<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | 眨眼的小星星</title><meta name="author" content="摘星的小月亮"><meta name="copyright" content="摘星的小月亮"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="描述">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://luckycyyyy.github.io/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="眨眼的小星星">
<meta property="og:description" content="描述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg">
<meta property="article:published_time" content="2024-05-09T02:06:18.000Z">
<meta property="article:modified_time" content="2024-06-05T08:11:07.726Z">
<meta property="article:author" content="摘星的小月亮">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://luckycyyyy.github.io/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-05 16:11:07'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head.jpg" onerror="onerror=null;src='/img/1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/travel/"><i class="fa-fw fas fa-globe-americas"></i><span> 旅行</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="眨眼的小星星"><span class="site-name">眨眼的小星星</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/travel/"><i class="fa-fw fas fa-globe-americas"></i><span> 旅行</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-09T02:06:18.000Z" title="发表于 2024-05-09 10:06:18">2024-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-05T08:11:07.726Z" title="更新于 2024-06-05 16:11:07">2024-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="绪论">绪论</h1>
<h2 id="概念">概念</h2>
<p><strong>数据</strong>：所有能输入到计算机中并被计算机程序加工、处理的符号的总称。如：整数、实数、字符、声音、图象、图形等。</p>
<p><strong>数据项</strong>：数据的不可分割的最小单位</p>
<p><strong>数据元素</strong>：数据的基本单位，一个数据元素可以由若干个数据项组成</p>
<p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集</p>
<p><strong>数据结构</strong>：相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p><strong>结构</strong>：数据元素之间的关系称为结构。</p>
<p><strong>数据类型</strong>：是一个值的集合和定义在这个值上的一组操作的总称。</p>
<ol type="1">
<li>原子类型(如：int,char,float等)</li>
<li>结构类型(如：数组,结构,联合体等）</li>
</ol>
<h2 id="抽象数据类型">抽象数据类型</h2>
<p><strong>抽象数据类型（ADT）</strong>：与计算机的实现无关的数据类型</p>
<p>形式定义：</p>
<p>ADT 抽象数据类型名 {</p>
<ol type="1">
<li><p>数据对象</p></li>
<li><p>数据关系:一个或多个关系</p></li>
<li><p>基本操作：一组基本操作/运算</p></li>
</ol>
<p>} ADT 抽象数据类型名</p>
<p>其中数据对象和数据关系的定义用<strong>伪码</strong>描述，基本操作的定义格式为：</p>
<p>基本操作名（参数表）</p>
<p>​ 初始条件：<初始条件描述></p>
<p>​ 操作结果：<操作结果描述></p>
<p>参数表中有两种操作：</p>
<ol type="1">
<li>赋值参数：只为操作提供输入值</li>
<li>引用参数：以&amp;打头，除可提供输入值外，还将返回操作结果</li>
</ol>
<h2 id="算法与算法分析">算法与算法分析</h2>
<p>算法的特征：</p>
<ol type="1">
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入：有0或多个输入量</li>
<li>输出：至少有一个输出量</li>
</ol>
<p>算法设计要求：</p>
<ol type="1">
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效与低存储量</li>
</ol>
<p>时间复杂度比较</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281632685.png" style="zoom: 50%;" /></p>
<h1 id="线性表">线性表</h1>
<h2 id="adt">ADT</h2>
<p>ADT List</p>
<p>{</p>
<p>数据对象：<span
class="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n&gt;=0\right\}\)</span></p>
<p>数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|
a_{i-1},a_i∈D,i=2,...n\right\}\)</span></p>
<p>基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitList</span>(&amp;L) <span class="comment">//构造空表L。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyList</span>(&amp;L) <span class="comment">//销毁线性表L</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearList</span>(&amp;L) <span class="comment">//置L为空表</span></span><br><span class="line"><span class="number">4.L</span>istEmpty(L) <span class="comment">//判断L是否为空表</span></span><br><span class="line"><span class="number">5.L</span>istLength(L) <span class="comment">//求表L的长度</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetElem</span>(L,i,&amp;e) <span class="comment">//取元素ai,由e返回ai</span></span><br><span class="line"><span class="number">7.L</span>ocateElem(L,e,<span class="built_in">compare</span>()) <span class="comment">//查找符合条件的元素</span></span><br><span class="line"><span class="number">8.L</span>istInsert(&amp;L,i,e) <span class="comment">//元素ai之前插入新元素e</span></span><br><span class="line"><span class="number">9.L</span>istDelete(&amp;L,i,&amp;e) <span class="comment">//删除第i个元素</span></span><br></pre></td></tr></table></figure>
<p>}ADT List</p>
<h2 id="顺序存储结构">顺序存储结构</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">    <span class="type">int</span> listsize;<span class="comment">//当前分配的存储容量</span></span><br><span class="line">&#125;Sqlist</span><br></pre></td></tr></table></figure>
<h3 id="插入操作">插入操作</h3>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中的第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;<span class="comment">//i不合法</span></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt; L.listsize)<span class="comment">//当前存储空间已满，增加存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(L.elem,(L.listsize + ADD)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += ADD;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(l.elem[i - <span class="number">1</span>]);<span class="comment">//q是待插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; p--)</span><br><span class="line">    	*(p + <span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>​ 设共有n个元素，在各个位置插入元素的概率相同，为<span
class="math inline">\(p=\frac{1}{n +
1}\)</span>，则插入一个元素时移动的平均值为<span
class="math inline">\(\sum\limits_{i=1}^{n+1}p(n-i+1)=\frac{n}{2}\)</span></p>
<h3 id="删除操作">删除操作</h3>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中删除第i个元素，并用e返回其值</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelte_Sq</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;<span class="comment">//如果i不合法</span></span><br><span class="line">    p = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = *p;</span><br><span class="line">    q = L.elem + L.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(++p; p &lt;= q; ++p)</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>​ 设共有n个元素，在各个地方删除元素的概率为<span
class="math inline">\(p=\frac{1}{n}\)</span>，则删除一个元素时移动元素的平均值为<span
class="math inline">\(\sum\limits_{i=1}^{n}p(n-i) =
\frac{n-1}{2}\)</span>​</p>
<h3 id="合并操作">合并操作</h3>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线性表Lb中的且不再La中的元素合并到La中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(Sqlist&amp; La, Sqlist&amp; Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, i, e);<span class="comment">//从Lb中取第i个元素赋值给e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La, e, equal))</span><br><span class="line">        	<span class="built_in">ListInsert</span>(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并并排序操作">合并并排序操作</h3>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并非递减排序线性表La和Lb，得到Lc并且Lc按非递减排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(Sqlist La, Sqlist Lb, Sqlist&amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = j = k = <span class="number">0</span>;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len &amp;&amp; j &lt;= Lb_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Getelem</span>(La, i, ai); <span class="built_in">Getelem</span>(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj) </span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= La_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(La, i++, ai);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= Lb_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(Lb, j++, bj);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序结构存储的评价">顺序结构存储的评价</h3>
<ol type="1">
<li>优点
<ol type="1">
<li>是一种随机存取结构，存取任何元素的时间是一个常数，速度快</li>
<li>结构简单，逻辑上相邻的元素，物理上也是相邻的</li>
<li>不使用指针，节省存储空间</li>
</ol></li>
<li>缺点
<ol type="1">
<li>插入和删除需要移动大量数据，消耗大量时间</li>
<li>需要一块连续的空间</li>
<li>插入元素时可能会“溢出”</li>
<li>自由区中的存储空间不能被其他数据占用（共享）</li>
</ol></li>
</ol>
<h2 id="链式存储结构">链式存储结构</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125;node, *Linklist;</span><br></pre></td></tr></table></figure>
<h3 id="建立单链表">建立单链表</h3>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“先进先出”（头插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, tail, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    tail = head;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“后进先出&quot;（尾插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* create2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建立递增有序链表">建立递增有序链表</h3>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create3</span>(<span class="keyword">struct</span> node* head, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    q = <span class="literal">NULL</span>, p = head;<span class="comment">//扫描，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//空表</span></span><br><span class="line">            head = s;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//尾插</span></span><br><span class="line">            q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//头插</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        head = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//其他正常情况的插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create4</span><span class="params">(<span class="keyword">struct</span> node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">//可以直接插入，不讨论</span></span><br><span class="line">    q-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作-1">插入操作</h3>
<p>​ 伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在i之前插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在i之后插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作-1">删除操作</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在带表头节点的链表中删除值为e的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete1</span><span class="params">(stuct node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* p, *q;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在单链表中删除指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete2</span><span class="params">(<span class="keyword">struct</span> node* head, <span class="type">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = head;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;<span class="comment">//q是待删除结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并操作-1">合并操作</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个带头节点的链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">Merge</span>(<span class="keyword">struct</span> node* La, <span class="keyword">struct</span> node* Lb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* pa, pb, pc;</span><br><span class="line">    pa = La-&gt;next, pb = Lb-&gt;next;</span><br><span class="line">    pc = La;</span><br><span class="line">    <span class="built_in">free</span>(Lb);<span class="comment">//释放Lb的头指针</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa) pc-&gt;next = pa;</span><br><span class="line">    <span class="keyword">else</span>  pc-&gt;next = pb; </span><br><span class="line">    <span class="keyword">return</span> La;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式存储结构评价">链式存储结构评价</h3>
<ol type="1">
<li>优点：灵活地增加/插入，删除操作</li>
<li>缺点：使用显式顺序指针代替隐式的相邻存储的位置关系，增加了存储空间</li>
</ol>
<h2 id="循环链表">循环链表</h2>
<ol type="1">
<li><p>一般形式</p>
<ol type="1">
<li><p>带头结点的非空循环单链表，有：</p>
<p><code>head-&gt;next != head, head != NULL</code></p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405291607660.png" /></p>
<ol type="1">
<li><p>带表头结点的空循环单链表，有：</p>
<p><code>head-&gt;next == head, head != NULL</code></p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048524.png" /></p></li>
<li><p>只有尾节点（带头）</p>
<ol type="1">
<li><p>非空表，有：</p>
<p><code>tail-&gt;data ==an</code></p>
<p><code>tail-&gt;next指向表头结点</code></p>
<p><code>tail-&gt;next-&gt;next指向首节点</code></p>
<p><code>tail-&gt;next-&gt;next-&gt;data == a1</code></p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048085.png" /></p>
<ol type="1">
<li><p>空表，有：</p>
<p><code>tail-&gt;next == tail</code></p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048479.png" /></p>
<ol type="1">
<li>两循环链表收尾相连(时间复杂度<code>O(1)</code>）</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048842.png" /></p></li>
</ol>
<p>​ <code>p2 = tail2-&gt;next</code></p>
<p>​ <code>tail2-&gt;next = tail1-&gt;next</code></p>
<p>​ <code>tail1-&gt;next = p2-&gt;next</code></p>
<p>​ <code>free(p2)</code></p>
<h2 id="双向链表">双向链表</h2>
<ol type="1">
<li><p>非空表</p>
<figure>
<img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047040.png"
alt="image-20240529163639637" />
<figcaption aria-hidden="true">image-20240529163639637</figcaption>
</figure>
<p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p>
<p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p>
<p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == NULL</code></p></li>
<li><p>空表</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047672.png" /></p>
<p>​ <code>L-&gt;next == L-&gt;prior == NULL</code></p></li>
</ol>
<h2 id="双向循环链表">双向循环链表</h2>
<ol type="1">
<li><p>非空表</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047950.png" /></p>
<p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p>
<p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p>
<p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == L</code></p></li>
<li><p>空表</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047389.png" /></p>
<p>​ <code>L-&gt;next == L-&gt;prior == L</code></p></li>
</ol>
<h2 id="各链表比较">各链表比较</h2>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292049549.png" /></p>
<h1 id="栈">栈</h1>
<p>栈：限定在表尾做插入、删除的线性表 ---“后进先出”</p>
<h2 id="adt-1">ADT</h2>
<p>ADT Stack</p>
<p>{</p>
<p>​ 数据对象：<span
class="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq
0\right\}\)</span></p>
<p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|
a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<span
class="math inline">\(a_n\)</span>端为栈顶端，<span
class="math inline">\(a_1\)</span>端为栈底</p>
<p>​ 基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitStack</span>(&amp;S) <span class="comment">//构造一个空栈。 </span></span><br><span class="line"><span class="number">2.</span><span class="built_in">ClearStack</span>(&amp;S) <span class="comment">//置s为空栈。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">DestroyStack</span>(&amp;S) <span class="comment">//栈s被销毁</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">Push</span>(&amp;S,e) <span class="comment">//元素e进栈S。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">Pop</span>(&amp;S,&amp;e) <span class="comment">//删除栈S的顶元素，并送入e 。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetTop</span>(S,&amp;e) <span class="comment">//将非空栈S的栈顶元素拷贝到e（与（4）的Pop操作是不同的）。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">StackEmpty</span>(&amp;S) <span class="comment">//判断s是否为空栈。若s为空栈,则返回值为true；否则为false。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">StackLength</span>(S) <span class="comment">//栈S的长度</span></span><br></pre></td></tr></table></figure>
<p>}ADT Stack</p>
<h2 id="栈的输出特点">栈的输出特点</h2>
<p>一般地，输入序列<span
class="math inline">\((...,a_i,...,a_j,...,a_k)\)</span>到栈中，不能得到<span
class="math inline">\((...,a_k,...,a_i,...,a_j)\)</span>​</p>
<h2 id="栈的存储结构">栈的存储结构</h2>
<p>栈的范围为<code>s[0...maxlen- 1]</code></p>
<ol type="1">
<li><p>顶指针指向栈顶元素所在的位置</p>
<p>栈顶元素：s[top]</p>
<p>进栈：先对top + 1，再将新数据指向top</p>
<p>出栈：先取栈顶元素，再对top - 1</p>
<p>空栈：<code>top == -1</code></p>
<p>非空栈：<code>top &gt;= 0</code></p>
<p>满栈：<code>top == maxlen - 1</code></p></li>
<li><p>顶指针指向顶元素上的一空位置</p>
<p>栈顶元素：s[top - 1]</p>
<p>进栈：先将新数据指向top，再对top + 1</p>
<p>出栈：先对top - 1，再取栈顶元素</p>
<p>空栈：<code>top == 0</code></p>
<p>非空栈：<code>top &gt;= 0</code></p>
<p>满栈：<code>top == maxlen</code></p></li>
</ol>
<p><strong><span
class="math inline">\(\color{red}{顺序栈规定top指向栈元素上一空位置}\)</span>​</strong></p>
<h2 id="顺序栈">顺序栈</h2>
<p>存储表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p>初始化栈：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base =(SElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SElemType)*STACK_INIT_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//内存分配失败</span></span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进栈：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果内存不够</span></span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize) </span><br><span class="line">    &#123;</span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(S.base,(S.stacksize + STACK_INIT_SIZE)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINITSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    *(S.top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;<span class="comment">//如果栈为空</span></span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式栈">链式栈</h2>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292207525.png" /></p>
<p>让top指向an，进栈将新节点作为首节点，出栈删除首节点，保证进出栈时间为常数</p>
<h2 id="栈的应用">栈的应用</h2>
<h3 id="数制转换">数制转换</h3>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292226270.png" /></p>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,N);</span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, N % <span class="number">8</span>);</span><br><span class="line">        N /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号匹配">括号匹配</h3>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292231643.png" /></p>
<h3 id="表达式求值">表达式求值</h3>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292253188.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292254637.png" /></p>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OperandType <span class="title">EvaluateExpression</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR); <span class="built_in">Push</span>(OPTR, <span class="string">&#x27;#&#x27;</span>);<span class="comment">//初始化操作符的栈</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPND); c = <span class="built_in">getchar</span>();<span class="comment">//初始化操作数的栈</span></span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(c, OP))<span class="comment">//如果不是运算符就进栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(OPND, c);</span><br><span class="line">            c = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), c))<span class="comment">//判断优先级</span></span><br><span class="line">             	<span class="comment">//栈顶优先级低</span></span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>&lt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            		Push(OPRT, c);</span></span><br><span class="line"><span class="string">            		c = getchar();</span></span><br><span class="line"><span class="string">            		break;</span></span><br><span class="line"><span class="string">            	//脱括号并接收下一个字符</span></span><br><span class="line"><span class="string">            	case&#x27;</span>=<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            		Pop(OPRT, x);</span></span><br><span class="line"><span class="string">            		c = getchar();</span></span><br><span class="line"><span class="string">            		break;</span></span><br><span class="line"><span class="string">               //退栈并将运算符结果入栈</span></span><br><span class="line"><span class="string">            	case&#x27;</span>&gt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            		Pop(OPRT, theta);</span></span><br><span class="line"><span class="string">            		Pop(OPND, b);</span></span><br><span class="line"><span class="string">            		Pop(OPND, a);</span></span><br><span class="line"><span class="string">            		Push(OPND, Operate(a, theta, b));</span></span><br><span class="line"><span class="string">            		break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return GetTop(OPND);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="队列">队列</h1>
<p>队列：只允许在表的一端插入一端删除的数据结构 ---“先进先出”</p>
<h2 id="adt-2">ADT</h2>
<p>ADT Queue</p>
<p>{</p>
<p>​ 数据对象：<span
class="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq
0\right\}\)</span></p>
<p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|
a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<span
class="math inline">\(a_n\)</span>端为队列尾，<span
class="math inline">\(a_1\)</span>端为队列头</p>
<p>​ 基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitQueue</span>(&amp;Q) <span class="comment">//初始化,构造空队列。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyQueue</span>(&amp;Q) <span class="comment">//销毁Q队列。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearQueue</span>(&amp;Q) <span class="comment">//置Q为空队列。</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">QueueEmpty</span>(Q) <span class="comment">//判断Q是否为空队列。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">EnQueue</span>(&amp;Q,e) <span class="comment">//将e插入队列Q的尾端。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">DeQueue</span>(&amp;Q,&amp;e) <span class="comment">//取走队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">GetHead</span>(Q,&amp;e) <span class="comment">//读取队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">QueueLengrh</span>(Q) <span class="comment">//返回队列长度</span></span><br></pre></td></tr></table></figure>
<p>}ADT Queue</p>
<h2 id="链式队列">链式队列</h2>
<p>用带头节点的单链表表示队列</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292334133.png" /></p>
<p>存储表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span>* next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>初始化队列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349895.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349851.png" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;<span class="comment">//头插</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="comment">//如果是只有一个节点的情况</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环队列">循环队列</h2>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_61959780/article/details/127332940?app_version=6.2.9&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127332940%22%2C%22source%22%3A%22luckyYY520%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">大佬的博客，写的很清楚</a></p>
<h1 id="数组">数组</h1>
<h2 id="数组的递归定义">数组的递归定义</h2>
<ul>
<li><p>一维数组：<span
class="math inline">\((a_1,a_2,...,a_n)\)</span>，其中<span
class="math inline">\(a_i\)</span>为数据元素<span
class="math inline">\(1\leq i\leq n\)</span></p></li>
<li><p>二维数组：<span
class="math inline">\((\alpha_1,\alpha_2,...,\alpha_m)\)</span>，其中<span
class="math inline">\(\alpha_i = (a_{i1},
a_{i2},...,a_{in})\)</span>为行向量，<span class="math inline">\(1\leq
i\leq m\)</span></p></li>
<li><p>三维数组：<span
class="math inline">\((\beta_1,\beta_2,...,\beta_p)\)</span>，其中<span
class="math inline">\(\beta_k=(\alpha_1,\alpha_2,...,\alpha_m)\)</span>，<span
class="math inline">\(1\leq k\leq p\)</span>​</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301404268.png" /></p></li>
</ul>
<h2 id="数组的顺序表示">数组的顺序表示</h2>
<ol type="1">
<li><p>以行序为主序的顺序存储方式</p>
<p><span
class="math inline">\(\color{red}{左边的下标后变化，右边的下标先变化}\)</span></p></li>
<li><p>以列序为主序的顺序存储方式</p>
<p><span
class="math inline">\(\color{red}{左边的下标先变化，右边的下标后变化}\)</span></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301413278.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301415139.png" /></p></li>
</ol>
<h2 id="数组的映像函数">数组的映像函数</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301418472.png" style="zoom: 67%;" /></p>
<ol type="1">
<li><p>以行序为主序，<span
class="math inline">\(a[i][j]\)</span>的地址为：</p>
<p><span class="math inline">\(Loc(i, j) = Loc(1, 1)+((i - 1)*n +(j -
1))*s\)</span></p></li>
<li><p>以列序为主序，<span
class="math inline">\(a[i][j]\)</span>的地址为：</p>
<p><span
class="math inline">\(Loc(i,j)=Loc(1,1)+((j-1)*m+(i-1))*s\)</span></p></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301422772.png" style="zoom:67%;" /></p>
<ol type="1">
<li><p>以行序为主序，<span
class="math inline">\(a[k][i][j]\)</span>的地址为：</p>
<p><span
class="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((k-1)*m*n+(i-1)*m+(j-1))*s\)</span></p></li>
<li><p>以列序为主序，<span
class="math inline">\(a[k][i][j]\)</span>的地址为：</p>
<p><span
class="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((j-1)*p*m+(i-1)*p+k-1)*s\)</span></p></li>
</ol>
<h2 id="矩阵的压缩存储">矩阵的压缩存储</h2>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301905856.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301909749.png" /></p>
<p><span class="math inline">\(a_{ij}\)</span>在SA中的序号：</p>
<p>$k(i,j) = <span
class="math display">\[$\left\{\begin{aligned}i(i-1)/2 + j&amp; &amp;i
\geq j\\ j(j-1)/2+i&amp; &amp;i&lt;j\end{aligned}\right.\]</span>​</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301916257.png" /></p>
<p>任意<span class="math inline">\(a_{ij}\neq
0\)</span>，在SA中的序号：<span
class="math inline">\(k=((i-1)*3-1)+(j-i+2)=2i+j-2\)</span></p>
<p><span class="math inline">\(A[i,j]=\left\{\begin{aligned}k&amp;
&amp;|i-j|\leq 1\\ 0&amp; &amp;其他\end{aligned}\right.\)</span></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301941684.jpg" /></p>
<h2 id="稀疏矩阵的存储">稀疏矩阵的存储</h2>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405302304289.png" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;<span class="comment">//非零元的下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];<span class="comment">//非零元三元组表</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数和非零元的个数</span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"><span class="comment">//求稀疏矩阵的转置</span></span><br><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.mu = M.nu, T.nu = M.mu, T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span>(T.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt;= M.nu; col++) num[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t &lt;= M.tu; t++) ++num[M.data[t].j];</span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">2</span>;col &lt;= M.nu; ++col) cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= M.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j;</span><br><span class="line">            T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[p].e;</span><br><span class="line">            ++cpot[col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十字链接表">十字链接表</h2>
<h1 id="二叉树">二叉树</h1>
<h2 id="二叉树的性质">二叉树的性质</h2>
<ol type="1">
<li>二叉树第i层，最多有<span
class="math inline">\(2^{i-1}\)</span>个结点</li>
<li>深度为k的二叉树，最多有<span class="math inline">\(2^k -
1\)</span>个结点</li>
<li><span class="math inline">\(n_0=n_2+1\)</span></li>
<li>n个结点的满二叉树深度为<span
class="math inline">\(log_2(n+1)\)</span></li>
<li>顺序编号的满二叉树<span class="math inline">\(1,2,...,n\)</span>
<ul>
<li>结点i的左孩子为2i，右孩子为2i+1</li>
<li>结点i的双亲为<span class="math inline">\(\lfloor
i/2\rfloor\)</span></li>
<li>结点i的层号<span class="math inline">\(\lfloor
log_2i\rfloor+1=\lceil log_2(n+1)\rceil\)</span></li>
</ul></li>
</ol>
<h2 id="二叉树的存储">二叉树的存储</h2>
<h3 id="顺序存储">顺序存储</h3>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323914.png" /></p>
<h3 id="链式存储">链式存储</h3>
<ol type="1">
<li>二叉链表</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>三叉链表</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* parent;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>静态链表</li>
</ol>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<span
class="math inline">\(O(n)\)</span>​</p>
<blockquote>
<p>前序+中序 / 中序+后序可以唯一确定一个二叉树</p>
</blockquote>
<h3 id="先序遍历">先序遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历">中序遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历">非递归遍历</h3>
<p>中序遍历：</p>
<ol type="1">
<li>第一次访问到根节点不访问，直接入栈</li>
<li>中序遍历左子树，左子树遍历结束之后，第二次遇到根节点，退栈进行访问，然后中序遍历右子树</li>
<li>退栈时栈为空结束</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历：</p>
<ol type="1">
<li>沿着根的左孩子依次入栈，直到左孩子为空</li>
<li>如果没有右孩子，或者右孩子已经访问过，就访问该根节点</li>
<li>栈顶元素出栈</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree last;<span class="comment">//上一个访问的节点</span></span><br><span class="line">    BitTree st[maxlength];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        st[top++] = t;</span><br><span class="line">        t = t-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">		BitTree tmp = st[--top];</span><br><span class="line">        <span class="keyword">if</span>((tmp-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; tmp-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">/*如果左右孩子均为空*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == last)<span class="comment">/*右孩子已经访问完*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == <span class="literal">NULL</span> &amp;&amp; tmp-&gt;lchild == last))<span class="comment">/*右孩子为空，左孩子访问了*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, tmp-&gt;data);<span class="comment">//访问</span></span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BitTree r = tmp-&gt;rchild;</span><br><span class="line">            <span class="keyword">while</span>(r)</span><br><span class="line">            &#123;</span><br><span class="line">                st[top++] = r;</span><br><span class="line">                r = r-&gt;l·child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历">层序遍历</h3>
<p>原理
：使用队列进行存储，将根节点放入队列中，并且访问之后将该节点的左右孩子加入队列中</p>
<h2 id="创建二叉树">创建二叉树</h2>
<h3 id="递归法">递归法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == #) root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (BiTree)<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        root-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归法">非递归法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        q = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        q-&gt;data = e;</span><br><span class="line">        q-&gt;lchild = <span class="literal">NULL</span>, q-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        s[i] = q;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) root = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">2</span>) s[j]-&gt;rchild = q;</span><br><span class="line">            <span class="keyword">else</span> s[j]-&gt;lchild = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线索二叉树">线索二叉树</h2>
<h3 id="概念-1">概念</h3>
<p>规则：</p>
<ol type="1">
<li>若结点的左子树为空，则该结点的左孩子指向其前驱结点</li>
<li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li>
</ol>
<p>为了区别lchild/rchild是指向左右孩子还是前/后驱结点，添加标志位ltag,
rtag：</p>
<ol type="1">
<li><code>ltag == 0</code>，指向左孩子；<code>ltag == 1</code>，指向前驱结点</li>
<li><code>rtag == 0</code>，指向右孩子；<code>rtag == 1</code>，指向后继结点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311434403.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311443551.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311444734.png" /></p>
<h3 id="线索化二叉树">线索化二叉树</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Thread</span>* lchild, rchild;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThreadTree</span><span class="params">(<span class="keyword">struct</span> Thread* node, <span class="keyword">struct</span> Thread* pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;lchild, pre);</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) node-&gt;ltag = <span class="number">0</span>;<span class="comment">//左孩子不是线索</span></span><br><span class="line">    <span class="keyword">else</span> node-&gt;ltag = <span class="number">1</span>, node-&gt;lchild = pre;</span><br><span class="line">    <span class="comment">//处理前驱结点</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) </span><br><span class="line">        pre-&gt;rchild = node, pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;rchild, pre);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历线索二叉树">遍历线索二叉树</h3>
<p>前序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span> *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//有左孩子</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有左孩子，指向右孩子或者后继结点</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BitNode</span>* p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;<span class="comment">//找到最左边的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rchild)<span class="comment">//存在后继结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>) p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//找到最左边的结点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = p-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树和森林">树和森林</h1>
<h2 id="树的表示形式">树的表示形式</h2>
<ol type="1">
<li>广义表</li>
</ol>
<p><img
src="C:\Users\cy\AppData\Roaming\Typora\typora-user-images\image-20240604140255820.png" />
2. 嵌套集合</p>
<p><img
src="C:\Users\cy\AppData\Roaming\Typora\typora-user-images\image-20240604140358990.png" /></p>
<ol start="3" type="1">
<li>凹入表/目录表</li>
</ol>
<p><img
src="C:\Users\cy\AppData\Roaming\Typora\typora-user-images\image-20240604140429890.png" /></p>
<h2 id="树的存储结构">树的存储结构</h2>
<ol type="1">
<li>双亲表示法/数组表示法/顺序表示法</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407567.png" style="zoom:67%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">snode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;t[maxlength + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>孩子表示法/链接表表示法</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407745.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408154.png" /></p>
<ol start="3" type="1">
<li>孩子兄弟表示法/二叉树表示法/二叉链表</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408655.png" /></p>
<ol start="4" type="1">
<li>孩子链表表示法/单链表表示法</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408590.png" /></p>
<ol start="5" type="1">
<li>带双亲的孩子链表表示法</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408034.png" /></p>
<h2 id="森林树和二叉树的转换">森林、树和二叉树的转换</h2>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021424154.png" /></p>
<h2 id="树和森林的遍历">树和森林的遍历</h2>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323277.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041324802.png" /></p>
<h2 id="哈夫曼树">哈夫曼树</h2>
<p>树T的路径长度：PL(T)从树T的跟到其余每个结点的路径长度之和</p>
<p>树的带权路径长度：WPL(T)每个叶子的权与根到该叶子的路径长度的乘积之和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HTNode, *HuffmanCode;<span class="comment">//动态分配数组存储哈夫曼树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;<span class="comment">//存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode &amp;HC, <span class="type">int</span> *w, <span class="type">int</span> n)</span><span class="comment">/*w存放n个字符的权值*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HTNode) * (m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(p = HT + <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= n; i++, p++, w++)<span class="comment">//0号单元未用</span></span><br><span class="line">    	*p = &#123;*w, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= m; i++, p++) *p = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);<span class="comment">//在HT[1,..,i-1]中选择parent为0且weight最小的两个结点，其序号分别是s1,s2</span></span><br><span class="line">        HT[s1].parent = i, HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1, HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight +HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从叶子到根逆向求每个字符的哈夫曼编码*/</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[i].parent)</span><br><span class="line">        	<span class="keyword">if</span>(HT[f].lchild == c) cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        	<span class="keyword">else</span> cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        HC[i] = (<span class="type">char</span>*)<span class="built_in">mallov</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (n - start));<span class="comment">//为编码开辟空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图">图</h1>
<h2 id="概念-2">概念</h2>
<p>强连通图：图G中每对结点都存在路径</p>
<p>强连通分量：图G'是图G的极大连通子图，G'是G的一个强连通分量</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002704.png" /></p>
<h2 id="图的存储结构">图的存储结构</h2>
<ol type="1">
<li>邻接矩阵
<ul>
<li>无向图中<span class="math inline">\(v_i\)</span> 的度<span
class="math inline">\(TD=\sum\limits_{j=1}^{n}M[i][j]=\sum\limits_{i=1}^{n}M[i][j]\)</span></li>
<li>有向图中<span class="math inline">\(v_i\)</span> 的入度<span
class="math inline">\(ID =
\sum\limits_{i=1}^{n}M[i][j]\)</span>(每一列的和)，出度<span
class="math inline">\(OD =
\sum\limits_{j=1}^{n}M[i][j]\)</span>(每一行的和)</li>
</ul></li>
<li>邻接表/逆邻接表</li>
<li>十字链表</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002846.png" /></p>
<ol start="4" type="1">
<li><p>邻接多重表​</p>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TL411b7V3/?spm_id_from=333.337.search-card.all.click">具体步骤见这个视频</a></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032019350.png" /></p></li>
</ol>
<p><strong>存储结构的优缺点</strong></p>
<p><strong>邻接矩阵</strong></p>
<p>优点：</p>
<ol type="1">
<li>简单直观，好理解</li>
<li>便于计算一对顶点间是否有边，并且找到所有的邻接点</li>
<li>方便计算一个顶点的度</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>不利于增加或者删除节点</li>
<li>存储稀疏图<span
class="math inline">\((e&lt;nlogn)\)</span>较浪费空间</li>
<li>在统计边数等操作方面时间复杂度大</li>
</ol>
<p><strong>邻接表</strong></p>
<p>缺点：</p>
<ol type="1">
<li>求节点度困难</li>
<li>每条边都要存两遍（无向图）</li>
</ol>
<h2 id="图的遍历">图的遍历</h2>
<p>DFS/BFS时间复杂度</p>
<ol type="1">
<li>邻接矩阵存储<span class="math inline">\(O(n^2)\)</span></li>
<li>邻接表存储<span class="math inline">\(O(n+e)\)</span></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038343.png" style="zoom: 67%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038662.png" style="zoom: 60%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032040296.png" style="zoom: 70%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032041338.png" style="zoom: 67%;" /></p>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="prim">Prim</h3>
<p>时间复杂度：<span
class="math inline">\(O(n^2)\)</span>，适合稠密图</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312202.jpg" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph G, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vertexNum; i++)<span class="comment">//遍历所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        shortEdge[i].lowcost = G.arc[start][i];<span class="comment">//初始化最短路的数组</span></span><br><span class="line">        shortEdge[i].adjvex = start;<span class="comment">//存储这个路径距离中这个节点的上一个节点  </span></span><br><span class="line">    &#125;</span><br><span class="line">    shortEdge[start].lowcost = <span class="number">0</span>;<span class="comment">//将start放入集合U</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vertexNum - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">minEdge</span>(shortEdge, G.vertexNum);<span class="comment">//寻找最短边的邻接点k</span></span><br><span class="line">        <span class="built_in">outputMST</span>(k, shortEdge[k]);<span class="comment">//输出最小生成树的路径</span></span><br><span class="line">        shortEdge[k].lowcast = <span class="number">0</span>;<span class="comment">//将k加入集合U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vertexNum; j++)<span class="comment">//调整shortEdge数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.arc[k][j] &lt; shortEdge[j].lowcast)</span><br><span class="line">            &#123;</span><br><span class="line">                shortEdge[j].lowcast = G.arc[k][j];</span><br><span class="line">                shortEdge[j].adjvex = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>时间复杂度：<span class="math inline">\(O(eloge)\)</span></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312333.jpg" /></p>
<h2 id="拓扑排序">拓扑排序</h2>
<blockquote>
<p>有回路的有向图不存在拓扑排序</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312495.png" /></p>
<h2 id="aoe网">AOE网</h2>
<blockquote>
<p>先求点，再求边</p>
</blockquote>
<p>工程完成的最短时间是从开始点到完成点的最长路径长度，路径长度最长的路径叫做关键路径，关键路径上的点为关键点--开始时间等于结束时间</p>
<p><a
href="%5B图-AOE网和关键路径_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV1dy421a7S1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef5e5127819460e26182982933cfa21e)">请参考这个视频</a></p>
<ol type="1">
<li>ve(事件/节点的最早开始时间)，拓扑排序，每次选取<strong>入度</strong>为0的点，更新与之相邻的结点，ve是最长的那条路径长度</li>
<li>vl(事件/节点的最晚开始时间)，初始化所有结点的vl为终点的ve，<strong>逆</strong>拓扑排序，每次选取<strong>出度</strong>为0的点，更新与之相邻的结点，vl是选择使vl最小的那条路</li>
<li>e(活动/边的最早开始时间)，与发出这条边的结点的ve一致</li>
<li>l(活动/边的最晚开始时间)，用这条边指向的结点的vl减去这条边的边权</li>
</ol>
<h2 id="最短路径">最短路径</h2>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<blockquote>
<p>解决单源最短路问题</p>
</blockquote>
<p><a
href="%5B图-最短路径-Dijkstra(迪杰斯特拉)算法_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.999.0.0&amp;vd_source=ef5e5127819460e26182982933cfa21e)">请参考这个视频</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//把起始点距离初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//用于找到当前距离起点最短的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新节点距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="floyd算法">Floyd算法</h3>
<p><a
href="%5B图-最短路径-Floyd(弗洛伊德)算法_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV19k4y1Q7Gj/?spm_id_from=333.788&amp;vd_source=ef5e5127819460e26182982933cfa21e)">请参考这个视频</a></p>
<blockquote>
<p>求任意两个节点间的最短路径</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph G, PathMatrix&amp; p[], DistanceMatrix&amp; D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">        &#123;</span><br><span class="line">            D[v][w] = G.arcs[v][w];</span><br><span class="line">            <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                P[v][w][u] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(D[v][w] &lt; INFINITY)</span><br><span class="line">                &#123;</span><br><span class="line">                    P[v][w][v] = <span class="literal">true</span>;</span><br><span class="line">                    P[v][w][w] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(D[v][u] + D[u][w] &lt; D[v][w])</span><br><span class="line">                &#123;</span><br><span class="line">                    D[v][w] = D[v][u] + D[u][w];</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        P[v][w][i] = P[v][u][i] || P[u][w][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找">查找</h1>
<h2 id="静态查找表">静态查找表</h2>
<h3 id="顺序查找法">顺序查找法</h3>
<ol type="1">
<li><p>不设置监视哨</p>
<p>判断条件：</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">1</span> &amp;&amp; k != ST.elem[i].key)	i--;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>设置监视哨</li>
</ol>
<p>​ <code>elem[0].key = k;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(k != ST.elem[i].key)	i--;</span><br></pre></td></tr></table></figure>
<p>ASL成功 = (n + 1) / 2</p>
<p>ASL失败：使用监视哨 = n + 1, 不使用监视哨 = n</p>
<h3 id="折半查找法">折半查找法</h3>
<p>相当于二分查找</p>
<h3 id="判定树">判定树</h3>
<p>描述折半查找过程的二叉树</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051340541.png" /></p>
<p>若判定树为满二叉树：<span class="math inline">\(ASL =
\frac{n+1}{n}log2(n + 1) - 1\)</span></p>
<p>证明：<img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051338386.jpg" /></p>
<h2 id="动态查找表">动态查找表</h2>
<h3
id="二叉排序树二叉查找树"><strong>二叉排序树（二叉查找树）</strong></h3>
<p>特点：如果二叉树的任一结点大于其非空左子树的所有结点，而小于其非空右子树的所有结点，则这棵二叉树称为二叉排序树。<strong><span
class="math inline">\({\color{red}(左小右大)}\)</span>​</strong></p>
<h4
id="删除二叉排序树中的结点"><strong><em>删除二叉排序树中的结点</em></strong></h4>
<p>设被删除的结点为*p，其双亲结点为*f，*s为*p的前驱结点，*p是*f的左孩子，有三种情况：</p>
<ol type="1">
<li><p>*p为叶子结点：直接删除</p></li>
<li><p>*p只有左孩子PL或者右孩子PR：让PL/PR为*f的左孩子</p></li>
<li><p>*p的左孩子PL和右孩子PR均不为空：</p>
<ol type="1">
<li><p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071134367.png" /></p></li>
<li><p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071135262.png" /></p></li>
</ol></li>
</ol>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是待删除的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果左子树为空，或者为叶子结点</span></span><br><span class="line">    &#123; q = p; p = p-&gt;rchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//如果右子树为空</span></span><br><span class="line">    &#123; q = p; p = p-&gt;lchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果左右子树均不为空 以方法二为例</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;<span class="comment">//设置s的双亲结点是q</span></span><br><span class="line">            s = s-&gt;rchild;<span class="comment">//遍历直到找到p的前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;<span class="comment">//将p替换成s</span></span><br><span class="line">        <span class="comment">//要判断是因为如果删除结点的左子树有右子树那么中序遍历的前驱结点是右孩子，否则前驱结点是左孩子，就会导致移动的不同</span></span><br><span class="line">        <span class="keyword">if</span>(p != q)<span class="comment">//表明删除节点的左子树有右子树</span></span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;<span class="comment">//不需要free因为原来的s占的是q-&gt;left，现在已经被替换了</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树avl树"><strong>平衡二叉树</strong>(<span
class="math inline">\(AVL\)</span>树)</h3>
<ol type="1">
<li>结点的平衡因子：结点的左右子树深度之差（左子树高度-右子树高度）</li>
<li>平衡二叉树：任意结点平衡因子的绝对值小于等于1的二叉树</li>
</ol>
<h4
id="高度一定的avl树所含最小节点个数">高度一定的AVL树所含最小节点个数</h4>
<p>S(h)表示深度为h的平衡二叉树所含有的最少节点个数</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051555220.png" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051556641.png" style="zoom: 67%;" /></p>
<h4
id="构造平衡二叉搜索树的方法"><strong><em>构造平衡二叉搜索树的方法</em></strong></h4>
<ul>
<li><p>左旋：向作左旋转，冲突的左孩变右孩</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081654715.png" /></p></li>
<li><p>右旋：向右旋转，冲突的右孩变左孩</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081656759.png" /></p></li>
<li><p><span class="math inline">\(LL\)</span>型，<span
class="math inline">\(RR\)</span>型，<span
class="math inline">\(LR\)</span>型，<span
class="math inline">\(RL\)</span>​型</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081714341.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081716342.png" /></p>
<ul>
<li><span class="math inline">\(LL\)</span>型：右旋</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715912.png" /></p>
<ul>
<li><span class="math inline">\(RR\)</span>​型：左旋</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081849686.png" /></p>
<ul>
<li><span class="math inline">\(LR\)</span>​型：先左旋左孩子，再右旋</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715436.png" /></p>
<ul>
<li><span class="math inline">\(RL\)</span>​型：先右旋右孩子，再左旋</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715357.png" /></p></li>
<li><p>插入结点时平衡失调，调整离删除结点最近的失衡结点即可</p>
<p>删除结点时平衡失调，依次对每个祖先进行检查和调整</p></li>
</ul>
<h3 id="哈希表">哈希表</h3>
<h4 id="构造哈希函数的方法"><em>构造哈希函数的方法</em></h4>
<ol type="1">
<li><p>直接定址法：取关键字或者关键字的某个线性函数值作为哈希地址</p></li>
<li><p>除留余数法：设哈希表HT[0,1,..,m-1]的表长为m，哈希地址为key除以p所得余数（
p为接近m的素数或为不包含20以内质因数的合数）</p></li>
<li><p>平方取中法：取关键字平方后的中间某几位为哈希地址</p></li>
<li><p>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址</p>
<ol type="1">
<li><p>边界折叠法：<span class="math inline">\(eg: k1 =
056439527\)</span>对应的地址为<span
class="math inline">\(650+439+725\)</span></p></li>
<li><p>移位折叠法：<span class="math inline">\(eg: k1 =
056439527\)</span>对应的地址为</p>
<p><span class="math inline">\(056+439+527\)</span></p></li>
</ol></li>
<li><p>数字分析法：如果哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干分布均匀的位组成哈希地址</p></li>
<li><p>随机数法：利用<span
class="math inline">\(random(key)\)</span>​</p></li>
</ol>
<h4 id="解决哈希冲突的方法"><em>解决哈希冲突的方法</em></h4>
<ol type="1">
<li>开放地址法
<ol type="1">
<li>线性嗅探再散列</li>
<li>二次嗅探再散列</li>
</ol></li>
<li>链地址法</li>
<li>建立公共溢出区</li>
<li>再哈希法</li>
</ol>
<h4 id="哈希化的效率"><strong><em>哈希化的效率</em></strong></h4>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405132118931.png" /></p>
<h4
id="哈希表的平均查找长度"><strong><em>哈希表的平均查找长度</em></strong></h4>
<p><a
href="%5B哈希表：线性探测法和链地址法求查找成功与不成功的平均查找长度_链地址法查找失败的平均查找长度怎么算-CSDN博客%5D(https://blog.csdn.net/KD35KD/article/details/107054474)">见此篇BLOG</a></p>
<p>散列表</p>
<p>查找成功的概率：</p>
<ul>
<li>分母：所有待插入的元素的个数</li>
<li>分子：每个位置元素出现的个数</li>
</ul>
<p>查找失败的概率：</p>
<ul>
<li>分母：mod的大小</li>
<li>分子：从0-m-1的每一个位置到下一个空位置需要查找的个数</li>
</ul>
<h1 id="排序">排序</h1>
<h2 id="插入排序稳定排序">插入排序（稳定排序）</h2>
<p>操作：将新的元素插入到已排序的数组中</p>
<p>时间复杂度：<span class="math inline">\(O(n^2)\)</span>​</p>
<ul>
<li><p>最好的情况：原n个记录递增有序</p>
<p>比较关键字次数：<span class="math inline">\(n-1\)</span>次</p>
<p>移动记录次数：<span
class="math inline">\(2(n-1)\)</span>次（将数据复制到a[0]又复制回来）</p></li>
<li><p>最坏的情况：原n个记录递减有序</p>
<p>比较关键字次数：<span class="math inline">\(\sum_\limits{i = 2}^n i =
2+3+...+n = \frac{(n-1)(n+2)}{2}\)</span></p>
<p>移动记录次数：<span class="math inline">\(\sum_\limits{i=2}^{n}
(i-1+2)=3+4+...+n=\frac{(n-1)(n+4)}{2}\)</span></p>
<p>（+2是因为监视哨，先复制一遍，再加到合适的位置）</p></li>
</ul>
<p>朴素版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序 </span></span><br><span class="line"><span class="comment">//对1-n进行排序(n表示的是数组的最后一个元素的下标，不是元素个数) </span></span><br><span class="line"><span class="comment">//在a[0]设置监视哨</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cur;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[<span class="number">0</span>] = a[i];</span><br><span class="line">		cur = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			a[cur + <span class="number">1</span>] = a[cur];</span><br><span class="line">			cur--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[cur + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>折半插入排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="comment">//优化了比较次数，但是只有当n很大时使用折半插入效率更高</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[<span class="number">0</span>] = a[i];</span><br><span class="line">		<span class="type">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>, m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high)<span class="comment">//利用二分法折半查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[m])	high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在high左边</span></span><br><span class="line">			<span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在low的右边</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//high + 1即是待插入的位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		a[high + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二路插入排序：</p>
<p>优点：可以减少移动的次数</p>
<p>操作：（排序长度为n的序列）相当于先开辟长度为n的数组，将该数组当做一个循环的空间，进行插入。</p>
<p>表插入排序：</p>
<h2 id="希尔排序colorred-不稳定排序">希尔排序<span
class="math inline">\(\color{red} {（不稳定排序）}\)</span></h2>
<p>操作：每次排序相隔gap的元素，不断缩小gap，直至gap ==
1，排序后退出循环</p>
<p>时间复杂度：<span class="math inline">\(O(n ^{1.3})\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--希尔排序  O(n^1.3)</span></span><br><span class="line"><span class="comment">//1. gap &gt; 1 预排序</span></span><br><span class="line"><span class="comment">//2. gap == 1 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> gap, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = gap + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[<span class="number">0</span>] = a[i];</span><br><span class="line">			<span class="type">int</span> cur = i - gap;</span><br><span class="line">			<span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				a[cur + gap] = a[cur];</span><br><span class="line">				cur -= gap;</span><br><span class="line">			&#125;</span><br><span class="line">			a[cur + gap] = a[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序colorred不稳定排序">快速排序<span
class="math inline">\(\color{red}{(不稳定排序)}\)</span></h2>
<p>操作：随机在数组中找一个数，利用递归，让左边的数都小于该数，右边的数都大于该数</p>
<ul>
<li>时间复杂度：<span
class="math inline">\(O(nlogn)\)</span>，最坏的情况下（序列基本有序）时间复杂度为<span
class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：快排需要一个栈做辅助空间，平均情况下需要<span
class="math inline">\(O(nlogn)\)</span>的空间，最坏的情况下，要递归n次，需要<span
class="math inline">\(O(n)\)</span>的空间</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, left, right);<span class="comment">//找到在left，mid，right三个下标下大小是中间的那个的下标</span></span><br><span class="line">	<span class="built_in">Swap</span>(a + keyi, a + left);</span><br><span class="line">	<span class="comment">//左边当key 右边先走 ；右边当key 左边先走</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">		&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">		&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">Swap</span>(a + left, a + right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Swap</span>(a + left, a + keyi);</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> part = <span class="built_in">PartSort</span>(a, begin, end);</span><br><span class="line">	<span class="built_in">QuickSort</span> (part + <span class="number">1</span>, end);</span><br><span class="line">	<span class="built_in">QuickSort</span>(begin, part - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是不是第2趟快排之后的结果：</p>
<p>判断左右两端的元素是否是最大的或者最小的</p>
<ol type="1">
<li>如果是，就再在中间找一个pivot</li>
<li>如果不是，就要找三个pivot</li>
</ol>
<h2 id="选择排序colorred不稳定排序">选择排序<span
class="math inline">\(\color{red}{(不稳定排序)}\)</span></h2>
<p>操作：每次选择未选择序列中最小的（最大的），放在已经排序的序列之后时间复杂度：</p>
<ul>
<li>比较次数：<span
class="math inline">\(\frac{n(n-1)}{2}\)</span>即<span
class="math inline">\(O(n^2)\)</span>​</li>
<li>移动次数：
<ul>
<li>最好的情况，一开始就是升序，不需要移动</li>
<li>最坏的情况：每次都需要移动（不是降序的时候），交换记录数为n-1对，移动记录数为3(n-1)（因为swap里面有三条语句）</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mini = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[mini]) mini = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Swap</span>(&amp;a[mini], &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序colorred不稳定排序">堆排序<span
class="math inline">\(\color{red}{(不稳定排序)}\)</span></h2>
<p>操作：升序建大堆，降序建小堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">			++child;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> child)</span><span class="comment">//造大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">			child = parent;</span><br><span class="line">			parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">AdjustUp</span>(a, i);</span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Swap</span>(a, a + end);</span><br><span class="line">		<span class="built_in">AdjustDown</span>(a, end , <span class="number">0</span>);</span><br><span class="line"><span class="comment">//因为end是交换过去的最后一个 所以循环应该到这个就结束 不应该传end+1</span></span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序稳定排序">归并排序（稳定排序）</h2>
<p>操作：将它们划分为长度均为1的子序列，然后逐步二路归并</p>
<p>时间复杂度：</p>
<ul>
<li>对n个记录的文件进行归并排序，共需要<span
class="math inline">\(log_2n\)</span>趟，每趟所需要比较的关键字次数不超过n，所以总比较次数为<span
class="math inline">\(O(nlogn)\)</span></li>
<li>每趟移动n个记录，移动次数为<span
class="math inline">\(O(nlogn)\)</span></li>
<li>归并排序需要一个大小为n的辅助空间</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin == end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(a, begin, mid, tmp);</span><br><span class="line">	<span class="built_in">MergeSort</span>(a, mid + <span class="number">1</span>, end, tmp);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin1 = begin, end1 = mid;</span><br><span class="line">	<span class="type">int</span> begin2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">	<span class="type">int</span> i = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">			tmp[i++] = a[begin1++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmp[i++] = a[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">		tmp[i++] = a[begin1++];</span><br><span class="line">	<span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">		tmp[i++] = a[begin2++];</span><br><span class="line">	<span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序稳定排序">基数排序（稳定排序）</h2>
<p>操作：</p>
<ul>
<li>MSD：高位有效优先</li>
<li>LSD：低位有效优先</li>
</ul>
<p>MSD对应数字排序：下面以个位为例</p>
<p>数组形式：</p>
<video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281546971.mp4" width="100%" height="100%" controls="controls">
</video>
<p>队列形式：</p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936416.png" /></p>
<p><img
src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936776.png" /></p>
<p>时间复杂度：设数字的有效位数为d</p>
<ul>
<li>需要d趟回收分配，每趟分配运算时间为<span
class="math inline">\(O(n)\)</span></li>
<li>收集：基数为rd,即rd个队列。从rd个队列中收集，运算时间O(rd)</li>
<li>一趟分配、回收运算时间O(n+rd), 时间复杂度O(d*(n+rd))</li>
<li>辅助空间：每个队列首尾2个指针，共2rd个指针；n个记录需要n个指针域。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Luckycyyyy.github.io">摘星的小月亮</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://luckycyyyy.github.io/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://luckycyyyy.github.io/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Luckycyyyy.github.io" target="_blank">眨眼的小星星</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/" title="曲线积分与曲面积分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/9.jpg" onerror="onerror=null;src='/img/1.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">曲线积分与曲面积分</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/07/%E7%AE%97%E6%B3%95/" title="算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/4.jpg" onerror="onerror=null;src='/img/1.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/1.jpg'" alt="avatar"/></div><div class="author-info__name">摘星的小月亮</div><div class="author-info__description">记录每一天的美好</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">算法与算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#adt"><span class="toc-number">2.1.</span> <span class="toc-text">ADT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text">合并操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.</span> <span class="toc-text">合并并排序操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%9A%84%E8%AF%84%E4%BB%B7"><span class="toc-number">2.2.5.</span> <span class="toc-text">顺序结构存储的评价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">建立单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">建立递增有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">2.3.4.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C-1"><span class="toc-number">2.3.5.</span> <span class="toc-text">合并操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AF%84%E4%BB%B7"><span class="toc-number">2.3.6.</span> <span class="toc-text">链式存储结构评价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">双向循环链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E9%93%BE%E8%A1%A8%E6%AF%94%E8%BE%83"><span class="toc-number">2.7.</span> <span class="toc-text">各链表比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#adt-1"><span class="toc-number">3.1.</span> <span class="toc-text">ADT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E8%BE%93%E5%87%BA%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">栈的输出特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">栈的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E6%A0%88"><span class="toc-number">3.5.</span> <span class="toc-text">链式栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.1.</span> <span class="toc-text">数制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-number">3.6.2.</span> <span class="toc-text">括号匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">3.6.3.</span> <span class="toc-text">表达式求值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#adt-2"><span class="toc-number">4.1.</span> <span class="toc-text">ADT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">链式队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">循环队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">数组的递归定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.2.</span> <span class="toc-text">数组的顺序表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%98%A0%E5%83%8F%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">数组的映像函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">5.4.</span> <span class="toc-text">矩阵的压缩存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">5.5.</span> <span class="toc-text">稀疏矩阵的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E6%8E%A5%E8%A1%A8"><span class="toc-number">5.6.</span> <span class="toc-text">十字链接表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.1.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.</span> <span class="toc-text">二叉树的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.4.</span> <span class="toc-text">非递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.5.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">创建二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">递归法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">6.4.2.</span> <span class="toc-text">非递归法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.5.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.5.2.</span> <span class="toc-text">线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.5.3.</span> <span class="toc-text">遍历线索二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">7.</span> <span class="toc-text">树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">树的表示形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.3.</span> <span class="toc-text">森林、树和二叉树的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.4.</span> <span class="toc-text">树和森林的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">7.5.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">8.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">8.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">图的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.3.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">8.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prim"><span class="toc-number">8.4.1.</span> <span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">8.5.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aoe%E7%BD%91"><span class="toc-number">8.6.</span> <span class="toc-text">AOE网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">8.7.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">8.7.1.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="toc-number">8.7.2.</span> <span class="toc-text">Floyd算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">9.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">9.1.</span> <span class="toc-text">静态查找表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">9.1.1.</span> <span class="toc-text">顺序查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">折半查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="toc-number">9.1.3.</span> <span class="toc-text">判定树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">9.2.</span> <span class="toc-text">动态查找表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">9.2.1.</span> <span class="toc-text">二叉排序树（二叉查找树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">删除二叉排序树中的结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl%E6%A0%91"><span class="toc-number">9.2.2.</span> <span class="toc-text">平衡二叉树(\(AVL\)树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E4%B8%80%E5%AE%9A%E7%9A%84avl%E6%A0%91%E6%89%80%E5%90%AB%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">高度一定的AVL树所含最小节点个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">构造平衡二叉搜索树的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">9.2.3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">构造哈希函数的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">解决哈希冲突的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8C%96%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">9.2.3.3.</span> <span class="toc-text">哈希化的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6"><span class="toc-number">9.2.3.4.</span> <span class="toc-text">哈希表的平均查找长度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.1.</span> <span class="toc-text">插入排序（稳定排序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fcolorred-%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.2.</span> <span class="toc-text">希尔排序\(\color{red} {（不稳定排序）}\)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fcolorred%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.3.</span> <span class="toc-text">快速排序\(\color{red}{(不稳定排序)}\)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fcolorred%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">选择排序\(\color{red}{(不稳定排序)}\)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8Fcolorred%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.5.</span> <span class="toc-text">堆排序\(\color{red}{(不稳定排序)}\)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.6.</span> <span class="toc-text">归并排序（稳定排序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">10.7.</span> <span class="toc-text">基数排序（稳定排序）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/05/ASL/" title="ASL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051507560.jpg" onerror="this.onerror=null;this.src='/img/1.jpg'" alt="ASL"/></a><div class="content"><a class="title" href="/2024/06/05/ASL/" title="ASL">ASL</a><time datetime="2024-06-05T07:01:36.000Z" title="发表于 2024-06-05 15:01:36">2024-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/" title="美丽的花花"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051507368.jpg" onerror="this.onerror=null;this.src='/img/1.jpg'" alt="美丽的花花"/></a><div class="content"><a class="title" href="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/" title="美丽的花花">美丽的花花</a><time datetime="2024-06-04T08:22:50.000Z" title="发表于 2024-06-04 16:22:50">2024-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/" title="不一样的天空"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051508381.jpg" onerror="this.onerror=null;this.src='/img/1.jpg'" alt="不一样的天空"/></a><div class="content"><a class="title" href="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/" title="不一样的天空">不一样的天空</a><time datetime="2024-06-04T08:04:16.000Z" title="发表于 2024-06-04 16:04:16">2024-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/02/%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F/" title="基础公式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405241302025.jpg" onerror="this.onerror=null;this.src='/img/1.jpg'" alt="基础公式"/></a><div class="content"><a class="title" href="/2024/06/02/%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F/" title="基础公式">基础公式</a><time datetime="2024-06-02T01:29:21.000Z" title="发表于 2024-06-02 09:29:21">2024-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/" title="B-树和B+树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405241303919.jpg" onerror="this.onerror=null;this.src='/img/1.jpg'" alt="B-树和B+树"/></a><div class="content"><a class="title" href="/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/" title="B-树和B+树">B-树和B+树</a><time datetime="2024-05-28T07:49:18.000Z" title="发表于 2024-05-28 15:49:18">2024-05-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg')"><div id="footer-wrap"><div class="footer_custom_text"><span id="realtime_duration"></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/plugin/duration.min.js"></script><script src="/scripts/realtime.js"></script><script defer src="/live2d-widget-master/autoload.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>