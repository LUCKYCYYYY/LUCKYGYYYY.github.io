<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>title: 数据结构<br>date: 2024-05-07 10:59:24<br>tags: [数据结构]<br>categories: [算法,数据结构]<br>top_image: <a href="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg">https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg</a><br>cover: <a href="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg">https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/5.jpg</a></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><h2 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h2><h3 id="二叉排序树（二叉查找树）"><a href="#二叉排序树（二叉查找树）" class="headerlink" title="二叉排序树（二叉查找树）"></a><strong>二叉排序树（二叉查找树）</strong></h3><p>特点：如果二叉树的任一结点大于其非空左子树的所有结点，而小于其非空右子树的所有结点，则这棵二叉树称为二叉排序树。<strong>${\color{red}(左小右大)}$​</strong></p><h4 id="删除二叉排序树中的结点"><a href="#删除二叉排序树中的结点" class="headerlink" title="删除二叉排序树中的结点"></a><strong><em>删除二叉排序树中的结点</em></strong></h4><p>设被删除的结点为*p，其双亲结点为*f，*s为*p的前驱结点，*p是*f的左孩子，有三种情况：</p><ol><li><p>*p为叶子结点：直接删除</p></li><li><p>*p只有左孩子PL或者右孩子PR：让PL/PR为*f的左孩子</p></li><li><p>*p的左孩子PL和右孩子PR均不为空：</p><ol><li><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071134367.png" alt=""></li></ol></li></ol><ol><li><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071135262.png" alt=""></li></ol><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是待删除的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果左子树为空，或者为叶子结点</span></span><br><span class="line">    &#123; q = p; p = p-&gt;rchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//如果右子树为空</span></span><br><span class="line">    &#123; q = p; p = p-&gt;lchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果左右子树均不为空 以方法二为例</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;<span class="comment">//设置q的双亲结点是s</span></span><br><span class="line">            s = s-&gt;rchild;<span class="comment">//遍历直到找到p的前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;<span class="comment">//将p替换成s</span></span><br><span class="line">        <span class="comment">//要判断是因为如果删除结点的左子树有右子树那么中序遍历的前驱结点是右孩子，否则前驱结点是左孩子，就会导致移动的不同</span></span><br><span class="line">        <span class="keyword">if</span>(p != q)<span class="comment">//表明删除节点的左子树有右子树</span></span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;<span class="comment">//不需要free因为原来的s占的是q-&gt;left，现在已经被替换了</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树($AVL$树)"></a><strong>平衡二叉树</strong>($AVL$树)</h3><ol><li>结点的平衡因子：结点的左右子树深度之差（左子树高度-右子树高度）</li><li>平衡二叉树：任意结点平衡因子的绝对值小于等于1的二叉树</li></ol><h4 id="构造平衡二叉搜索树的方法"><a href="#构造平衡二叉搜索树的方法" class="headerlink" title="构造平衡二叉搜索树的方法"></a><strong><em>构造平衡二叉搜索树的方法</em></strong></h4><ul><li><p>左旋：向作左旋转，冲突的左孩变右孩</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081654715.png" alt=""></p></li><li><p>右旋：向右旋转，冲突的右孩变左孩</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081656759.png" alt=""></p></li><li><p>$LL$型，$RR$型，$LR$型，$RL$​型</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081714341.png" alt=""></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081716342.png" alt=""></p><ul><li>$LL$型：右旋</li></ul><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715912.png" alt=""></p><ul><li>$RR$​型：左旋</li></ul><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081849686.png" alt=""></p><ul><li>$LR$​型：先左旋左孩子，再右旋</li></ul><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715436.png" alt=""></p><ul><li>$RL$​型：先右旋右孩子，再左旋</li></ul><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715357.png" alt=""></p></li><li><p>插入结点时平衡失调，调整离删除结点最近的失衡结点即可</p><p>删除结点时平衡失调，依次对每个祖先进行检查和调整</p></li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h4 id="B树的定义："><a href="#B树的定义：" class="headerlink" title="B树的定义："></a><em>B树的定义</em>：</h4><p>一颗m阶B树是一颗平衡的m路搜索树</p><h4 id="B树的特性："><a href="#B树的特性：" class="headerlink" title="B树的特性："></a><strong><em>B树的特性</em></strong>：</h4><ol><li><p>每个结点至少两个子女</p></li><li><p>每个非根节点包含的关键字个数n：$\lceil m/2 \rceil - 1 \leq n \leq m-1$，</p><p>每个非根节点子树个数k：$\lceil m/2 \rceil \leq k \leq m$</p></li><li><p>根节点的关键字个数n：$1 \leq n \leq m-1$</p><p>根节点的子树个数k：$2 \leq n \leq m$</p></li><li><p>所有的非终端结点中包含下列信息数据$(n，A_0，K_1,A_1,K_2,A_2,…,K_n,A_n)$</p><ul><li>$K<em>i是关键字，K_i \textless K</em>{i+1}$</li><li>$A<em>i$为指向子树根节点的指针，且指针$A</em>{i-1}$所指子树中所有结点的关键字均小于$K_i$</li><li>$A_n$所指子树中所有结点的关键字均大于$K_n$</li></ul></li><li><p>叶子结点都在同一层</p></li><li><p>对于任一结点其子树高度相同</p></li><li><p>B树的m值比树高大很多，m的实用值一般在100-500</p></li></ol><h4 id="B树的查找："><a href="#B树的查找：" class="headerlink" title="B树的查找："></a><em>B树的查找：</em></h4><p>待查找元素$x_0$，如果：</p><ol><li>$K<em>i \textless x \textless K</em>{i+1}(1 \leq i\textless n)$，准备查找$A_i$页</li><li>$x \textless K_1$，准备查找$A_0$页</li><li>$x \textgreater K_n$，准备查找$A_n$页</li></ol><p>页内存储方式：顺序存储或者采用二叉排序树的形式</p><p>页内检索算法：顺序检索或者折半查找</p><h4 id="B树的高度（不包括叶子结点）："><a href="#B树的高度（不包括叶子结点）：" class="headerlink" title="B树的高度（不包括叶子结点）："></a><em>B树的高度（不包括叶子结点）：</em></h4><p>含n个关键字的m阶B树：</p><ul><li><p>最小高度：</p><p>让每个结点尽可能的满，每个结点有$m-1$个关键字，$m$个分叉，</p><p>则  $n \leq (m-1)(1+m+m^2+m^3+…+m^{h-1})=m^h-1$，</p><p>所以  $\color{red}h \geq log_m(n+1)$</p></li><li><p>最大高度：</p><p>让各层分支尽可能少，即根节点有两个分支，其他节点只有$\lceil m/2\rceil$个分支</p><p>各层节点至少有：</p><p>第一层 1、第二层 2、第三层 $2\lceil m/2\rceil$、第三层 $2\lceil m/2\rceil^2 $     $……$</p><p>第$h$层  $2\lceil m/2\rceil ^{h-2}$、第$h+1$层（即叶子节点/失败结点） $2\lceil m/2\rceil ^{h-1}$</p><p>n个关键字的B树一定有$n+1$个叶子结点，所以$n+1\geq 2\lceil m/2\rceil^{h-1}$，</p><p>即$\color{red}h \leq log_{\lceil m/2\rceil} \frac{n+1}{2}+1$</p></li></ul><h4 id="B树的插入："><a href="#B树的插入：" class="headerlink" title="B树的插入："></a><em>B树的插入</em>：</h4><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405090936688.mp4" width="100%" height="100%" controls="controls"></video><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>操作：将新的元素插入到已排序的数组中（稳定排序）</p><p>时间复杂度：$O(n^2)$​</p><ul><li><p>最好的情况：原n个记录递增有序</p><p>比较关键字次数：$n-1$次</p><p>移动记录次数：$2(n-1)$次（将数据复制到a[0]又复制回来）</p></li><li><p>最坏的情况：原n个记录递减有序</p><p>比较关键字次数：$\sum_\limits{i = 2}^n i = 2+3+…+n = \frac{(n-1)(n+2)}{2}$</p><p>移动记录次数：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序 </span></span><br><span class="line"><span class="comment">//对1-n进行排序(n表示的是数组的最后一个元素的下标，不是元素个数) </span></span><br><span class="line"><span class="comment">//在a[0]设置监视哨</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">cur = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[cur];</span><br><span class="line">cur--;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/05/07/%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/07/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础">算法基础</h1><h1 id="数据结构">数据结构</h1><h1 id="图论">图论</h1><h2 id="最短路问题">最短路问题</h2><h3 id="dijkstra算法">Dijkstra算法</h3><ul><li>朴素版本 ：时间复杂度 <spanclass="math inline">\(O(n^2)\)</span>，适合稠密图（利用邻接矩阵存储）<ol type="1"><li>将起点距离初始化为0，其他点的初始距离设置为无穷</li><li>每次找到距离起点距离最近的节点，将该点做标记，表示已经设置过</li><li>更新与该点有关的结点的距离</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//循环n-1次（除了开始的结点），每次都找到到某一个点的最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//寻找当前还未找的结点距离起点的最短路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">            <span class="comment">//找到一个距离起点更小的未被标记过的结点，就让t等于那个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//设置标记表示已经找到最小距离了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新与该结点有关结点的最小距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;<span class="comment">//n个结点m条边</span></span><br><span class="line">    <span class="built_in">memset</span>(g,  <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//初始化距离为无穷大</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);<span class="comment">//利用邻接矩阵进行存储，因为有重边所以取min</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用堆排序优化：时间复杂度<spanclass="math inline">\(O(mlogn)\)</span>，适合稀疏图（利用邻接表存储）<spanclass="math inline">\({\color{red}(除了找最小距离的时候利用堆优化，其他与朴素算法一致)}\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], w[N],idx;<span class="comment">//利用链式前向星存储</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//一个用来存距离，一个用来存结点</span></span><br><span class="line"><span class="comment">//只能将距离存在前面，因为要根据距离排序</span></span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><span class="comment">//存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = z;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII q = heap.<span class="built_in">top</span>();<span class="comment">//取堆顶元素</span></span><br><span class="line">        <span class="type">int</span> a = q.second, b = q.first;<span class="comment">//a是路径的尾节点，b是这条路径的长度</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();<span class="comment">//删除刚刚用过的堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(st[a]) <span class="keyword">continue</span>;</span><br><span class="line">        st[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[a]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[a] + w[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[a] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijsktra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论">数论</h1><h1 id="动态规划">动态规划</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/2024/05/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/2024/05/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合"><strong>集合</strong></h1><ul><li><p>常见集合：</p><p>N：正整数或自然数集合</p><p><span class="math inline">\(N_m\)</span>：<spanclass="math inline">\(1,2,...,m\)</span></p><p>Z：非负整数集合</p><p><span class="math inline">\(Z_m\)</span>：<spanclass="math inline">\(0,1,2,...,m-1\)</span></p><p>I：整数集合</p><p>P：素数集合</p><p>C：复数集合</p></li><li><p>寻常集：不包含自身作为元素</p><p>不寻常集：包含自身作为元素</p></li><li><p>基数：集合A中不同元素的个数，记作<spanclass="math inline">\(\#A\)</span></p></li><li><p>幂集：设有集合A，由A的所有子集组成的集合，称为集合A的幂集，记作<spanclass="math inline">\(2^A\)</span>，即<spanclass="math inline">\(2^A=\left\{S|S \subset A\right\}\)</span></p></li><li><p>设A是具有基数<span class="math inline">\(\#A\)</span>的有限集，则<spanclass="math inline">\(\#(2^A)=2^{\#A}\)</span></p></li><li><p>补集：集合A关于全集合U的相对补集称为A的绝对补集，记作<spanclass="math inline">\(A&#39;\)</span></p></li><li><p>A与B的对称差：集合A、B，由属于A但不属于B以及属于B但不属于A的所有元素构成的集合，记作<spanclass="math inline">\(A \oplus B\)</span>，即<spanclass="math inline">\(A \oplus B = (A-B)\cup (B-A)\)</span></p></li><li><p>集合的运算定律</p><ul><li>同一律： <span class="math inline">\(A\cup \varnothing =A\)</span>，<span class="math inline">\(A \cap U=A\)</span></li><li>互补律：<span class="math inline">\(A \cup A&#39; =U\)</span>，<span class="math inline">\(A \cap A&#39; =\varnothing\)</span></li><li>对合律：<span class="math inline">\((A&#39;)&#39; = A\)</span></li><li>等幂律：<span class="math inline">\(A \cup A = A,A \cap A =A\)</span></li><li>零一律：<span class="math inline">\(A \cup U = U, A \cap \varnothing= \varnothing\)</span></li><li>吸收率：<span class="math inline">\(A \cup (A \cap B) = A, A \cap (A\cup B) = A\)</span></li><li>德摩根律：<span class="math inline">\((A \cup B)&#39; = A&#39; \capB&#39;, (A \cap B)&#39; = A&#39; \cup B&#39;\)</span></li></ul></li><li><p>对称差运算</p><ul><li><span class="math inline">\(A \oplus B = B \oplus A\)</span></li><li><span class="math inline">\((A \oplus B)\oplus C = A \oplus (B\oplus C)\)</span></li><li><span class="math inline">\(A \cap (B \oplus C) = (A \cap B)\oplus(A \cap C)\)</span></li><li><span class="math inline">\(A \oplus \varnothing =A, A\oplus U =A&#39;\)</span></li><li><span class="math inline">\(A \oplus A=\varnothing, A\oplusA&#39;=U\)</span></li><li><span class="math inline">\(A\oplus(A\oplus B)=B\)</span></li></ul></li><li><p>分划：设<span class="math display">\[\pi= \left\{A_i\right\}_{i\inK}\]</span>是集合A的某些非空子集的集合，如果集合A的每个元素在且只在其中之一<spanclass="math inline">\(A_i\)</span>中，即如果</p><ol type="1"><li><p>当<span class="math inline">\(i \neq j\)</span>时，<spanclass="math inline">\(A_i \cap A_j = \varnothing\)</span></p></li><li><p><span class="math inline">\(\bigcup\limits_{i \in K}A_i =A\)</span></p><p>则称集合<spanclass="math inline">\(\pi\)</span>时集合A的一个分划</p></li></ol></li></ul><h1 id="关系"><strong>关系</strong></h1><h2 id="集合的笛卡尔积">集合的笛卡尔积</h2><ul><li><p>序偶：有序二元组</p></li><li><p>笛卡尔积：设<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>时、是任意集合，所有有序n元组<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>的集合，称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>的笛卡尔积，记作<spanclass="math inline">\(A_1 \times A_2 \times...\times A_n\)</span></p><p>即<span class="math inline">\(A_1 \times A_2 \times...\times A_n =\left\{(a_1,a_2,...,a_n)|a_i \in A_i\right\}\)</span></p></li><li><p><span class="math inline">\(A \times B \neq B \timesA\)</span></p><p><span class="math inline">\(A \times B = B \times A =\varnothing\)</span></p></li><li><p><span class="math inline">\(A \times (B \cup C) = (A \times B)\cup (A \times C)\)</span></p><p><strong>证明与笛卡尔积有关的定理利用序偶</strong></p></li></ul><h2 id="关系-1">关系</h2><ul><li><p>笛卡尔积<span class="math inline">\(A_1 \times A_2\times...\times A_n\)</span>的任何一个子集称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>上的n元关系</p></li><li><p>设<spanclass="math inline">\(\rho\)</span>是A到B的一个关系，定义域<spanclass="math inline">\(D_{\rho}\)</span>，值域<spanclass="math inline">\(R_{\rho}\)</span></p></li><li><p>逆关系<span class="math inline">\(\widetilde{\rho} =\left\{(b,a)|(a,b)\in \rho \right\}\)</span></p></li><li><p>若<spanclass="math inline">\(\rho\)</span>是由A到B的一个关系，且<spanclass="math inline">\((a,b)\in \rho\)</span>，则称a对b有关系<spanclass="math inline">\(\rho\)</span>，记作<spanclass="math inline">\(a\rho b\)</span>，</p><p>如果<span class="math inline">\((a,b)\notin\rho\)</span>，则记作<spanclass="math inline">\(a\rho&#39;b\)</span></p></li><li><p>集合A上的关系：由集合A到A自身的关系</p></li><li><p>普遍关系<span class="math inline">\(U_A\)</span>：若<spanclass="math inline">\(\rho = A^2\)</span>，则称<spanclass="math inline">\(\rho\)</span>为A上的普遍关系，即<spanclass="math inline">\(U_A = \left\{(a_i,a_j)|a_i,a_j \inA\right\}\)</span></p><p>恒等关系<span class="math inline">\(I_A\)</span>：<spanclass="math inline">\(I_A=\left\{(a_i,a_i)|a_i \inA\right\}\)</span></p></li><li><p>复合关系：<span class="math inline">\(\rho_1 \cdot \rho_2 =\left\{(a,c)|a\in A，c\in C,且\exists b\in B,s.t.(a\rho_1b,b\rho_2c)\right\}\)</span></p></li><li><p><span class="math inline">\((\rho_1 \cdot \rho_2)\cdot \rho_3 =\rho_1 \cdot (\rho_2 \cdot \rho_3)\)</span></p><p><strong>证明与关系有关的定理利用序偶</strong></p></li></ul><h2 id="关系的表示方法">关系的表示方法</h2><ul><li>关系矩阵<ul><li>设<span class="math inline">\(\rho_1\)</span>是A到B的关系，<spanclass="math inline">\(\rho_2\)</span>是B到C的关系，它们的关系矩阵分别为<spanclass="math inline">\(M_{\rho_1}、M_{\rho_2}\)</span>，则复合关系<spanclass="math inline">\(\rho_1 \cdot \rho_2\)</span>的关系矩阵<spanclass="math inline">\(M_{\rho_1 \rho_2}=M_{\rho_1} \cdotM_{\rho_2}\)</span></li><li><span class="math inline">\(M_{\rho ^n}=M_{\rho}^n\)</span></li></ul></li><li>关系图</li></ul><h2 id="集合a上关系的性质和闭包运算">集合A上关系的性质和闭包运算</h2><ul><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是自反的，否则是非自反的</p><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho&#39;a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反自反的</p></li><li><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rhob\)</span>就有<span class="math inline">\(b\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是对称的，否则是非对称的</p><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>，就必有<spanclass="math inline">\(a=b\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反对称的，也可描述为对于所有的<spanclass="math inline">\(a,b \in A\)</span>，若<spanclass="math inline">\(a \neq b\)</span>，则<spanclass="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>不能同时出现</p></li><li><p>对于所有的<span class="math inline">\(a,b,c \inA\)</span>，若每当有<span class="math inline">\(a\rho b和b\rhoc\)</span>就有<span class="math inline">\(a\rho c\)</span>，则称<spanclass="math inline">\(\rho\)</span>是可传递的，否则，<spanclass="math inline">\(\rho\)</span>是不可传递的</p></li></ul></li><li><p>A上关系的性质在关系矩阵上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>是自反的：主对角线上的元素全为1</li><li><spanclass="math inline">\(\rho\)</span>是对称的：关于主对角线对称</li><li><span class="math inline">\(\rho\)</span>是反对称的：对于<spanclass="math inline">\(i\neq j\)</span>，若<spanclass="math inline">\(r_{ij}=1\)</span>，则<spanclass="math inline">\(r_{ji}=0\)</span></li></ul></li><li><p>A上的关系的性质在关系图上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>​是自反的：每个结点引出一个单边环</li><li><spanclass="math inline">\(\rho\)</span>是反自反的：每个结点无单边环</li><li><span class="math inline">\(\rho\)</span>是对称的：对每一由结点<spanclass="math inline">\(a_i\)</span>指向结点<spanclass="math inline">\(a_j\)</span>的边，必有一相反的边</li><li><spanclass="math inline">\(\rho\)</span>是反对称的：任何两个不同的借点之间最多有一条边</li></ul></li><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><span class="math inline">\(\rho\)</span>的自反闭包<spanclass="math inline">\(r(\rho)\)</span>：<spanclass="math inline">\(r(\rho)=\rho \cup I_A\)</span></li><li><span class="math inline">\(\rho\)</span>的对称闭包<spanclass="math inline">\(s(\rho)\)</span>：<spanclass="math inline">\(s(\rho)=\rho \cup \widetilde{\rho}\)</span></li><li><span class="math inline">\(\rho\)</span>的传递闭包<spanclass="math inline">\(t(\rho)\)</span>：<spanclass="math inline">\(t(\rho)=\bigcup_\limits{i=1}^\infty\rho^i\)</span>​（若<span class="math inline">\(\# A=n\)</span>，则<spanclass="math inline">\(t(\rho)=\bigcup _\limits{i=1}^n\rho^i\)</span>）</li></ul><p><strong><spanclass="math inline">\({\color{red}r(\rho)、s(\rho)、t(\rho)分别是集合A上包含\rho最小的自反关系、对称关系、可传递关系}\)</span></strong></p></li><li><p>设<span class="math inline">\(\rho_1\)</span>、<spanclass="math inline">\(\rho_2\)</span>是集合A上的关系，且<spanclass="math inline">\(\rho_1 \subset \rho_2\)</span>，则<spanclass="math inline">\(r(\rho_1) \subset r(\rho_2)\)</span>，<spanclass="math inline">\(s(\rho_1) \subset s(\rho_2)\)</span>，<spanclass="math inline">\(t(\rho_1) \subset t(\rho_2)\)</span></p></li></ul><h2 id="集合a上两类重要的关系">集合A上两类重要的关系</h2><h3 id="等价关系">等价关系</h3><p>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它使自反、对称且可传递的，则称<spanclass="math inline">\(\rho\)</span>为A上的等价关系</p><h4 id="等价类">等价类：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则A中等价于a的全体元素的集合，成为a所生成的等价类，用<spanclass="math inline">\([a]_{\rho}\)</span>表示，即<spanclass="math inline">\([a]_{\rho}=\left\{b|b\in A,a\rho b\right\}\)</span></p><p>性质：</p><ol type="1"><li>A中每一个元素生成的等价类非空</li><li>彼此等价的元素属于同一个等价类</li><li>彼此不等价的元素属于不同的等价类，且这些等价类之间没有公共元素</li></ol><h4 id="分划">分划：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则等价类的集合<spanclass="math inline">\(\left\{[a]_{\rho} |a\inA\right\}\)</span>构成A的一个分划</p><p>说明：每一个等价类就是一个分化块，因为A的每一元素的等价类（在<spanclass="math inline">\(\rho\)</span>下）是唯一的，所以分划也是唯一的，这种由等价关系<spanclass="math inline">\(\rho\)</span>的等价类所组成的A的分划，称为A上由<spanclass="math inline">\(\rho\)</span>所导出的等价分化，用<spanclass="math inline">\(\pi_{\rho}^A\)</span>表示</p><h3 id="偏序">偏序</h3><p><strong>偏序</strong>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它是自反、反对称、可传递的，则称<spanclass="math inline">\(\rho\)</span>是A上的一个偏序关系，用<spanclass="math inline">\(\leq\)</span>表示；显然一个偏序的逆也是偏序，用<spanclass="math inline">\(\geq\)</span>表示。</p><p><strong>全序</strong>定义：一个集合A上的偏序，若对于所有的<spanclass="math inline">\(a,b\in A\)</span>，有<spanclass="math inline">\(a\leq b\)</span>或<span class="math inline">\(b\leq a\)</span>，则称它为A上的一个全序。</p><p><strong>良序</strong>定义：</p><h1 id="函数"><strong>函数</strong></h1><h1 id="图论"><strong>图论</strong></h1><h2 id="基本概念">基本概念</h2><h3 id="概念">概念</h3><ul><li><p>n阶图：有n个结点的图</p></li><li><p>(n, m)图：n个结点m条边</p><p>(n, 0)图：零图</p><p>(1, 0)图：平凡图</p></li><li><p>完全图：任意两个不同结点都相邻接的图叫完全图</p><p>补图：由G所有节点和为了使G变成完全图添加的边构成的图</p></li><li><p>d次正则图：所有节点都具有同一度d</p></li><li><p>子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p><p>真子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span> , 且 <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\neq\)</span> <spanclass="math inline">\(E\)</span></p><p>生成子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(=\)</span> <span class="math inline">\(V\)</span>, <span class="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p></li><li><p>图的同构：两个图存在边与边之间的双射关系</p></li><li><p>伪图：设 <span class="math inline">\(G = (V, E)\)</span> ,V是一个有限非空集合，E是V中任意元素的非有序对偶的多重集</p><ul><li>在E中允许出现相同元素的对偶</li><li>在E中无序对偶{<span class="math inline">\({Vi,Vj}\)</span>}可能出现r次</li></ul></li><li><p>多重图： 没有长度为1的环的伪图</p><p>简单图：没有自环且没有重数大于1的边</p></li><li><p>邻接（结点与结点，边与边）、关联（结点与边）、孤立点、孤立边</p></li></ul><h3 id="性质定理">性质定理</h3><ul><li>握手定理----在(n, m)图中，<spanclass="math inline">\(\sum\limits_{i=1}^{n}\)</span>deg(<spanclass="math inline">\(vi\)</span>)<spanclass="math inline">\(=2m\)</span>​;</li><li>n阶完全图<span class="math inline">\(Kn\)</span>中，<spanclass="math inline">\(m=\)</span><spanclass="math inline">\(\frac{1}{2}\)</span>n(n-1);</li><li>两个图同构的必要条件：<ol type="1"><li>它们有相同的结点数和相同的边数</li><li>对应结点的度数相同</li></ol></li></ul><h2 id="路">路</h2><h3 id="概念-1">概念</h3><ul><li>开路、真路、回路、环<ul><li>没有重复结点的开路是真路</li><li>没有重复结点的回路是环</li></ul></li><li>短程、距离</li></ul><h3 id="性质定理-1">性质定理</h3><ul><li>设G是具有结点集<spanclass="math inline">\(V={v_1,v_2,...,v_n}\)</span>的图，则对于任意两个相连接的结点<spanclass="math inline">\(v_i,v_j \in V (v_i \neqv_j)\)</span>，其短程是一条长度不大于n-1的真路</li></ul><h2 id="图的矩阵表示">图的矩阵表示</h2><p>设<span class="math inline">\(G = (V, E)\)</span>，其中 <spanclass="math inline">\(V = \left\{ v_1, v_2, ...,v_n\right\}\)</span></p><ul><li><p>邻接矩阵<span class="math inline">\(A = (a_{ij})\)</span></p><p><span class="math display">\[ a_{ij} =\left\{ \begin{aligned} 1&amp;&amp;{若\left\{ v_i, v_j \right\}} \in E \\ 0&amp; &amp;否则\end{aligned} \right. \]</span>​</p><ul><li>一个图的邻接矩阵是对角线元素均为0的0-1矩阵，反之，一个对角线全为0的0-1矩阵一定可以唯一地做一个图</li><li>如果两个图的邻接矩阵可以通过行列变换得到，那么这两个图同构</li><li>图G的邻接矩阵A的第i行（或第i列）出现1的个数就是节点<spanclass="math inline">\(v_i\)</span>​的度</li><li><span class="math inline">\(A^l (l = 1, 2, 3, ...)\)</span>的<spanclass="math inline">\((i, j)\)</span>项元素<spanclass="math inline">\(a_{ij}^{(l)}\)</span>是连接<spanclass="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>长度为l的路的总数</li></ul></li><li><p>关联矩阵<span class="math inline">\(I =(b_{ij})\)</span>是一个n<spanclass="math inline">\(\times\)</span>m矩阵</p><p><span class="math display">\[b_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若v_i和e_j是关联的 \\ 0&amp; &amp;否则  \end{aligned}\right.\]</span></p><ul><li>I中每一列都正好包含两个 1，并且任何两个列都是不相同的</li><li>第i行中的1的个数即为节点<spanclass="math inline">\(v_i\)</span>的度</li></ul></li><li><p>连接矩阵<span class="math inline">\(C = (c_{ij})\)</span></p><p><span class="math display">\[c_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若从v_i到v_j存在一条路 \\ 0&amp; &amp;否则 \end{aligned}\right.\]</span>​</p><ul><li>当C中所有元素都为1时图是连通 的</li></ul></li></ul><h2 id="图的连通性">图的连通性</h2><h3 id="概念-2">概念</h3><ul><li><p>连通图：如果存在一条路连接<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>，则称结点<spanclass="math inline">\(v_i\)</span>与<spanclass="math inline">\(v_j\)</span>是连接的，若G中任意两个节点均是连接的，则称图G是连通的</p></li><li><p>割边：如果在图G中删去边<span class="math inline">\(\left\{v_i,v_j\right\}\)</span>后，图G的分图数增加，则称边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>是G的割边</p></li><li><p>割点：如果在图G中删去结点<spanclass="math inline">\(v_i\)</span>及与其相关联的边之后，图G的分图数增加，则称结点<spanclass="math inline">\(v_i\)</span>是G的割点</p></li><li><p>边割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有E的子集S，使得在图G中删去S中的所有边后，得到的子图G-S变成具有两个分图的不连通图，而删去了S的任一真子集后，得到的子图仍然是连通图，则称S是G的一个边割集</p></li><li><p>点割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有V的子集<spanclass="math inline">\(V_1\)</span>使得在图G中删除了<spanclass="math inline">\(V_1\)</span>中的所有结点之后，所得到的子图<spanclass="math inline">\(G - V_1\)</span>不连通或为平凡图，则称<spanclass="math inline">\(V_1\)</span>是G的一个点割集</p><p><strong>（割点是点割集的特例）</strong></p></li><li><p>断集：设<span class="math inline">\(G = (V,E)\)</span>是一连通图，<span class="math inline">\(V_1 \subsetV\)</span>, G中端点分别属于<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>的所有边的集合，则成为G的断集</p><p><strong>边割集是断集的特例</strong></p></li><li><p>关联集：设v是图<span class="math inline">\(G =(V,E)\)</span>的一个结点，与v相关联的所有边的集合，称为结点v的关联集，记作<spanclass="math inline">\(S(v)\)</span></p></li><li><p>点连通度：<span class="math inline">\(K(G) = min\left\{\\#V_i|V_i是G的点割集\right\}\)</span>，点连通度是为了使G成为一个非连通图需要删除的点的最少数目</p></li><li><p>边连通度：λ<span class="math inline">\((G) = min\left\{ \#S|S是G的断集\right\}\)</span>，边连通度是为了使G成为一个非连通图需要删去的边的最少数目</p></li></ul><h3 id="性质定理-2">性质定理</h3><ul><li>图G中，边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>为割边的充要条件是边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>不在G的任何环中出现</li><li>在图G中，结点v为割点的充要条件是存在两个结点u和w，使得连接u和w的所有路中都出现结点v</li><li>对于一个给定的图<span class="math inline">\(G = (V, E)\)</span>，如果能把结点集V分成两个互补的子集<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(V&#39;\)</span>，使得同一结点集中的任意两个结点之间，至少存在一条不包含另一个结点子集中的任何结点的路，那么G中的端点分别在<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>​中的边组成G的一个边割集</li><li>对于任意的图<span class="math inline">\(G = (V, E)\)</span>，有<spanclass="math inline">\(K(G) \leq \lambda(G)\leq  \delta(G)\)</span>（其中<spanclass="math inline">\(\delta(G)\)</span>是图G的最小度</li></ul><h2 id="欧拉图">欧拉图</h2><h3 id="概念-3">概念</h3><ul><li>欧拉回路：在图G中找到一个回路，它通过G的每条边一次且仅一次</li><li>欧拉路：具有欧拉回路的图</li><li>欧拉图：通过图G每条边一次且仅一次的开路</li></ul><h3 id="性质定理-3">性质定理</h3><ul><li>一个连通图G为欧拉图的充要条件是G的每一结点的度均为偶数</li><li>连通图G具有一条连接结点<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>的欧拉路的充要条件是，<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>​是G中仅有的具有奇数度的结点</li><li>欧拉回路的边不可以重复但是结点可以重复，所以欧拉回路不一定是环路</li></ul><h2 id="哈密顿图">哈密顿图</h2><h3 id="概念-4">概念</h3><ul><li><p>哈密顿环：找到一个环它通过图G的每个结点一次且仅一次</p><p>哈密顿路：通过图G每个结点一次且仅一次的开路</p><p>哈密顿图：具有哈密顿环的图</p></li><li><p>闭图：设G是具有n个结点的图，若对于<spanclass="math inline">\(deg(u)+deg(v) \geqn\)</span>​的每一对结点u和v，均有u和v相邻接，则称图G是闭图</p></li><li><p>闭包：图G的闭包是一个与G有相同结点集的闭图，记作<spanclass="math inline">\(G_c\)</span>，使<span class="math inline">\(G\subset G_c\)</span>，且异于<spanclass="math inline">\(G_c\)</span>的任何图H，若<spanclass="math inline">\(G \subset H \subset G_c\)</span>，则G不是闭图</p><p><strong>图G的闭包是包含图G的最小闭图</strong></p></li></ul><h3 id="性质定理-4">性质定理</h3><ul><li>图G的闭包是唯一的</li><li>每个哈密顿图都一定是连通的</li><li>若图<span class="math inline">\(G =(V,E)\)</span>是哈密顿图，则对于V的任何一个非空子集S，有<spanclass="math inline">\(W(G-S)\leq\#S\)</span>，这里<spanclass="math inline">\(W(G-S)\)</span>表示G - S中分图的个数</li><li>设G是具有n个结点的图，若有结点u和v不相邻接，且<spanclass="math inline">\(deg(u) + deg(v) \geq n\)</span>，则当且仅当图<spanclass="math inline">\(G+\left\{u,v\right\}\)</span>是哈密顿图时，图G时哈密顿图</li><li>设有图G当且仅当<spanclass="math inline">\(G_c\)</span>​是哈密顿图时，图G是哈密顿图</li><li>若图G的闭包<span class="math inline">\(G_c = K_n\)</span>，且<spanclass="math inline">\(n \geq 3\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#G \geq3\)</span>，若V中任意两个不相邻的结点u和v，均有<spanclass="math inline">\(deg(u) + deg(v) \geqn\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#V \geq 3\)</span>，若对于任意的<spanclass="math inline">\(v \in V\)</span>，均有<spanclass="math inline">\(deg(v) \geq\frac{n}{2}\)</span>，则G是哈密顿图</li></ul><h2 id="树">树</h2><h3 id="概念-5">概念</h3><ul><li><p>树：不包含环的连通图</p><p>树林：不包含环的图</p><p>树叶：度为1的结点</p></li><li><p>生成树：若连通图G的生成子图T是一棵树，T是G的生成树</p><p>最小生成树：在所有生成树中有最小权值</p></li><li><p>若G是一<spanclass="math inline">\((n,m)\)</span>连通图，G的生成树<spanclass="math inline">\(T_G\)</span>是一<spanclass="math inline">\((n,n-1)\)</span>图</p><p>环秩：在得到<spanclass="math inline">\(T_G\)</span>之前需要删除的边的总数为<spanclass="math inline">\(m-(n-1)\)</span>，该数为环秩，环秩是为了“弄破”G的所有环而必须由G中删去的边的最小数目</p><p>弦：被删去的每一条边</p><p>枝：在生成树<span class="math inline">\(T_G\)</span>中的边</p></li></ul><h3 id="性质定理-5">性质定理</h3><ul><li><p>在<span class="math inline">\((n,m)\)</span>树中，<spanclass="math inline">\(m = n - 1\)</span></p></li><li><p>具有两个或更多个结点的树至少有两片树叶</p></li><li><p>两个节点之间由唯一的真路连接的图就是树</p><p><span class="math inline">\(m=n-1\)</span>的连通图是树</p><p><span class="math inline">\(m=n-1\)</span>​且无环的图是树</p></li></ul><h2 id="有向树">有向树</h2><h3 id="概念-6">概念</h3><ul><li><p>有向树：一个不包含环的有向图G，若它只有一个结点<spanclass="math inline">\(v_0\)</span>入度为0，而所有其它结点入度为1</p></li><li><p>根：节点<span class="math inline">\(v_0\)</span></p><p>树叶或终点：出度为0的结点</p><p>级：从<span class="math inline">\(v_0\)</span>到结点<spanclass="math inline">\(v_i\)</span>的距离</p></li><li><p>m元树：在一有向树中，若每一个结点的出度都小于或等于m</p><p>完全m元树：若每个结点的出度等于m或0</p></li><li><p>外部结点：树叶结点</p><p>内部结点：分支结点</p></li><li><p>外部路径长度：根到所有外部结点的距离和</p><p>内部路径长度：根到所有内部结点的距离和</p><p>树的路径长度：根到所有结点的距离和</p></li><li><p>有序树：规定了每一级上结点的次序，一般规定同一级结点的次序为从左到右</p></li><li><p>前缀码：在一个序列的集合中，如果没有一个序列是另一个序列的前缀，则称该序列的集合为前缀码</p></li><li><p>最优树：一颗带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树，如果在所有带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树中具有最小的权，则称为最优树</p></li></ul><h3 id="性质定理-6">性质定理</h3><ul><li>一颗二元树第i级的最大结点数是<spanclass="math inline">\(2^i\)</span>，高度为h的二元树的最大结点数为<spanclass="math inline">\(2^{h+1}-1\)</span>​</li><li>设T为一颗完全二元树（T不为孤立结点）有r个内部结点，内部路径长度为I，外部路径长度为E，则<spanclass="math inline">\(E=I+2r\)</span></li><li>设T为一颗二元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，<spanclass="math inline">\(n_2\)</span>个出度为2的结点，则<spanclass="math inline">\(n_2=n_0-1\)</span></li><li>设T是一颗完全二元树，有n个结点，<spanclass="math inline">\(n_0\)</span>个叶节点，则<spanclass="math inline">\(n=2n_0-1\)</span></li><li>设T是一颗完全m元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，t个分支结点，则<spanclass="math inline">\((m-1)t=n_0-1\)</span></li></ul><h2 id="二部图">二部图</h2><h3 id="概念-7">概念</h3><ul><li><p>二部图：若一个图G的结点集V能分成两个子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>使得<span class="math inline">\(V_1\cup V_2=V\)</span>,<span class="math inline">\(V_1 \cap V_2 =\varnothing\)</span>，使得G的每一条边<spanclass="math inline">\(\left\{V_i,V_j\right\}\)</span>的端点<spanclass="math inline">\(v_i \in V1, v_j \inV_2\)</span>，则称图G是一个二部图</p><p>完全二部图：如果<spanclass="math inline">\(V_1\)</span>的每一个结点和<spanclass="math inline">\(V_2\)</span>的每一个结点想邻接，则G为完全二部图</p></li><li><p>匹配：设G是具有互补结点子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>的二部图，其中<spanclass="math inline">\(V_1=\left\{v_1,v_2,...,v_q\right\}\)</span>，<spanclass="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配是G的一个子图，它由q条边<spanclass="math inline">\(\left\{v_1,v_1&#39;\right\},\left\{v_2,v_2&#39;\right\},...,\left\{v_q,v_q&#39;\right\}\)</span>组成，其中<spanclass="math inline">\(v_1&#39;,v_2&#39;,...v_q&#39;\)</span>是<spanclass="math inline">\(V_2\)</span>中q个不同的元素</p></li></ul><h3 id="性质定理-7">性质定理</h3><ul><li>图G为二部图的充要条件是它的所有回路均为偶数长</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>必要条件</strong>是<spanclass="math inline">\(\# V_2 \geq \#V_1\)</span></li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充要条件</strong>是<spanclass="math inline">\(V_1\)</span>中没k个结点至少和<spanclass="math inline">\(V_2\)</span>​中k个结点相邻接</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充分条件</strong>是，存在某一整数<spanclass="math inline">\(t&gt;0\)</span>使<ol type="1"><li>对<spanclass="math inline">\(V_1\)</span>中每个结点，至少有t条边与其相关联</li><li>对<spanclass="math inline">\(V_2\)</span>中每个结点，至多有t条边与其相关联</li></ol></li></ul><h2 id="平面图">平面图</h2><h3 id="概念-8">概念</h3><ul><li>平面图：能画于平面上而无任何交叉</li></ul><h3 id="性质定理-8">性质定理</h3><ul><li>平面图的欧拉公式：设G是一连通的平面图，则有<spanclass="math inline">\(n-m+k=2\)</span>这里的n、m、k分别是图G的结点数、边数、面数（包括无限面）</li><li>有两条或者更多条边的任何连通的平面图G中,有<spanclass="math inline">\(m \leq 3n-6\)</span></li><li><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051141374.png"alt="image-20240505114109639" /><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051243937.png"alt="image-20240505124328184" /></li></ul><h2 id="有向图">有向图</h2><h3 id="概念-9">概念</h3><ul><li><p>弱连通：看作无向图时是连通的</p><p>单向连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>中至少有一个由另一个出发是可达的</p><p>强连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>都是相互可达的</p><p><strong>强连通的有向图是单向连通的，单向连通的有向图是弱连通的</strong></p></li><li><p>强分图、单向分图、弱分图分别是G的极大连通子图、极大单向连通子图、极大弱连通子图</p></li></ul><h3 id="性质定理-9">性质定理</h3><ul><li><p>一个连通的有向图具有欧拉回路的充要条件是，G的每一个结点的入度和出度相等</p><p>一个连通的有向图具有欧拉路的充要条件是，除了两个结点外，G的每一个结点的入度和出度相等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/28/hello-world/"/>
      <url>/2024/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
