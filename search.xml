<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>memset的使用</title>
      <link href="/2024/07/11/memset%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/07/11/memset%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="memset的赋值规则"><a href="#memset的赋值规则" class="headerlink" title="memset的赋值规则"></a>memset的赋值规则</h1><blockquote><p>memset赋值时，是按字节赋值，是将参数转换成二进制之后填入一个字节</p></blockquote><p><code>eg: memset(g, 100, sizeof g);</code></p><p>100转换成二进制是0110 0100，而int是4个字节，</p><p>所以一个int被赋值为0110 0100, 0110 0100, 0110 0100, 0110 0100，</p><p>对应十进制是1684300900</p><h1 id="memset的赋值-1，0，0x3f"><a href="#memset的赋值-1，0，0x3f" class="headerlink" title="memset的赋值-1，0，0x3f"></a>memset的赋值-1，0，0x3f</h1><ol><li>0赋值之后肯定还是0</li><li>-1因为它的补码是111……111，所以赋值之后还是-1</li><li>0x3f赋值之后是无穷大，即0x3f3f3f3f</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing图论题解</title>
      <link href="/2024/07/10/Acwing%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/10/Acwing%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排列数字">排列数字</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121424620.png" /></p><blockquote><p>利用深搜，设置一个数组用来存储走过的“路径”，还有一个标记数组用来看这个数有没有用过</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N], st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; n)     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[x] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">        st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n皇后">n皇后</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121424900.png" /></p><blockquote><p>设置三个参数，一个用来表示横行、一个竖行、一个表示当前已经有的皇后个数，一有冲突就让y++，当y走到头就让y重新回到0，然后让x向下移，设置四个bool数组，表示横行、纵行、正斜线、反斜线是否已经放了皇后</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> place[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n) y = <span class="number">0</span>, x++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; place[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x - y + n] &amp;&amp; ! udg[x + y])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x - y + n] = udg[x + y] = <span class="literal">true</span>;</span><br><span class="line">        place[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x - y + n] = udg[x + y] = <span class="literal">false</span>;</span><br><span class="line">        place[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x , y + <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//memset(place, &#x27;.&#x27;, sizeof place);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        place[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="走迷宫">走迷宫</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423575.png" /></p><blockquote><p>广度优先搜索，利用队列，先将第一层的数加入到队列中，然后在出队的时候把与第一层有关的第二层的数加入到队列中，“探索”它的上下左右，遍历到的地方不遍历第二遍，因为是层序遍历，第一次遍历到的一定是最小的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [a, b] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i], y = b + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; !g[x][y] &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               d[x][y] = d[a][b] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八数码">八数码</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423535.png" /></p><blockquote><p>将初始的状态和最后的状态转换成字符串，找到字符串中字符的位置和9宫格中字符位置的关系，对字符串进行操作</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ed = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; d;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">string  start;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[start] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        string t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dis = d[t];</span><br><span class="line">        <span class="keyword">if</span>(t == ed) <span class="keyword">return</span> dis;</span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//找到x在字符串中的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = k / <span class="number">3</span>, b = k % <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i], y =  b + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[x * <span class="number">3</span> + y]);</span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))<span class="comment">//如果这个样子的字符串没有出现过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[t] = dis + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[x * <span class="number">3</span> + y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        start += x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的重心">树的重心</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407111517293.png" /></p><blockquote><p>每个结点的每个分支都是一个连通块，剩下的上面那部分是另一个连通块；对于每个结点，找到它所区分的连通块中的最大值；对于所有结点，将他们对应的连通块最大值进行比较，找到其中的最小值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> h[N], to[M], ne[M], idx;<span class="comment">//链式前向星</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, ans = N;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//链式前向星</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//从u开始深搜</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;<span class="comment">//size用来记录连通块中的最大值，sum用来记录下面所有连通块所拥有的结点个数，用来计算上面剩下的结点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历，开始深搜</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = to[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j);<span class="comment">//这一条通路下面的所有结点数</span></span><br><span class="line">        size = <span class="built_in">max</span>(size, s);<span class="comment">//最大的连通块</span></span><br><span class="line">        sum += s;<span class="comment">//下面所有的结点个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="built_in">max</span>(size, n - sum - <span class="number">1</span>);<span class="comment">//将下面的最大连通块个数和上面那个剩余的连通块比较，看哪个大</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, size);<span class="comment">//最大连通块中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> sum + <span class="number">1</span>;<span class="comment">//返回下面连通块的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);<span class="comment">//构图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图中点的层次">图中点的层次</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121022089.png" /></p><blockquote><p>图的广度优先搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> to[N], h[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//构图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//广搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图的拓扑排序">图的拓扑排序</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059150.png" /></p><blockquote><p>每次将度为0的节点加入到“队列”中</p><p>用链式前向星存图，不要忘记初始化head数组！！！！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> to[N], ne[M], head[M], idx;</span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!d[i]) q[++tt] = i;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">TopSort</span>()) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dijkstra求最短路on2">Dijkstra求最短路<spanclass="math inline">\(O(n^2)\)</span></h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423082.png" /></p><blockquote><p>设置一个集合，st为true就是在集合里面，否则就是不在那个集合里面；每次求不在集合里面的点到1结点的最短距离，加入到集合中之后，更新与这个结点有关的距离，直到所有点都在集合中（贪心的策略）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//找到距离1距离最小的点，并且这个点不在集合中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//加入到集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="dijsktra求最短路堆优化版omlogm">Dijsktra求最短路（堆优化版）(O(mlogm))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423302.png" /></p><blockquote><p>用priority_queue进行优化，使得找到距离1最近点的时间复杂度变为O(1)，以类似于bfs的形式进行遍历，更新距离，加入到队列中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> to[N], h[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    w[idx] = z;</span><br><span class="line">    h[x] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> d = t.first, x = t.second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[x]) <span class="keyword">continue</span>;</span><br><span class="line">        st[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[x] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[x] + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="spfa处理存在负边权的情况omn">Spfa(处理存在负边权的情况)(O(mn))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059202.png" /></p><blockquote><p>因为边权可能为负值，只能用spfa算法，不能用dijkstra算法；spfa算法是以“层序”的方式进行不断更新节点距离，也就是说，会用某一层的所有结点去更新下一层次的节点，而不是像dijkstra一样使用贪心的策略，这样就可以保证即使前面的边权大、后面有负边权也可以更新到。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> to[N], ne[N], w[N], head[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    q. <span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spfa判断是否存在负环onomn">Spfa判断是否存在负环(O(n)~O(mn))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059864.png" /></p><blockquote><p>如果存在负环，那么一旦进入这个负环，就会一直循环，因为只要在负环里面dist就会一直减，所以可以计算每个节点距离最短的路上有几个结点，如果大于等于n必定存在负环，因为如果只存在正环或者不存在环，那么最长的应该是n-1；因为负环不一定是从结点1开始的，所以在起始的时候需要把所有结点加入到队列中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> to[M], ne[M], w[M], head[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="bellmanford处理有限制条件的情况omn">BellmanFord（处理有限制条件的情况）(O(mn))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059705.png" /></p><blockquote><p>利用一个循环，保证循环k次，每一次只往后“走”一步，并且每次更新需要用上一次更新的结果更新这一次的结果（不是用这一次更新这一次），所以需要每次先拷贝再更新</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], cpy[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cpy, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], cpy[e.a] + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        edges[i].a = x, edges[i].b = y, edges[i].w = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BellmanFord</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="floydon3">Floyd<spanclass="math inline">\((O(n^3))\)</span></h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407191043155.png" /></p><blockquote><ol type="1"><li>不能处理负边权</li><li><span class="math inline">\(d[i][j]\)</span>表示从i到j的距离</li><li>floyd中必须先遍历k，因为最后遍历k会导致更新i、j时的距离不是最优距离</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">20010</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> n, m, x, y, z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        d[x][y] = <span class="built_in">min</span>(d[x][y], z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(d[x][y] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing数据结构题解</title>
      <link href="/2024/07/02/AcWing%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/02/AcWing%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407022159322.png" alt=""></p><blockquote><p>利用数组模拟链表，相当于链式前向星。head表示头结点的下标，e[i]表示i节点的值，ne[i]表示i节点指向的下一个节点的下标，idx表示当前可用的最后一个下标；因为idx从0开始不是从1开始，所以题目输入的k在用的时候需要-1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//头结点的插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span><span class="comment">//任意节点的插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x;cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> k, val;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; val;</span><br><span class="line">            <span class="built_in">add_to_head</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; val;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k) head = ne[head];<span class="comment">//如果k==0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">delete_k</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407022202290.png" alt=""></p><blockquote><p>根据单链表的经验，双链表只需要添加指向前一个结点的数组即可；这里我们省略head和tail，让0是左端点，1是右端点，那么idx就从2开始；在初始的时候head指向tail，tail指向head，因为前后节点都知道，所以只需要写一个插入函数即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], le[N], re[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span><span class="comment">//初始化，头尾是没有值的，只是标记</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    le[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//尾节点的前一个节点是头结点</span></span><br><span class="line">    re[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//头结点的后一个节点是尾节点</span></span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span><span class="comment">//插入到k的后面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    le[idx] = k;</span><br><span class="line">    re[idx] = re[k];</span><br><span class="line">    le[re[k]] = idx;</span><br><span class="line">    re[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    re[le[k]] = re[k];</span><br><span class="line">    le[re[k]] = le[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(<span class="number">0</span>, x);<span class="comment">//头插，0是头，插到0的后面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(le[<span class="number">1</span>], x);<span class="comment">//1是尾，插入到尾的前面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">Delete</span>(k + <span class="number">1</span>);<span class="comment">//因为idx从2开始，所以要+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(le[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IR&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = re[<span class="number">0</span>]; i != <span class="number">1</span>; i = re[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407022342608.png" alt=""></p><blockquote><p>建两个栈，一个存数字，一个存运算符</p><p>需要注意：</p><ol><li>遇到一个字符是数字，需要判断后面是不是接着是数字，将字符串转换成数字</li><li>结束条件之一是没有剩余的运算符</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; sg;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp&#123; &#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125; &#125;;<span class="comment">//用来存储各运算符的优先级</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span><span class="comment">//进行运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">char</span> op = sg.<span class="built_in">top</span>();sg.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;<span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)  r = b + a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>) r = b - a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;*&#x27;</span>) r = b * a;</span><br><span class="line">    <span class="keyword">else</span> r = b / a;</span><br><span class="line">    num.<span class="built_in">push</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i])) <span class="comment">//如果是数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[j]))<span class="comment">//判断后面是否有跟着的数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)<span class="comment">//左括号直接入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            sg.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sg.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)<span class="comment">//右括号计算到左括号为止</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            sg.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还有没有用的运算符并且栈顶的优先级高，就计算</span></span><br><span class="line">            <span class="keyword">while</span>(sg.<span class="built_in">size</span>() &amp;&amp; mp[sg.<span class="built_in">top</span>()] &gt;= mp[s[i]])</span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            sg.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sg.<span class="built_in">size</span>()) <span class="built_in">eval</span>();<span class="comment">//计算剩下的表达式</span></span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031243104.png" alt=""></p><p><strong>解析</strong>：<img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031244235.png" style="zoom: 50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> st[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; st[tt] &gt;= x) tt--;<span class="comment">//如果栈不为空，并且栈顶元素比当前元素大，就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(!tt) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st[++tt] = x;<span class="comment">//当前元素入栈，先++，保证tt==0的时候栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031420669.png" alt=""></p><blockquote><p>首先根据题意我们知道可以用队列模拟滑动窗口，但是如果直接暴力的话，时间复杂度是O(nk)，显然会超时，这时候就可以用单调队列优化，即将不需要的数字删去，看最后队列中的数是否具有单调性，如果有，就可以用单调队列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N], a[N];<span class="comment">//q是队列，a是存储数据的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断需不需要让窗口往后移</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为是找最小值，所以如果新出现的元素比左边的元素小，那么在窗口右移的过程中，左边的那个更大的元素必定用不到，所以删去</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//将新元素加进队列</span></span><br><span class="line">        <span class="comment">//整个队列单调增，所以hh位置元素最小</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前队列中的元素个数大于k，需要队首出队</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为找最大值，所以如果新出现元素更大，同上，删去左边的元素</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//在队列里面存下标</span></span><br><span class="line">        <span class="comment">//整个队列单调减，hh位置元素最大</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041040433.png" alt=""></p><blockquote><ol><li>暴力，i指针遍历s字符串，j指针遍历p字符串；如果遍历不成功i就会回退，时间复杂度是O(mn)会超时</li><li>KMP优化，利用next数组，让i指针不回退，如果不成功就让j根据next数组跳转，next跳转的位置前面的字符串应该与当前匹配到的位置前面的字符串一致；时间复杂度O(m + n)</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[M], p[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//生成next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="comment">//前面有字符串并且当前字符串不匹配，就让j跳转到有相同前缀的子串后面，比如字符串abcabab，在倒数第二个a后面的b不匹配的时候跳转到第一个a</span></span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;<span class="comment">//如果相等就往后匹配，要找到最大的相同前后缀</span></span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//不匹配就让j跳转</span></span><br><span class="line">        <span class="keyword">if</span>(p[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i - n &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//因为题目要求的下标从0开始，但是程序写的时候是从1开始</span></span><br><span class="line">            j = ne[j];<span class="comment">//如果已经匹配完成，看要匹配的字符串里面有没有相同的前后缀，避免二次匹配，所以跳转到ne[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><blockquote><p>高效存储和查找字符串集合的数据结构</p></blockquote><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041456057.png" alt=""></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041339064.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">//son的第一维表示编号，一条一条递增，第二维表示字母；总体表示trie树</span></span><br><span class="line"><span class="comment">//cnt用来标记字符串的结尾，以及有几个字符串以这个字母结尾</span></span><br><span class="line"><span class="comment">//idx用来表示当前的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;<span class="comment">//相当于指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];<span class="comment">//让p到子节点的位置，寻找子节点的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;<span class="comment">//尾节点标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]) p = son[p][u];<span class="comment">//如果有这个字母，就接着往下遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//否则不存在这个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">Insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">Query</span>(s) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041423388.png" alt=""></p><blockquote><p>利用Trie树，从高位到低位存储每一个数的二进制形式；利用遍历，尽量找每一位都不一样的数，从而找到每一个数与其他数异或中的最大值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">31</span> * N;</span><br><span class="line"><span class="type">int</span> a[N], son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//建立Trie树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; ~i; i--)<span class="comment">//~i相当于i &gt;= 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;<span class="comment">//判断这一位是0/1</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<span class="comment">///建树</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; ~i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])<span class="comment">//看是否有和这一位01相反的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = <span class="number">2</span> * res + <span class="number">1</span>;<span class="comment">//如果有，在结果中这一位是1，所以+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = <span class="number">2</span> * res + <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">Insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">Query</span>(a[i]));<span class="comment">//遍历判断</span></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><blockquote><ol><li>将两个集合合并</li><li>询问两个元素是否在同一个集合中</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041519626.png" alt=""></p><blockquote><p>用p数组表示该集合中元素的父节点，当p[i] == i的时候，i是根节点</p><p>合并集合：让两个数的根节点合并</p><p>是否在同一个集合：判断根节点是否相等</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//找到根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归到根节点并且做路径压缩，让这条路上的所有结点直接指向根节点</span></span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> x; </span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> n, m;  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            <span class="built_in">Merge</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">Query</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407082202771.png" alt=""></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407082203529.png" alt=""></p><blockquote><ol><li>根据分析，如果将整个食物链连成一棵树，那么到根节点距离<ul><li>除3余0，就跟根节点为同类</li><li>除3余1，就被根节点吃</li><li>除3余2，就吃根节点</li></ul></li><li>返回值为bool的函数，一定要保证<strong>每条路径有返回值</strong></li><li>找到x， y的根节点，如果根节点不一样，则跟前面的话不可能冲突，所以一定是真话，将二者的关系加上即可；如果一样就通过到根节点的距离除3的余数判断</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> d[N], fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(fa[x]);<span class="comment">//找到fa[x]的根节点</span></span><br><span class="line">        <span class="comment">//设置一个新的变量t而不是直接更新x的父节点是根节点是因为后面更新d[x]需要用到x的fa[x]的距离值</span></span><br><span class="line">        d[x] += d[fa[x]];<span class="comment">//更新d[x]的距离，d[x]表示x到其父节点的距离</span></span><br><span class="line">        fa[x] = t;<span class="comment">//更新x的父节点为根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">D1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy &amp;&amp; (d[y] - d[x] + M) % M) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//因为d mod 3的余数相同表示是同一类，+M是怕d[y] - d[x] &lt; 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fx != fy)<span class="comment">//表示二者没有关系，一定不是假话，让x, y变成同类</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        <span class="comment">//(d[x] + ?) % 3 == d[y] % 3，其中?表示fx到fy的距离，即d[fx]</span></span><br><span class="line">        d[fx] = d[y] - d[x];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">D2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//x吃y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy &amp;&amp; (d[y] - d[x] - <span class="number">1</span> + M) % M)<span class="comment">//第0代吃第1代...，第二项等于0表示X吃Y</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fx != fy)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        d[fx] = (d[y] - <span class="number">1</span> - d[x] + M) % M;<span class="comment">//画个图，x吃y，可以知道x距离根节点比y距离根节点多1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> D, x, y;</span><br><span class="line">        cin &gt;&gt; D &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (D == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">D1</span>(x, y)) cnt++;</span><br><span class="line">        <span class="keyword">if</span> (D == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">D2</span>(x, y)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407090944850.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = p * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt;= n &amp;&amp; a[c] &gt; a[c + <span class="number">1</span>]) c++;</span><br><span class="line">        <span class="keyword">if</span> (a[c] &lt; a[p])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[c], a[p]);</span><br><span class="line">            p = c;</span><br><span class="line">            c = p * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)  <span class="built_in">down</span>(i, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        a[<span class="number">1</span>] = a[cnt--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407090944936.png" alt=""></p><blockquote><p>链地址法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">3</span>;<span class="comment">//大于1e5的质数</span></span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N], idx;<span class="comment">//链式前向星</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//将x映射到0~N</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x) <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">Query</span>(x) &lt;&lt; endl;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开放寻址法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span>(t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, null, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;    </span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[<span class="built_in">find</span>(x)] == null) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><p><img src="C:\Users\cy\AppData\Roaming\Typora\typora-user-images\image-20240709104900995.png" alt=""></p><blockquote><p>将字符串假设成为p进制的数，经过实验发现，当p=131或者p=1331的时候，可以当做没有冲突；然后就可以将字符串（p进制）转化成十进制数字，用p数组表示p的n次方，h数组存储前n个字符组成的字符串转换成的数字；可以利用前缀和的思想，发现h[s[l, r] ]= h[r] - h[l - 1] * p[r - l + 1];</p></blockquote><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407100814057.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//冲突问题：通过巧妙设置P (131 或 13331) , Q (2^64)的值，一般可以理解为不产生冲突。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"><span class="type">char</span> s[N]; </span><br><span class="line"><span class="function">ULL <span class="title">Query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>]* p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i];</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>, h[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//p[i]表示p的i次方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + s[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, l2, r1, r2;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Query</span>(l1, r1) == <span class="built_in">Query</span>(l2, r2)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;<span class="comment">//如果两个字符串的哈希值相等，那么就说明两个字符串相等</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing基础算法题解</title>
      <link href="/2024/07/01/AcWing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/01/AcWing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="位整数乘法">64位整数乘法</h1><p>求a乘b对p取模的值，<span class="math inline">\(1 \leq a, b, p\leq10^{18}\)</span></p><blockquote><p>因为a，b的范围到了<spanclass="math inline">\(10^{18}\)</span>，相当于64位的整数，二者相乘之后就变成了128位的整数，计算机没有这么大的类型存储。虽然不能乘，但是我们可以想象成是b个a相加，将b写成二进制形式，那么答案就是<spanclass="math inline">\(a\times(2^{k_1}+2^{k_2}+...2^{k_n})\)</span></p></blockquote><p>上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULL a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">    ULL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (res + a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * <span class="number">2</span> % p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="费解的开关">费解的开关</h1><p>25盏灯排成一个 5×5的方形，每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。我们用数字1表示一盏开着的灯，用数字0表示关着的灯。给定一些游戏的初始状态，编写程序判断游戏者是否可能在6 步以内使所有的灯都变亮。</p><blockquote><p>如果第一行的(i, j)位置是0，那么改变(i + 1, j)就可以让(i,j)变成1，但是如果就按题目给定的25盏灯进行上述操作，因为第一行是给定的，那么只会有一种结果，所以我们需要把第一行的所有情况都考虑到，第一行共有32种情况，我们不管第一行题目给的是什么样都直接把那32种情况都改变一遍，然后再判断1~3 行改变第 2~4 行，最后判断第四行是不是全是开即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">char</span> g[N][N], cp[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//矢量，方便表示某个位置的上下左右和自己</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//改变这个位置和其上下左右位置的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">        g[a][b] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++) cin &gt;&gt; g[i];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">10</span>;<span class="comment">//初始化答案，大于6即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> op = <span class="number">0</span>; op &lt; <span class="number">32</span>; op++)<span class="comment">//第一行的32种情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(cp, g, <span class="built_in">sizeof</span>(g));<span class="comment">//拷贝一份</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)<span class="comment">//对第一行进行操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(op &gt;&gt; i &amp; <span class="number">1</span>)<span class="comment">//这个数的二进制哪一位是1就改变哪个位置的状态（不管它现在是什么状态） </span></span><br><span class="line">                &#123;</span><br><span class="line">                    step++;</span><br><span class="line">                    <span class="built_in">turn</span>(<span class="number">0</span>, <span class="number">4</span>-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//对2~4行进行操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    <span class="comment">//如果(i, j)是0，就改变(i + 1, j)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">turn</span>(i + <span class="number">1</span>, j);</span><br><span class="line">                        step++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断最后一行是不是都是1</span></span><br><span class="line">            <span class="type">bool</span> dark = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[<span class="number">4</span>][i] == <span class="string">&#x27;0&#x27;</span>) dark = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dark) res = <span class="built_in">min</span>(res, step);</span><br><span class="line">            <span class="built_in">memcpy</span>(g, cp, <span class="built_in">sizeof</span>(cp));<span class="comment">//拷贝回来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &lt;= <span class="number">6</span>) cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象</title>
      <link href="/2024/06/29/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/06/29/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h1><ol><li>半缺省参数必须从右往左依次给出，不能间隔着给</li><li>缺省参数在函数声明的时候给出，不能声明定义同时给</li><li>缺省值必须是常量或者全局变量</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><ol><li>在使用引用时，权限可以平移和缩小，不能放大</li><li>引用定义时必须初始化</li><li>引用一旦引用一个实体就不能引用其他实体</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">2.234</span>;</span><br><span class="line">    <span class="comment">//类型转换，会生成一份临时拷贝，临时拷贝具有常性</span></span><br><span class="line">    <span class="type">int</span> i = d;</span><br><span class="line">    <span class="type">int</span>&amp; i = d;<span class="comment">//错误!!!!!</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;i = d; <span class="comment">//临时拷贝具有常性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表达式也会产生临时变量</span></span><br><span class="line">    <span class="type">int</span> x= <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;i = x + y;<span class="comment">//必须要加const</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><blockquote><p>用inline修饰的函数，inline只是一种建议，比较长的函数、递归函数等就算被定义为inline也会被编译器忽略</p></blockquote><p>在调用内联函数的地方进行展开，不需要建立函数栈帧，提升程序运行效率</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><ol><li>this指针被const修饰不能被修改，但是this指针指向的内容可以被修改</li><li>只能在“成员函数”的内部使用</li><li>this指针可以在类里面被引用，但是不能在函数形参里面定义，这个编译器会自动生成</li></ol><p><strong>练练手</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> _a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     A* p = <span class="literal">nullptr</span>;</span><br><span class="line">     p-&gt;<span class="built_in">Print</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>答案：C</p><p>在 p-&gt;Print() 这一步，可能会觉得是访问了空指针，但是实际上只是把 this 指针赋为空，但是 Print 函数是直接打印的，并没有对 this 指针进行访问，所以不会运行崩溃</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintA</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        cout&lt;&lt;_a&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;<span class="built_in">PrintA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>答案：B</p><p>因为打印的是_a，实际上就是this-&gt;_a，所以对this指针进行了访问，导致运行崩溃</p></blockquote><h1 id="默认成员函数"><a href="#默认成员函数" class="headerlink" title="默认成员函数"></a>默认成员函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>构造函数不是开空间创造对象，而是初始化</li><li>函数名和类名相同</li><li>无返回值，不需要写void</li><li>对象实例化的时候编译器自动调用构造函数</li><li>构造函数可以重载</li><li>编译器自动生成的构造函数，对于<strong>内置类型</strong>成员变量(int, char, double…)不做处理，对于<strong>自定义类型</strong>成员变量(class, struct,…)会调用它的无参构造</li><li>如果类中没有显示定义构造函数，编译器会自动生成一个无参的构造函数，一旦用户显示定义编译器将不再生成</li></ol><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ol><li>析构函数不是对对象本身的销毁，而是完成对象中资源清理工作</li><li>函数名是在类名前面加上~</li><li>在对象声明周期结束的时候自动调用 </li><li>析构函数不能重载</li></ol><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ol><li>参数只有一个且必须是类类型对象的引用，使用传值的方式会引发无穷递归，正确形式：Date (const Date&amp; d)</li><li>若未显示定义，则编译器会默认生成，但是只完成字节序的拷贝，即浅拷贝</li><li>如果类中没有涉及资源申请的时候，写不写拷贝构造都可以；但是如果涉及到资源申请，就必须写拷贝构造，否则会出现两个不同的对象指向同一块空间</li></ol><h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><ol><li>函数名是operate后面加需要重载的运算符</li><li>“.* “  “::”  “sizeof”  “?:”  “.”  这5个运算符不能重载  </li><li>赋值运算符重载格式：<ul><li>参数类型：const T&amp;</li><li>返回值类型：T&amp;，有返回值是为了连续赋值</li><li>检测是否是自己给自己赋值</li><li>返回*this，要符合连续赋值的定义</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; d)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)</span><br><span class="line">       &#123;</span><br><span class="line">            _year = d._year;</span><br><span class="line">            _month = d._month;</span><br><span class="line">            _day = d._day;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>赋值运算符重载只能重载成类的成员函数，不能重载成全局函数</li><li>同拷贝构造一样，默认的赋值运算符重载只完成浅拷贝</li></ol><h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><p>const修饰的“成员函数”成为const成员函数，实际上修饰的是this指针，表明在该成员函数中不能对类中的任何成员进行修改</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407011553818.png" alt=""></p><h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h1><blockquote><p>以一个冒号开始，接着是以一个逗号分隔的数据成员列表，每个“成员变量”后面跟一个放在括号中的初始值或者表达式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)     </span><br><span class="line">: _year(year)</span><br><span class="line">    , _month(month)</span><br><span class="line">    , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>每个成员变量在初始化列表中只能出现一次，初始化只能初始化一次</li><li>类中包含以下成员，必须放在初始化列表中初始化<ul><li>引用成员变量</li><li>const成员变量</li><li>自定义类型成员（且该类没有默认构造函数时）</li></ul></li><li>成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中初始化的顺序无关</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 类和对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转曲线的侧面积和体积</title>
      <link href="/2024/06/10/%E6%97%8B%E8%BD%AC%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BE%A7%E9%9D%A2%E7%A7%AF%E5%92%8C%E4%BD%93%E7%A7%AF/"/>
      <url>/2024/06/10/%E6%97%8B%E8%BD%AC%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BE%A7%E9%9D%A2%E7%A7%AF%E5%92%8C%E4%BD%93%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406100931602.jpg" /></p><h1 id="曲线与x轴所围的面积">曲线与x轴所围的面积</h1><p>抽出微元<spanclass="math inline">\(\Longrightarrow\)</span><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406100935009.jpg" style="zoom:33%;" />，其中<spanclass="math inline">\(f(x+dx)=f(x)+f&#39;(x)dx\)</span></p><p><span class="math inline">\(\RightarrowdS=\frac{1}{2}[f(x)+f(x+dx)]dx =\frac{1}{2}[2f(x)+f&#39;(x)dx]dx\)</span></p><p><span class="math inline">\(\Rightarrow dS \sim f(x)dx\)</span></p><h1id="曲线绕x轴一周所围图形的侧面积">曲线绕x轴一周所围图形的侧面积</h1><p>求出微元<span class="math inline">\(\Longrightarrow ds =\sqrt{1+f&#39;(x)}dx\)</span></p><p>圆台面积：$(r_1+r_2)l $</p><p><span class="math inline">\(\Rightarrow d_{S\text{侧}}=\pi[f(x)+f(x+dx)]ds=\pi[2f(x)+f&#39;(x)dx]\sqrt{1+f&#39;(x)^2}dx\)</span></p><p><span class="math inline">\(\Rightarrow d_{s\text{侧}}\sim 2\pif(x)\color{red}{ds}\)</span> <span class="math inline">\(\sim 2\pif(x)\sqrt{1+f&#39;(x)^2}dx\)</span></p><h1 id="曲线绕x轴一周所围图形的体积">曲线绕x轴一周所围图形的体积</h1><p>圆台体积公式：<span class="math inline">\(\frac{1}{3}\pih(r_1^2+r_1r_2+r_2^2)\)</span></p><p><span class="math inline">\(\Rightarrow dV_x=\frac{1}{3}\pidx[f^2(x)+f(x)[f(x)+f&#39;(x)dx]+[f(x)+f&#39;(x)]^2]\)</span></p><p><span class="math inline">\(\Rightarrow dV_x\sim \pif^2(x)\color{red}{dx}\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旋转曲线的侧面积和体积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k叉树</title>
      <link href="/2024/06/07/k%E5%8F%89%E6%A0%91/"/>
      <url>/2024/06/07/k%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>含n个结点的k叉树，最小深度为 <spanclass="math inline">\(\color{blue}{\lfloor log_2[(k-1)n]+1\rfloor} +1\)</span>，最大深度为<spanclass="math inline">\(\color{blue}{n}\)</span></p><blockquote><p>解析：最小深度即使让前面的所有层是满的，最后一层尽可能满</p><p><span class="math inline">\(\frac{k^{h - 1}-1}{k-1}&lt;n \leq\frac{k^h-1}{k-1}\)</span> <spanclass="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(h-1&lt;log_k[n(k-1)+1]\leq h\)</span></p><p>最大深度即使每一层都只有一个元素</p></blockquote><p>满k叉树，根的编号为1</p><ol type="1"><li>求p的第i个孩子的编号<spanclass="math inline">\(\color{blue}{k(p-1)+1+i}\)</span></li></ol><blockquote><p>解析：k(p-1)表示前p-1个结点所拥有的所有孩子的数量，即p的第1个孩子之前的所有孩子的数量（除了根节点不是任何节点的孩子），加一加的是根节点</p></blockquote><ol start="2" type="1"><li>p的父亲节点的编号<span class="math inline">\(\color{blue}{\lfloor\frac{p+(k-2)}{k}\rfloor}\)</span></li></ol><blockquote><p>解析：观察发现k叉树中每个节点的子节点的后面两个节点的编号除以k为父节点的编号，倒数第2个叉的编号是父节点的k倍</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASL</title>
      <link href="/2024/06/05/ASL/"/>
      <url>/2024/06/05/ASL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希表">哈希表</h1><h2 id="链地址">链地址</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051358262.png" /></p><p><strong>查找成功时的平均查找长度</strong></p><blockquote><p>ASL成功 = 表中每个元素查找成功时的比较的次数 /待查找的所有元素的个数</p></blockquote><p>ASL成功 = (1 * 5 + 2 * 2 + 3 * 1) / 8</p><p><strong>查找失败时的平均查找长度</strong></p><blockquote><p>ASL失败 = 每个链表上一直查找到空所需要的次数 / 表的长度</p></blockquote><p>ASL失败 = (4 + 1 + 1+ 3 + 1 + 1 + 2 + 2 + 1 + 2) / 10</p><h2 id="散列表">散列表</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051451626.png" /></p><p><strong>查找成功时的平均查找长度</strong></p><blockquote><p>ASL成功 = 从计算得到的位置往后查查到现在位置需要的次数 /待查找所有元素的个数</p></blockquote><p>ASL成功 = (1 + 2 + 1 + 1 + 1 + 3 + 3) / 7</p><p><strong>查找失败时的平均查找长度</strong></p><blockquote><p>ASL失败 = 表中从0~MOD-1中每个格子到下一个空格子需要的查找次数 /MOD的数（因为结果只有可能在0~MOD里面）</p></blockquote><p>ASL失败 = (3 + 2 + 1 + 2 + 1 + 5 + 4 ) / 7</p><h1 id="顺序查找">顺序查找</h1><p>查找方式为从头查到尾，找到待查找元素则为成功，找到尾部仍未找到则为失败，所以Ci（第i个元素的比较次数）取决于它在表中的位置</p><p>ASL成功 = <span class="math inline">\(\frac{1}{n}\cdot\frac{n(n+1)}{2}=\frac{n+1}{2}\)</span></p><p>ASL失败 = <span class="math inline">\(n\)</span></p><h1 id="折半查找">折半查找</h1><p>化为二叉排序树（判定树）</p><h1 id="二叉排序树">二叉排序树</h1><p>ASL成功 = <span class="math inline">\(\sum\limits_{i=1}^{n}P_i *level(k_i)\)</span>(Pi为查找k的概率，level(Ki)为k对应内部结点的层次)</p><p>ASL失败 = <span class="math inline">\(\sum\limits_{i=0}^{n}q_i*level(U_i)\)</span>(有n + 1个外部结点，用Ei(0 &lt;= i &lt;=n)表示，qi表示查找属于Ei中关键字的概率，level(Ui)表示Ei对应外部结点的层次)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051520395.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美丽的花花</title>
      <link href="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/"/>
      <url>/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>花花 &amp;&amp; 光秃秃树枝</p><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/1.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/2.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/3.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/4.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/5.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/6.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/7.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/8.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/9.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/10.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/11.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/12.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/13.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/14.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/15.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/16.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/17.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/18.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/19.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/20.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 风景 </category>
          
          <category> 花和光秃秃的树枝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美丽花花 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不一样的天空</title>
      <link href="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/"/>
      <url>/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="华科天空拍拍拍">华科天空拍拍拍</h1><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/1.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/2.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/3.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/4.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/5.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/6.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/7.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/8.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/9.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/10.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/11.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/12.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/13.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/14.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/15.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/16.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/17.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/18.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/19.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/20.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/21.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/22.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/23.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/24.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/25.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/26.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/27.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/28.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/29.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/30.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/31.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/32.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 风景 </category>
          
          <category> 天空 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天空拍拍拍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-树和B+树</title>
      <link href="/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/"/>
      <url>/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="b树">B树</h3><h4 id="b树的定义"><em>B树的定义</em>：</h4><p>一颗m阶B树是一颗平衡的m路搜索树</p><h4 id="b树的特性"><strong><em>B树的特性</em></strong>：</h4><ol type="1"><li><p>每个结点至少两个子女</p></li><li><p>每个非根节点包含的关键字个数n：<span class="math inline">\(\lceilm/2 \rceil - 1 \leq n \leq m-1\)</span>，</p><p>每个非根节点子树个数k：<span class="math inline">\(\lceil m/2 \rceil\leq k \leq m\)</span></p></li><li><p>根节点的关键字个数n：<span class="math inline">\(1 \leq n \leqm-1\)</span></p><p>根节点的子树个数k：<span class="math inline">\(2 \leq n \leqm\)</span></p></li><li><p>所有的非终端结点中包含下列信息数据<spanclass="math inline">\((n，A_0，K_1,A_1,K_2,A_2,…,K_n,A_n)\)</span></p><ul><li><span class="math inline">\(K_i是关键字，K_i &lt;K_{i+1}\)</span></li><li><spanclass="math inline">\(A_i\)</span>为指向子树根节点的指针，且指针<spanclass="math inline">\(A_{i-1}\)</span>所指子树中所有结点的关键字均小于<spanclass="math inline">\(K_i\)</span></li><li><spanclass="math inline">\(A_n\)</span>所指子树中所有结点的关键字均大于<spanclass="math inline">\(K_n\)</span></li></ul></li><li><p>叶子结点都在同一层</p></li><li><p>对于任一结点其子树高度相同</p></li><li><p>B树的m值比树高大很多，m的实用值一般在100-500</p></li></ol><h4 id="b树的查找"><em>B树的查找：</em></h4><p>待查找元素<span class="math inline">\(x_0\)</span>，如果：</p><ol type="1"><li><span class="math inline">\(K_i &lt; x &lt; K_{i+1}(1 \leq i&lt;n)\)</span>，准备查找<span class="math inline">\(A_i\)</span>页</li><li><span class="math inline">\(x &lt; K_1\)</span>，准备查找<spanclass="math inline">\(A_0\)</span>页</li><li><span class="math inline">\(x &gt; K_n\)</span>，准备查找<spanclass="math inline">\(A_n\)</span>页</li></ol><p>页内存储方式：顺序存储或者采用二叉排序树的形式</p><p>页内检索算法：顺序检索或者折半查找</p><h4id="b树的高度不包括叶子结点"><em>B树的高度（不包括叶子结点）：</em></h4><p>含n个关键字的m阶B树：</p><ul><li><p>最小高度：</p><p>让每个结点尽可能的满，每个结点有<spanclass="math inline">\(m-1\)</span>个关键字，<spanclass="math inline">\(m\)</span>个分叉，</p><p>则 <span class="math inline">\(n \leq(m-1)(1+m+m^2+m^3+...+m^{h-1})=m^h-1\)</span>，</p><p>所以 <span class="math inline">\(\color{red}h \geqlog_m(n+1)\)</span></p></li><li><p>最大高度：</p><p>让各层分支尽可能少，即根节点有两个分支，其他节点只有<spanclass="math inline">\(\lceil m/2\rceil\)</span>个分支</p><p>各层节点至少有：</p><p>第一层 1、第二层 2、第三层 <span class="math inline">\(2\lceilm/2\rceil\)</span>、第三层 $2m/2^2 $ <spanclass="math inline">\(......\)</span></p><p>第<span class="math inline">\(h\)</span>层 <spanclass="math inline">\(2\lceil m/2\rceil ^{h-2}\)</span>、第<spanclass="math inline">\(h+1\)</span>层（即叶子节点/失败结点） <spanclass="math inline">\(2\lceil m/2\rceil ^{h-1}\)</span></p><p>n个关键字的B树一定有<spanclass="math inline">\(n+1\)</span>个叶子结点，所以<spanclass="math inline">\(n+1\geq 2\lceil m/2\rceil^{h-1}\)</span>，</p><p>即<span class="math inline">\(\color{red}h \leq log_{\lceilm/2\rceil} \frac{n+1}{2}+1\)</span></p></li></ul><h4 id="b树的插入"><em>B树的插入：</em></h4><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405090936688.mp4" width="100%" height="100%" controls="controls"></video>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B-树和B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学上</title>
      <link href="/2024/05/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%8A/"/>
      <url>/2024/05/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合"><strong>集合</strong></h1><ul><li><p>常见集合：</p><p>N：正整数或自然数集合</p><p><span class="math inline">\(N_m\)</span>：<spanclass="math inline">\(1,2,...,m\)</span></p><p>Z：非负整数集合</p><p><span class="math inline">\(Z_m\)</span>：<spanclass="math inline">\(0,1,2,...,m-1\)</span></p><p>I：整数集合</p><p>P：素数集合</p><p>C：复数集合</p></li><li><p>寻常集：不包含自身作为元素</p><p>不寻常集：包含自身作为元素</p></li><li><p>基数：集合A中不同元素的个数，记作<spanclass="math inline">\(\#A\)</span></p></li><li><p>幂集：设有集合A，由A的所有子集组成的集合，称为集合A的幂集，记作<spanclass="math inline">\(2^A\)</span>，即<spanclass="math inline">\(2^A=\left\{S|S \subset A\right\}\)</span></p></li><li><p>设A是具有基数<span class="math inline">\(\#A\)</span>的有限集，则<spanclass="math inline">\(\#(2^A)=2^{\#A}\)</span></p></li><li><p>补集：集合A关于全集合U的相对补集称为A的绝对补集，记作<spanclass="math inline">\(A&#39;\)</span></p></li><li><p><span class="math inline">\(a\inA\)</span>表示a是集合A的一个元素，<span class="math inline">\(B \subsetA\)</span>​表示B是A的一个子集，它意味着B中的每一个元素也是集合A中的元素</p><ul><li>若<span class="math inline">\(A\in B,B\subset C\)</span>，则<spanclass="math inline">\(A\in C\)</span> <spanclass="math inline">\(\color{red}{（只有这一种组合是对的）}\)</span></li><li><span class="math inline">\(\color{red}{错错错:}\)</span><ul><li>若<span class="math inline">\(A\in B,B\subset C\)</span>，则<spanclass="math inline">\(A\subset C\)</span></li><li>若<span class="math inline">\(A\subset B,B\in C\)</span>，则<spanclass="math inline">\(A\in C\)</span></li><li>若<span class="math inline">\(A\subset B,B\in C\)</span>，则<spanclass="math inline">\(A\subset C\)</span></li></ul></li></ul></li><li><p>A与B的对称差：集合A、B，由属于A但不属于B以及属于B但不属于A的所有元素构成的集合，记作<spanclass="math inline">\(A \oplus B\)</span>，即<spanclass="math inline">\(A \oplus B = (A-B)\cup (B-A)\)</span></p></li><li><p>集合的运算定律</p><ul><li>同一律： <span class="math inline">\(A\cup \varnothing =A\)</span>，<span class="math inline">\(A \cap U=A\)</span></li><li>互补律：<span class="math inline">\(A \cup A&#39; =U\)</span>，<span class="math inline">\(A \cap A&#39; =\varnothing\)</span></li><li>对合律：<span class="math inline">\((A&#39;)&#39; = A\)</span></li><li>等幂律：<span class="math inline">\(A \cup A = A,A \cap A =A\)</span></li><li>零一律：<span class="math inline">\(A \cup U = U, A \cap \varnothing= \varnothing\)</span></li><li>吸收率：<span class="math inline">\(A \cup (A \cap B) = A, A \cap (A\cup B) = A\)</span></li><li>德摩根律：<span class="math inline">\((A \cup B)&#39; = A&#39; \capB&#39;, (A \cap B)&#39; = A&#39; \cup B&#39;\)</span></li></ul></li><li><p>对称差运算</p><ul><li><span class="math inline">\(A \oplus B = B \oplus A\)</span></li><li><span class="math inline">\((A \oplus B)\oplus C = A \oplus (B\oplus C)\)</span></li><li><span class="math inline">\(A \cap (B \oplus C) = (A \cap B)\oplus(A \cap C)\)</span></li><li><span class="math inline">\(A \oplus \varnothing =A, A\oplus U =A&#39;\)</span></li><li><span class="math inline">\(A \oplus A=\varnothing, A\oplusA&#39;=U\)</span></li><li><span class="math inline">\(A\oplus(A\oplus B)=B\)</span></li></ul></li><li><p>分划：设<span class="math inline">\(\pi= \left\{A_i\right\}_{i\inK}\)</span>是集合A的某些非空子集的集合，如果集合A的每个元素在且只在其中之一<spanclass="math inline">\(A_i\)</span>中，即如果</p><ol type="1"><li><p>当<span class="math inline">\(i \neq j\)</span>时，<spanclass="math inline">\(A_i \cap A_j = \varnothing\)</span></p></li><li><p><span class="math inline">\(\bigcup\limits_{i \in K}A_i =A\)</span></p><p>则称集合<spanclass="math inline">\(\pi\)</span>时集合A的一个分划</p></li></ol></li></ul><h1 id="关系"><strong>关系</strong></h1><h2 id="集合的笛卡尔积">集合的笛卡尔积</h2><ul><li><p>序偶：有序二元组</p></li><li><p>笛卡尔积：设<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>时、是任意集合，所有有序n元组<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>的集合，称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>的笛卡尔积，记作<spanclass="math inline">\(A_1 \times A_2 \times...\times A_n\)</span></p><p>即<span class="math inline">\(A_1 \times A_2 \times...\times A_n =\left\{(a_1,a_2,...,a_n)|a_i \in A_i\right\}\)</span></p></li><li><p><span class="math inline">\(A \times B \neq B \timesA\)</span></p><p><span class="math inline">\(A \times B = B \times A =\varnothing\)</span></p></li><li><p><span class="math inline">\(A \times (B \cup C) = (A \times B)\cup (A \times C)\)</span></p><p><strong>证明与笛卡尔积有关的定理利用序偶</strong></p></li></ul><h2 id="关系-1">关系</h2><ul><li><p>笛卡尔积<span class="math inline">\(A_1 \times A_2\times...\times A_n\)</span>的任何一个子集称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>上的n元关系</p></li><li><p>设<spanclass="math inline">\(\rho\)</span>是A到B的一个关系，定义域<spanclass="math inline">\(D_{\rho}\)</span>，值域<spanclass="math inline">\(R_{\rho}\)</span></p></li><li><p>逆关系<span class="math inline">\(\widetilde{\rho} =\left\{(b,a)|(a,b)\in \rho \right\}\)</span></p></li><li><p>若<spanclass="math inline">\(\rho\)</span>是由A到B的一个关系，且<spanclass="math inline">\((a,b)\in \rho\)</span>，则称a对b有关系<spanclass="math inline">\(\rho\)</span>，记作<spanclass="math inline">\(a\rho b\)</span>，</p><p>如果<span class="math inline">\((a,b)\notin\rho\)</span>，则记作<spanclass="math inline">\(a\rho&#39;b\)</span></p></li><li><p>集合A上的关系：由集合A到A自身的关系</p></li><li><p>普遍关系<span class="math inline">\(U_A\)</span>：若<spanclass="math inline">\(\rho = A^2\)</span>，则称<spanclass="math inline">\(\rho\)</span>为A上的普遍关系，即<spanclass="math inline">\(U_A = \left\{(a_i,a_j)|a_i,a_j \inA\right\}\)</span></p><p>恒等关系<span class="math inline">\(I_A\)</span>：<spanclass="math inline">\(I_A=\left\{(a_i,a_i)|a_i \inA\right\}\)</span></p></li><li><p>复合关系：<span class="math inline">\(\rho_1 \cdot \rho_2 =\left\{(a,c)|a\in A，c\in C,且\exists b\in B,s.t.(a\rho_1b,b\rho_2c)\right\}\)</span></p></li><li><p><span class="math inline">\((\rho_1 \cdot \rho_2)\cdot \rho_3 =\rho_1 \cdot (\rho_2 \cdot \rho_3)\)</span></p><p><strong>证明与关系有关的定理利用序偶</strong></p></li></ul><h2 id="关系的表示方法">关系的表示方法</h2><ul><li>关系矩阵<ul><li>设<span class="math inline">\(\rho_1\)</span>是A到B的关系，<spanclass="math inline">\(\rho_2\)</span>是B到C的关系，它们的关系矩阵分别为<spanclass="math inline">\(M_{\rho_1}、M_{\rho_2}\)</span>，则复合关系<spanclass="math inline">\(\rho_1 \cdot \rho_2\)</span>的关系矩阵<spanclass="math inline">\(M_{\rho_1 \rho_2}=M_{\rho_1} \cdotM_{\rho_2}\)</span></li><li><span class="math inline">\(M_{\rho ^n}=M_{\rho}^n\)</span></li></ul></li><li>关系图</li></ul><h2 id="集合a上关系的性质和闭包运算">集合A上关系的性质和闭包运算</h2><ul><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是自反的，否则是非自反的</p><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho&#39;a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反自反的</p></li><li><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rhob\)</span>就有<span class="math inline">\(b\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是对称的，否则是非对称的</p><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>，就必有<spanclass="math inline">\(a=b\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反对称的，也可描述为对于所有的<spanclass="math inline">\(a,b \in A\)</span>，若<spanclass="math inline">\(a \neq b\)</span>，则<spanclass="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>不能同时出现</p></li><li><p>对于所有的<span class="math inline">\(a,b,c \inA\)</span>，若每当有<span class="math inline">\(a\rho b和b\rhoc\)</span>就有<span class="math inline">\(a\rho c\)</span>，则称<spanclass="math inline">\(\rho\)</span>是可传递的，否则，<spanclass="math inline">\(\rho\)</span>是不可传递的</p></li></ul></li><li><p>A上关系的性质在关系矩阵上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>是自反的：主对角线上的元素全为1</li><li><spanclass="math inline">\(\rho\)</span>是对称的：关于主对角线对称</li><li><span class="math inline">\(\rho\)</span>是反对称的：对于<spanclass="math inline">\(i\neq j\)</span>，若<spanclass="math inline">\(r_{ij}=1\)</span>，则<spanclass="math inline">\(r_{ji}=0\)</span></li></ul></li><li><p>A上的关系的性质在关系图上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>​是自反的：每个结点引出一个单边环</li><li><spanclass="math inline">\(\rho\)</span>是反自反的：每个结点无单边环</li><li><span class="math inline">\(\rho\)</span>是对称的：对每一由结点<spanclass="math inline">\(a_i\)</span>指向结点<spanclass="math inline">\(a_j\)</span>的边，必有一相反的边</li><li><spanclass="math inline">\(\rho\)</span>是反对称的：任何两个不同的借点之间最多有一条边</li></ul></li><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><span class="math inline">\(\rho\)</span>的自反闭包<spanclass="math inline">\(r(\rho)\)</span>：<spanclass="math inline">\(r(\rho)=\rho \cup I_A\)</span></li><li><span class="math inline">\(\rho\)</span>的对称闭包<spanclass="math inline">\(s(\rho)\)</span>：<spanclass="math inline">\(s(\rho)=\rho \cup \widetilde{\rho}\)</span></li><li><span class="math inline">\(\rho\)</span>的传递闭包<spanclass="math inline">\(t(\rho)\)</span>：<spanclass="math inline">\(t(\rho)=\bigcup_\limits{i=1}^\infty\rho^i\)</span>​（若<span class="math inline">\(\# A=n\)</span>，则<spanclass="math inline">\(t(\rho)=\bigcup _\limits{i=1}^n\rho^i\)</span>）</li></ul><p><strong><spanclass="math inline">\({\color{red}r(\rho)、s(\rho)、t(\rho)分别是集合A上包含\rho最小的自反关系、对称关系、可传递关系}\)</span></strong></p><p>(可以利用关系图得到传递闭包，只要能到达就有一条线连接)</p></li><li><p>设<span class="math inline">\(\rho_1\)</span>、<spanclass="math inline">\(\rho_2\)</span>是集合A上的关系，且<spanclass="math inline">\(\rho_1 \subset \rho_2\)</span>，则<spanclass="math inline">\(r(\rho_1) \subset r(\rho_2)\)</span>，<spanclass="math inline">\(s(\rho_1) \subset s(\rho_2)\)</span>，<spanclass="math inline">\(t(\rho_1) \subset t(\rho_2)\)</span></p></li></ul><h2 id="集合a上两类重要的关系">集合A上两类重要的关系</h2><h3 id="等价关系">等价关系</h3><p>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它使自反、对称且可传递的，则称<spanclass="math inline">\(\rho\)</span>为A上的等价关系</p><h4 id="等价类">等价类：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则A中等价于a的全体元素的集合，成为a所生成的等价类，用<spanclass="math inline">\([a]_{\rho}\)</span>表示，即<spanclass="math inline">\([a]_{\rho}=\left\{b|b\in A,a\rho b\right\}\)</span></p><p>性质：</p><ol type="1"><li>A中每一个元素生成的等价类非空</li><li>彼此等价的元素属于同一个等价类</li><li>彼此不等价的元素属于不同的等价类，且这些等价类之间没有公共元素</li></ol><h4 id="分划">分划：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则等价类的集合<spanclass="math inline">\(\left\{[a]_{\rho} |a\inA\right\}\)</span>构成A的一个分划</p><p>说明：每一个等价类就是一个分化块，因为A的每一元素的等价类（在<spanclass="math inline">\(\rho\)</span>下）是唯一的，所以分划也是唯一的，这种由等价关系<spanclass="math inline">\(\rho\)</span>的等价类所组成的A的分划，称为A上由<spanclass="math inline">\(\rho\)</span>所导出的等价分化，用<spanclass="math inline">\(\pi_{\rho}^A\)</span>​​表示</p><h4 id="商集">商集：</h4><p>等价类的集合<span class="math inline">\(\left\{[a]_{\rho}|a\inA\right\}\)</span>称为A关于<spanclass="math inline">\(\rho\)</span>的商集，记作<spanclass="math inline">\(A/\rho\)</span>，<spanclass="math inline">\(A/\rho\)</span>的基数称为<spanclass="math inline">\(\rho\)</span>的秩</p><p><spanclass="math inline">\(res_m(i)\)</span>表示用m除以i所得的余数</p><h4 id="细分">细分：</h4><p>如果<span class="math inline">\(I_2\)</span>的每一个分化块都是<spanclass="math inline">\(I_1\)</span>的某一个分化块的子集，则<spanclass="math inline">\(I_2\)</span>是<spanclass="math inline">\(I_1\)</span>的细分</p><h3 id="偏序">偏序</h3><p><strong>偏序</strong>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它是自反、反对称、可传递的，则称<spanclass="math inline">\(\rho\)</span>是A上的一个偏序关系，用<spanclass="math inline">\(\leq\)</span>表示；显然一个偏序的逆也是偏序，用<spanclass="math inline">\(\geq\)</span>表示。</p><p><strong>全序</strong>定义：一个集合A上的偏序，若对于所有的<spanclass="math inline">\(a,b\in A\)</span>，有<spanclass="math inline">\(a\leq b\)</span>或<span class="math inline">\(b\leq a\)</span>，则称它为A上的一个全序。<spanclass="math inline">\(\color{red}{集合A中任意两个元素都是可比的}\)</span></p><p><strong>良序</strong>定义：一个集合A上的偏序，若对于A的每一个非空子集<spanclass="math inline">\(S \subset A\)</span>，在S中存在一个元素<spanclass="math inline">\(a_s\)</span>（S中的最小的元素），使得对于所有<spanclass="math inline">\(s \in S\)</span>，有<spanclass="math inline">\(a_s \leq s\)</span>​，则称它为A上的一个良序。<spanclass="math inline">\(\color{red}{集合A中有最小元素}\)</span></p><p><strong>特点：</strong></p><ul><li>全序或者良序一定是偏序</li><li>偏序不一定是全序或者良序</li><li>一个偏序如果是良序则一定是全序</li></ul><h1 id="函数"><strong>函数</strong></h1><h2 id="函数-1">函数</h2><p><span class="math inline">\(A \timesB\)</span>的每一个子集都是由A到B的关系，其中一部分子集可以用来定义由A到B的函数，用<spanclass="math inline">\(B^A\)</span>表示这些函数的集合，即<spanclass="math inline">\(B^A=\left\{f|f:A\rightarrowB\right\}\)</span>，<spanclass="math inline">\(\color{red}{当A、B都是有限集}\)</span> <spanclass="math inline">\(\color{red}{的时候}\)</span>，<spanclass="math inline">\(\#A=m,\#B=n\)</span>，从A到B不同函数共有<spanclass="math inline">\(n^m\)</span>，即<spanclass="math inline">\(\#(B^A)=(\# B)^{\#A}\)</span></p><h2 id="三种特殊函数">三种特殊函数</h2><p>定义：</p><ul><li>内射：当<span class="math inline">\(a_i \neq a_j\)</span>时，有<spanclass="math inline">\(f(a_i) \neq f(a_j)\)</span>，也就是当<spanclass="math inline">\(f(a_i) = f(a_j)\)</span>时，有<spanclass="math inline">\(a_i=a_j\)</span>（集合A中的不同元素在B中有不同的像）</li><li>满射：B中每一个元素都是A中至少一个元素的像</li><li>双射：集合A和集合B的元素间一一对应</li></ul><p>特点：</p><p>​ 如果A、B都是有限集</p><ul><li><span class="math inline">\(\#A \leq\#B\)</span>时，f有可能时内射</li><li><span class="math inline">\(\#A\geq\#B\)</span>​时，f有可能是满射</li><li><span class="math inline">\(\#A=\#B\)</span>​时，f有可能是双射</li></ul><h2 id="函数的复合">函数的复合</h2><p>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow C\)</span>，那么：</p><ol type="1"><li>如果f和g都是内射，则<spanclass="math inline">\(gf\)</span>也是内射</li><li>如果f和g都是满射，则<spanclass="math inline">\(gf\)</span>也是满射</li><li>如果f和g都是双射，则<spanclass="math inline">\(gf\)</span>​​也是双射</li></ol><p>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow C\)</span>，那么：</p><ol type="1"><li>如果<span class="math inline">\(gf\)</span>是内射，则f是内射</li><li>如果<span class="math inline">\(gf\)</span>是满射，则g是满射</li><li>如果<spanclass="math inline">\(gf\)</span>是双射，则f是内射，g是满射</li></ol><h2 id="逆函数">逆函数</h2><ol type="1"><li>设函数<span class="math inline">\(f:A\rightarrowB\)</span>是一个双射，则逆函数<spanclass="math inline">\(f^{-1}\)</span>也是一个双射</li><li>设函数<span class="math inline">\(f:A\rightarrowB\)</span>是一个双射，则<spanclass="math inline">\((f^{-1})^{-1}=f\)</span></li><li>如果函数<span class="math inline">\(f:A\rightarrowB\)</span>是可逆的，则有<spanclass="math inline">\(f^{-1}f=I_A,ff^{-1}=I_B\)</span></li><li>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow A\)</span>，当且仅当<spanclass="math inline">\(gf=I_A,fd=I_B\)</span>时，有<spanclass="math inline">\(g=f^{-1}\)</span></li><li>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrowA\)</span>，且f和g都是可逆的，则<spanclass="math inline">\((gf)^{-1}=f^{-1}g^{-1}\)</span></li></ol><h2 id="集合的基数">集合的基数</h2><h3 id="概念">概念</h3><p>概念：集合的基数即集合中不同元素的个数</p><p><strong>等势</strong>：设有集合A、B，如果存在双射函数<spanclass="math inline">\(f:A\rightarrowB\)</span>，则说A和B有相同的基数，或者说A和B等势，记作<spanclass="math inline">\(A\sim B\)</span></p><p>注：对于有限集来说，A和B有相同的基数指的是它们元素个数相同</p><p><strong>有限集</strong>：如果集合A与集合<spanclass="math inline">\(N_m=\left\{1,2,...,m\right\}\)</span>属于同一基数类，则称集合A是有限集。有限集的基数就是该集合中的元素个数。</p><p><strong>可数集</strong>：如果集合<span class="math inline">\(A\simN\)</span>，则称A为可数集。可数集的基数记作<spanclass="math inline">\(\aleph_0\)</span>。一个集合是可数集的<strong>充分必要条件</strong>是它全部元素可以排成一个无穷序列的形式。</p><p><strong>可计数集：</strong>有限集和可数集称为可计数集。</p><h3 id="性质">性质</h3><ol type="1"><li><p>可数集的无限子集仍是可数集</p></li><li><p>任一无限集A必包含一可数子集</p></li><li><p>设集A可数，集B有限，且<span class="math inline">\(A\capB=\varnothing\)</span>，则<span class="math inline">\(A\cupB\)</span>可数</p></li><li><p>若A、B都是可数集，<span class="math inline">\(A\capB=\varnothing\)</span>，则<span class="math inline">\(A\cupB\)</span>​可数</p></li><li><p>有限个可数集的并是可数集</p></li><li><p>可数个(互不相交的)可数集的并依旧是可数集</p></li><li><p>设有集合A，B，若A的子集<spanclass="math inline">\(A_1\)</span>和B的子集<spanclass="math inline">\(B_1\)</span>，使得<spanclass="math inline">\(A\sim B_1,B\sim A_1\)</span>，则<spanclass="math inline">\(A\sim B\)</span></p></li></ol><h1 id="图论"><strong>图论</strong></h1><h2 id="基本概念">基本概念</h2><h3 id="概念-1">概念</h3><ul><li><p>n阶图：有n个结点的图</p></li><li><p>(n, m)图：n个结点m条边</p><p>(n, 0)图：零图</p><p>(1, 0)图：平凡图</p></li><li><p>完全图：任意两个不同结点都相邻接的图叫完全图</p><p>补图：由G所有节点和为了使G变成完全图添加的边构成的图</p></li><li><p>d次正则图：所有节点都具有同一度d</p></li><li><p>子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p><p>真子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span> , 且 <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\neq\)</span> <spanclass="math inline">\(E\)</span></p><p>生成子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(=\)</span> <span class="math inline">\(V\)</span>, <span class="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p></li><li><p>图的同构：两个图存在边与边之间的双射关系</p></li><li><p>伪图：设 <span class="math inline">\(G = (V, E)\)</span> ,V是一个有限非空集合，E是V中任意元素的非有序对偶的多重集</p><ul><li>在E中允许出现相同元素的对偶</li><li>在E中无序对偶{<span class="math inline">\({Vi,Vj}\)</span>}可能出现r次</li></ul></li><li><p>多重图： 没有长度为1的环的伪图</p><p>简单图：没有自环且没有重数大于1的边</p></li><li><p>邻接（结点与结点，边与边）、关联（结点与边）、孤立点、孤立边</p></li></ul><h3 id="性质定理">性质定理</h3><ul><li>握手定理----在(n, m)图中，<spanclass="math inline">\(\sum\limits_{i=1}^{n}\)</span>deg(<spanclass="math inline">\(vi\)</span>)<spanclass="math inline">\(=2m\)</span>​;</li><li>n阶完全图<span class="math inline">\(Kn\)</span>中，<spanclass="math inline">\(m=\)</span><spanclass="math inline">\(\frac{1}{2}\)</span>n(n-1);</li><li>两个图同构的必要条件：<ol type="1"><li>它们有相同的结点数和相同的边数</li><li>对应结点的度数相同</li></ol></li></ul><h2 id="路">路</h2><h3 id="概念-2">概念</h3><ul><li>开路、真路、回路、环<ul><li>没有重复结点的开路是真路</li><li>没有重复结点的回路是环</li></ul></li><li>短程、距离</li></ul><h3 id="性质定理-1">性质定理</h3><ul><li>设G是具有结点集<spanclass="math inline">\(V={v_1,v_2,...,v_n}\)</span>的图，则对于任意两个相连接的结点<spanclass="math inline">\(v_i,v_j \in V (v_i \neqv_j)\)</span>，其短程是一条长度不大于n-1的真路</li></ul><h2 id="图的矩阵表示">图的矩阵表示</h2><p>设<span class="math inline">\(G = (V, E)\)</span>，其中 <spanclass="math inline">\(V = \left\{ v_1, v_2, ...,v_n\right\}\)</span></p><ul><li><p>邻接矩阵<span class="math inline">\(A = (a_{ij})\)</span></p><p><span class="math display">\[ a_{ij} =\left\{ \begin{aligned} 1&amp;&amp;{若\left\{ v_i, v_j \right\}} \in E \\ 0&amp; &amp;否则\end{aligned} \right. \]</span>​</p><ul><li>一个图的邻接矩阵是对角线元素均为0的0-1矩阵，反之，一个对角线全为0的0-1矩阵一定可以唯一地做一个图</li><li>如果两个图的邻接矩阵可以通过行列变换得到，那么这两个图同构</li><li>图G的邻接矩阵A的第i行（或第i列）出现1的个数就是节点<spanclass="math inline">\(v_i\)</span>​的度</li><li><span class="math inline">\(A^l (l = 1, 2, 3, ...)\)</span>的<spanclass="math inline">\((i, j)\)</span>项元素<spanclass="math inline">\(a_{ij}^{(l)}\)</span>是连接<spanclass="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>长度为l的路的总数</li></ul></li><li><p>关联矩阵<span class="math inline">\(I =(b_{ij})\)</span>是一个n<spanclass="math inline">\(\times\)</span>m矩阵</p><p><span class="math display">\[b_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若v_i和e_j是关联的 \\ 0&amp; &amp;否则  \end{aligned}\right.\]</span></p><ul><li>I中每一列都正好包含两个 1，并且任何两个列都是不相同的</li><li>第i行中的1的个数即为节点<spanclass="math inline">\(v_i\)</span>的度</li></ul></li><li><p>连接矩阵<span class="math inline">\(C = (c_{ij})\)</span></p><p><span class="math display">\[c_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若从v_i到v_j存在一条路 \\ 0&amp; &amp;否则 \end{aligned}\right.\]</span>​</p><ul><li>当C中所有元素都为1时图是连通 的</li></ul></li></ul><h2 id="图的连通性">图的连通性</h2><h3 id="概念-3">概念</h3><ul><li><p>连通图：如果存在一条路连接<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>，则称结点<spanclass="math inline">\(v_i\)</span>与<spanclass="math inline">\(v_j\)</span>是连接的，若G中任意两个节点均是连接的，则称图G是连通的</p></li><li><p>割边：如果在图G中删去边<span class="math inline">\(\left\{v_i,v_j\right\}\)</span>后，图G的分图数增加，则称边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>是G的割边</p></li><li><p>割点：如果在图G中删去结点<spanclass="math inline">\(v_i\)</span>及与其相关联的边之后，图G的分图数增加，则称结点<spanclass="math inline">\(v_i\)</span>是G的割点</p></li><li><p>边割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有E的子集S，使得在图G中删去S中的所有边后，得到的子图G-S变成具有两个分图的不连通图，而删去了S的任一真子集后，得到的子图仍然是连通图，则称S是G的一个边割集</p></li><li><p>点割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有V的子集<spanclass="math inline">\(V_1\)</span>使得在图G中删除了<spanclass="math inline">\(V_1\)</span>中的所有结点之后，所得到的子图<spanclass="math inline">\(G - V_1\)</span>不连通或为平凡图，则称<spanclass="math inline">\(V_1\)</span>是G的一个点割集</p><p><strong>（割点是点割集的特例）</strong></p></li><li><p>断集：设<span class="math inline">\(G = (V,E)\)</span>是一连通图，<span class="math inline">\(V_1 \subsetV\)</span>, G中端点分别属于<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>的所有边的集合，则成为G的断集</p><p><strong>边割集是断集的特例</strong></p></li><li><p>关联集：设v是图<span class="math inline">\(G =(V,E)\)</span>的一个结点，与v相关联的所有边的集合，称为结点v的关联集，记作<spanclass="math inline">\(S(v)\)</span></p></li><li><p>点连通度：<span class="math inline">\(K(G) = min\left\{\\#V_i|V_i是G的点割集\right\}\)</span>，点连通度是为了使G成为一个非连通图需要删除的点的最少数目</p></li><li><p>边连通度：λ<span class="math inline">\((G) = min\left\{ \#S|S是G的断集\right\}\)</span>，边连通度是为了使G成为一个非连通图需要删去的边的最少数目</p></li></ul><h3 id="性质定理-2">性质定理</h3><ul><li>图G中，边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>为割边的充要条件是边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>不在G的任何环中出现</li><li>在图G中，结点v为割点的充要条件是存在两个结点u和w，使得连接u和w的所有路中都出现结点v</li><li>对于一个给定的图<span class="math inline">\(G = (V, E)\)</span>，如果能把结点集V分成两个互补的子集<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(V&#39;\)</span>，使得同一结点集中的任意两个结点之间，至少存在一条不包含另一个结点子集中的任何结点的路，那么G中的端点分别在<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>​中的边组成G的一个边割集</li><li>对于任意的图<span class="math inline">\(G = (V, E)\)</span>，有<spanclass="math inline">\(K(G) \leq \lambda(G)\leq  \delta(G)\)</span>（其中<spanclass="math inline">\(\delta(G)\)</span>是图G的最小度</li></ul><h2 id="欧拉图">欧拉图</h2><h3 id="概念-4">概念</h3><ul><li>欧拉回路：在图G中找到一个回路，它通过G的每条边一次且仅一次</li><li>欧拉路：具有欧拉回路的图</li><li>欧拉图：通过图G每条边一次且仅一次的开路</li></ul><h3 id="性质定理-3">性质定理</h3><ul><li>一个连通图G为欧拉图的充要条件是G的每一结点的度均为偶数</li><li>连通图G具有一条连接结点<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>的欧拉路的充要条件是，<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>​是G中仅有的具有奇数度的结点</li><li>欧拉回路的边不可以重复但是结点可以重复，所以欧拉回路不一定是环路</li></ul><h2 id="哈密顿图">哈密顿图</h2><h3 id="概念-5">概念</h3><ul><li><p>哈密顿环：找到一个环它通过图G的每个结点一次且仅一次</p><p>哈密顿路：通过图G每个结点一次且仅一次的开路</p><p>哈密顿图：具有哈密顿环的图</p></li><li><p>闭图：设G是具有n个结点的图，若对于<spanclass="math inline">\(deg(u)+deg(v) \geqn\)</span>​的每一对结点u和v，均有u和v相邻接，则称图G是闭图</p></li><li><p>闭包：图G的闭包是一个与G有相同结点集的闭图，记作<spanclass="math inline">\(G_c\)</span>，使<span class="math inline">\(G\subset G_c\)</span>，且异于<spanclass="math inline">\(G_c\)</span>的任何图H，若<spanclass="math inline">\(G \subset H \subset G_c\)</span>，则G不是闭图</p><p><strong>图G的闭包是包含图G的最小闭图</strong></p></li></ul><h3 id="性质定理-4">性质定理</h3><ul><li>图G的闭包是唯一的</li><li>每个哈密顿图都一定是连通的</li><li>若图<span class="math inline">\(G =(V,E)\)</span>是哈密顿图，则对于V的任何一个非空子集S，有<spanclass="math inline">\(W(G-S)\leq\#S\)</span>，这里<spanclass="math inline">\(W(G-S)\)</span>表示G - S中分图的个数</li><li>设G是具有n个结点的图，若有结点u和v不相邻接，且<spanclass="math inline">\(deg(u) + deg(v) \geq n\)</span>，则当且仅当图<spanclass="math inline">\(G+\left\{u,v\right\}\)</span>是哈密顿图时，图G时哈密顿图</li><li>设有图G当且仅当<spanclass="math inline">\(G_c\)</span>​是哈密顿图时，图G是哈密顿图</li><li>若图G的闭包<span class="math inline">\(G_c = K_n\)</span>，且<spanclass="math inline">\(n \geq 3\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#G \geq3\)</span>，若V中任意两个不相邻的结点u和v，均有<spanclass="math inline">\(deg(u) + deg(v) \geqn\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#V \geq 3\)</span>，若对于任意的<spanclass="math inline">\(v \in V\)</span>，均有<spanclass="math inline">\(deg(v) \geq\frac{n}{2}\)</span>，则G是哈密顿图</li></ul><h2 id="树">树</h2><h3 id="概念-6">概念</h3><ul><li><p>树：不包含环的连通图</p><p>树林：不包含环的图</p><p>树叶：度为1的结点</p></li><li><p>生成树：若连通图G的生成子图T是一棵树，T是G的生成树</p><p>最小生成树：在所有生成树中有最小权值</p></li><li><p>若G是一<spanclass="math inline">\((n,m)\)</span>连通图，G的生成树<spanclass="math inline">\(T_G\)</span>是一<spanclass="math inline">\((n,n-1)\)</span>图</p><p>环秩：在得到<spanclass="math inline">\(T_G\)</span>之前需要删除的边的总数为<spanclass="math inline">\(m-(n-1)\)</span>，该数为环秩，环秩是为了“弄破”G的所有环而必须由G中删去的边的最小数目</p><p>弦：被删去的每一条边</p><p>枝：在生成树<span class="math inline">\(T_G\)</span>中的边</p></li></ul><h1 id="性质定理-5">性质定理</h1><ul><li><p>在<span class="math inline">\((n,m)\)</span>树中，<spanclass="math inline">\(m = n - 1\)</span></p></li><li><p>具有两个或更多个结点的树至少有两片树叶</p></li><li><p>两个节点之间由唯一的真路连接的图就是树</p><p><span class="math inline">\(m=n-1\)</span>的连通图是树</p><p><span class="math inline">\(m=n-1\)</span>​且无环的图是树</p></li></ul><h2 id="有向树">有向树</h2><h3 id="概念-7">概念</h3><ul><li><p>有向树：一个不包含环的有向图G，若它只有一个结点<spanclass="math inline">\(v_0\)</span>入度为0，而所有其它结点入度为1</p></li><li><p>根：节点<span class="math inline">\(v_0\)</span></p><p>树叶或终点：出度为0的结点</p><p>级：从<span class="math inline">\(v_0\)</span>到结点<spanclass="math inline">\(v_i\)</span>的距离</p></li><li><p>m元树：在一有向树中，若每一个结点的出度都小于或等于m</p><p>完全m元树：若每个结点的出度等于m或0</p></li><li><p>外部结点：树叶结点</p><p>内部结点：分支结点</p></li><li><p>外部路径长度：根到所有外部结点的距离和</p><p>内部路径长度：根到所有内部结点的距离和</p><p>树的路径长度：根到所有结点的距离和</p></li><li><p>有序树：规定了每一级上结点的次序，一般规定同一级结点的次序为从左到右</p></li><li><p>前缀码：在一个序列的集合中，如果没有一个序列是另一个序列的前缀，则称该序列的集合为前缀码</p></li><li><p>最优树：一颗带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树，如果在所有带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树中具有最小的权，则称为最优树</p></li></ul><h3 id="性质定理-6">性质定理</h3><ul><li>一颗二元树第i级的最大结点数是<spanclass="math inline">\(2^i\)</span>，高度为h的二元树的最大结点数为<spanclass="math inline">\(2^{h+1}-1\)</span>​</li><li>设T为一颗完全二元树（T不为孤立结点）有r个内部结点，内部路径长度为I，外部路径长度为E，则<spanclass="math inline">\(E=I+2r\)</span></li><li>设T为一颗二元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，<spanclass="math inline">\(n_2\)</span>个出度为2的结点，则<spanclass="math inline">\(n_2=n_0-1\)</span></li><li>设T是一颗完全二元树，有n个结点，<spanclass="math inline">\(n_0\)</span>个叶节点，则<spanclass="math inline">\(n=2n_0-1\)</span></li><li>设T是一颗完全m元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，t个分支结点，则<spanclass="math inline">\((m-1)t=n_0-1\)</span></li></ul><h2 id="二部图">二部图</h2><h3 id="概念-8">概念</h3><ul><li><p>二部图：若一个图G的结点集V能分成两个子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>使得<span class="math inline">\(V_1\cup V_2=V\)</span>,<span class="math inline">\(V_1 \cap V_2 =\varnothing\)</span>，使得G的每一条边<spanclass="math inline">\(\left\{V_i,V_j\right\}\)</span>的端点<spanclass="math inline">\(v_i \in V1, v_j \inV_2\)</span>，则称图G是一个二部图</p><p>完全二部图：如果<spanclass="math inline">\(V_1\)</span>的每一个结点和<spanclass="math inline">\(V_2\)</span>的每一个结点想邻接，则G为完全二部图</p></li><li><p>匹配：设G是具有互补结点子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>的二部图，其中<spanclass="math inline">\(V_1=\left\{v_1,v_2,...,v_q\right\}\)</span>，<spanclass="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配是G的一个子图，它由q条边<spanclass="math inline">\(\left\{v_1,v_1&#39;\right\},\left\{v_2,v_2&#39;\right\},...,\left\{v_q,v_q&#39;\right\}\)</span>组成，其中<spanclass="math inline">\(v_1&#39;,v_2&#39;,...v_q&#39;\)</span>是<spanclass="math inline">\(V_2\)</span>中q个不同的元素</p></li></ul><h3 id="性质定理-7">性质定理</h3><ul><li>图G为二部图的充要条件是至少有两个节点，它的所有回路均为偶数长</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>必要条件</strong>是<spanclass="math inline">\(\# V_2 \geq \#V_1\)</span></li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充要条件</strong>是<spanclass="math inline">\(V_1\)</span>中每k个结点至少和<spanclass="math inline">\(V_2\)</span>​中k个结点相邻接</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充分条件</strong>是，存在某一整数<spanclass="math inline">\(t&gt;0\)</span>使<ol type="1"><li>对<spanclass="math inline">\(V_1\)</span>中每个结点，至少有t条边与其相关联</li><li>对<spanclass="math inline">\(V_2\)</span>中每个结点，至多有t条边与其相关联</li></ol></li></ul><h2 id="平面图">平面图</h2><h3 id="概念-9">概念</h3><ul><li>平面图：能画于平面上而无任何交叉</li></ul><h3 id="性质定理-8">性质定理</h3><ul><li>平面图的欧拉公式：设G是一连通的平面图，则有<spanclass="math inline">\(n-m+k=2\)</span>这里的n、m、k分别是图G的结点数、边数、面数（包括无限面）</li><li>有两条或者更多条边的任何连通的平面图G中,有<spanclass="math inline">\(m \leq 3n-6\)</span></li><li><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051141374.png"alt="image-20240505114109639" /><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051243937.png"alt="image-20240505124328184" /></li></ul><h2 id="有向图">有向图</h2><h3 id="概念-10">概念</h3><ul><li><p>弱连通：看作无向图时是连通的</p><p>单向连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>中至少有一个由另一个出发是可达的</p><p>强连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>都是相互可达的</p><p><strong>强连通的有向图是单向连通的，单向连通的有向图是弱连通的</strong></p></li><li><p>强分图、单向分图、弱分图分别是G的极大连通子图、极大单向连通子图、极大弱连通子图</p></li></ul><h3 id="性质定理-9">性质定理</h3><ul><li><p>一个连通的有向图具有欧拉回路的充要条件是，G的每一个结点的入度和出度相等</p><p>一个连通的有向图具有欧拉路的充要条件是，除了两个结点外，G的每一个结点的入度和出度相等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>级数</title>
      <link href="/2024/05/27/%E7%BA%A7%E6%95%B0/"/>
      <url>/2024/05/27/%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数项级数">数项级数</h1><h2 id="概念">概念</h2><p><strong>数项级数：</strong> 给定一列实数<spanclass="math inline">\(a_1,a_2,...,a_n\)</span>，称<spanclass="math inline">\(a_1+a_2+...+a_n+...\)</span>为一个数项级数，简称级数</p><p><strong>部分和：</strong>称<spanclass="math inline">\(S_n=\sum\limits_{k=1}^{k=n}a_k\)</span>为级数的部分和</p><p><strong>级数的和：</strong> <spanclass="math inline">\(S=\lim\limits_{n \to\infty}S_n\)</span>，s是级数的和，<spanclass="math inline">\(S=\sum\limits_{n=1}^{\infty}a_n\)</span></p><p><strong>余项：</strong> <spanclass="math inline">\(R_n=S-S_n=\sum\limits_{k=n+1}^{\infty}a_k\)</span></p><h3 id="敛散性的定义">敛散性的定义</h3><p><spanclass="math inline">\(\color{red}{改变级数的有限项，不影响其敛散性}\)</span></p><ol type="1"><li>当S有限的时候，级数收敛</li><li>若级数收敛，则<span class="math inline">\(\lim\limits_{n \to\infty}a_n=0\)</span><ul><li>只要级数收敛，则通项趋于零；通项不趋于零时，级数必发散 <spanclass="math inline">\((eg:\sum a_n收敛\Rightarrow\sum\limits_{n=1}^{\infty}\frac{1}{1+|a_n|}发散)\)</span></li><li>通项趋于零的级数不一定都收敛 <span class="math inline">\((eg:\,\sum\limits_{n=1}^\infty  \frac{1}{n_p})\)</span></li><li>发散的级数通项不一定不趋于零<spanclass="math inline">\((eg:\sum\limits_{n=1}^{\infty}\frac{1}{n})\)</span>​</li></ul></li><li><span class="math inline">\(\sum a_n,\sum b_n\)</span>收敛<spanclass="math inline">\(\Rightarrow\)</span><spanclass="math inline">\(\sum (a_n +b_n)\)</span>收敛</li><li><span class="math inline">\(\sum a_n\)</span>收敛，<spanclass="math inline">\(\sum b_n\)</span>发散<spanclass="math inline">\(\Rightarrow\)</span><spanclass="math inline">\(\sum(a_n+b_n)\)</span>发散</li></ol><h3 id="常见级数">常见级数</h3><ul><li>几何级数：<span class="math inline">\(\sum\limits_{n=0}^{\infty}r^n= 1+r+r^2+...\)</span><ol type="1"><li><span class="math inline">\(\left|r \right| &lt;1\)</span>，收敛，且和为<spanclass="math inline">\(\frac{1}{1-r}\)</span></li><li><span class="math inline">\(|r|\geq1\)</span>，发散</li></ol></li><li>p-级数：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}\frac{1}{n^p}=1+\frac{1}{2^p}+\frac{1}{3^p}+...\)</span>​<ol type="1"><li><span class="math inline">\(p&gt;1\)</span>，收敛</li><li><span class="math inline">\(p\leq1\)</span>，发散</li></ol></li><li>调和级数：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}\frac{1}{n}=1+\frac{1}{2}+\frac{1}{3}+...\)</span>​<ol type="1"><li>发散</li></ol></li></ul><h2 id="正项级数">正项级数</h2><p>形式：<span class="math inline">\(a_n \geq 0\)</span>​</p><h3 id="判别法">判别法</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405272227749.jpg" /></p><ol type="1"><li><p><spanclass="math inline">\(A_n=\sum\limits_{k=1}^{n}a_k\)</span>随n单调增加，因此<spanclass="math inline">\(\sum a_n收敛\Leftrightarrow\left\{A_n\right\}极限存在\Leftrightarrow\left\{A_n\right\}有界\)</span>​</p></li><li><p>一般形式的<strong>比较判别法</strong></p><p>若从某项起有<span class="math inline">\(a_n\leq b_n\)</span></p><ul><li><p>当<span class="math inline">\(\sum b_n\)</span>收敛时，<spanclass="math inline">\(\sum a_n\)</span>收敛</p></li><li><p>当<span class="math inline">\(\sum a_n\)</span>发散时，<spanclass="math inline">\(\sum b_n\)</span>发散</p></li></ul></li><li><p>极限形式的<strong>比较判别法</strong></p><p>若<span class="math inline">\(b_n\neq 0,\lim\limits_{n\to\infty}a_n/b_n=l\)</span></p><ul><li><p><span class="math inline">\(0&lt;l&lt;+\infty\)</span>时，<spanclass="math inline">\(\sum a_n与\sum b_n\)</span>敛散性相同</p></li><li><p><span class="math inline">\(l=0\)</span>时，<spanclass="math inline">\(\sum b_n收敛，\sum a_n收敛\)</span></p></li><li><p><span class="math inline">\(l=+\infty\)</span>时，<spanclass="math inline">\(\sum b_n发散，\sum a_n发散\)</span>​</p></li></ul></li><li><p><strong>比值判别法</strong> --适用于连乘</p><p>若<spanclass="math inline">\(\lim\limits_{n\to\infty}\frac{a_{n+1}}{a_n}=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(l&lt;1\)</span>时，收敛</li><li><span class="math inline">\(l&gt;1\)</span>时，发散</li></ul></li><li><p><strong>根值判别法</strong> --适用于n次幂</p><p>若<spanclass="math inline">\(\lim\limits_{n\to\infty}\sqrt[n]{a_n}=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(l&lt;1\)</span>时，收敛</li><li><span class="math inline">\(l&gt;1\)</span>​时，发散</li></ul></li><li><p><strong>积分判别法</strong></p><p>设<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\([1,+\infty)\)</span>上非负且单调减，<spanclass="math inline">\(a_n=f(n)\)</span> <spanclass="math inline">\((n=1,2,3,...)\)</span>，则<spanclass="math inline">\(\sum a_n\)</span>与<spanclass="math inline">\(\int_1^{+\infty}f(x)dx\)</span>敛散性相同</p></li><li><p><strong>比阶判别法</strong></p><p>设<span class="math inline">\(\sum a_n\)</span>是一正项级数，<spanclass="math inline">\(\lim n^pa_n=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(p&gt;1且0\leql&lt;+\infty\)</span>时，收敛</li><li><span class="math inline">\(p\leq 1且0&lt;l\leq+\infty\)</span>时，发散</li></ul></li></ol><h2 id="变号级数">变号级数</h2><p>形式：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}(-1)^{n-1}a_n，其中a_n&gt;0\)</span></p><h3 id="判别法-1">判别法</h3><p>Leibniz判别法：若<spanclass="math inline">\(\left\{a_n\right\}\)</span><strong>单调减</strong>且收敛于零，则级数收敛，在完全单调减的条件下，其和<spanclass="math inline">\(S\leq a_1\)</span>，余项<spanclass="math inline">\(R_n\)</span>满足<spanclass="math inline">\(|R_n|\leq a_{n+1}\)</span></p><h3 id="绝对收敛与相对收敛">绝对收敛与相对收敛</h3><p>绝对收敛：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}|a_n|收敛\)</span></p><p>条件收敛：<spanclass="math inline">\(\sum_\limits{n=1}^{\infty}a_n\)</span>收敛，但<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}|a_n|\)</span>发散</p><h1 id="函数项级数">函数项级数</h1><h2 id="概念-1">概念</h2><p><strong>函数项级数</strong>：定义域<em>I</em>上的一列函数<spanclass="math inline">\(u_n(x)\)</span>，称<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}u_n(x)=u_1(x)+u_2(x)+...+u_n(x)+...\)</span>为<em>I</em>上的一个函数项级数</p><p><strong>收敛点</strong>：<span class="math inline">\(x_0\inI\)</span>，数项级数<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}u_n(x_0)\)</span>收敛，则称<spanclass="math inline">\(x_0\)</span>为级数的收敛点</p><p><strong>收敛域</strong>：全体收敛点构成的集合B为级数的收敛域</p><p><strong>和函数</strong>：对每一个<span class="math inline">\(x\inB\)</span>，以<spanclass="math inline">\(S(x)\)</span>记级数的和，是定义于收敛域B上的函数</p><p><strong>部分和</strong>：<spanclass="math inline">\(S_n(x)=\sum\limits_{k=1}^{n}u_k(x)\)</span>是级数的部分和，定义于<em>I</em>上的函数</p><p><strong>余项</strong>：<spanclass="math inline">\(R_n(x)=S(x)-S_n(x)=\sum\limits_{k=n+1}^{\infty}u_k(x)\)</span>，仅在集合B上有定义</p><h2 id="一致收敛">一致收敛</h2><p>设级数在点集A上收敛，若<span class="math inline">\(\forall\varepsilon&gt;0,\exist N&gt;0,\forall n\geq N,\forall x\inA:|R_n(x)|&lt;\varepsilon\)</span>，则说级数在A上一致连续</p><h2 id="weierstrass判别法">Weierstrass判别法</h2><p>若存在一个收敛的正项级数<span class="math inline">\(\sumb_n\)</span>，使得<span class="math inline">\(|u_n(x)|\leqb_n\)</span>，则级数在A上绝对收敛且一致收敛</p><h2 id="和函数的分析性质">和函数的分析性质</h2><p>在一致收敛条件下，有：</p><ol type="1"><li>“逐项求导”：<spanclass="math inline">\((\sum\limits_{n=1}^{\infty}u_n(x))&#39;=\sum\limits_{n=1}^{\infty}u_n&#39;(x)\)</span></li><li>“逐项积分”：<spanclass="math inline">\(\int_{\alpha}^{\beta}\sum\limits_{n=1}^{\infty}u_n(x)dx=\sum\limits_{n=1}^{\infty}\int_{\alpha}^{\beta}u_n(x)dx\)</span></li></ol><h1 id="幂函数">幂函数</h1><h2 id="概念-2">概念</h2><p><strong>幂级数</strong>：</p><ol type="1"><li><p><spanclass="math inline">\(\sum\limits_{n=0}^{\infty}a_nx^n=a_0+a_1x+...+a_nx^n+...\)</span></p></li><li><p><spanclass="math inline">\(\sum\limits_{n=0}^{\infty}a_n(x-x_0)^n=a_0+a_1(x-x_0)+...+a_n(x-x_0)^n+...\)</span></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无穷级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静电场</title>
      <link href="/2024/05/24/%E9%9D%99%E7%94%B5%E5%9C%BA/"/>
      <url>/2024/05/24/%E9%9D%99%E7%94%B5%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电荷和库仑定律"><a href="#电荷和库仑定律" class="headerlink" title="电荷和库仑定律"></a>电荷和库仑定律</h1><p>电子e：$1.602 \times 10^{-19}C$</p><p>库仑定律：</p><blockquote><p>库仑定律对运动的电荷不成立，因为会产生磁场；但是高斯定理对运动的电荷成立</p></blockquote><p>$F=k\frac{q_1 q_2}{r^2}\vec{e_r}$，其中$k=\frac{1}{4\pi \varepsilon_0}=9\times 10^9, \varepsilon_0=8.8542=10^{-12}C^2/(N\cdot m^{-2})$​</p><h1 id="静电场与电场强度"><a href="#静电场与电场强度" class="headerlink" title="静电场与电场强度"></a>静电场与电场强度</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>电场强度：$E=\frac{F}{q_0}$，单位：$N/C或V/m$​</p><p>点电荷：$E=\frac{q}{4\pi \varepsilon_0r^2}\vec{e_r}$</p><p>线电荷密度：$\lambda$     面电荷密度：$\sigma$    体电荷密度：$\rho$</p><p>$\color{red}{(\lambda = \sigma dy)}$</p><h2 id="各特殊模型产生的场强"><a href="#各特殊模型产生的场强" class="headerlink" title="各特殊模型产生的场强"></a>各特殊模型产生的场强</h2><ol><li><p>电偶极子</p><p>电偶极子：两相隔一定距离的等量异号点电荷</p><p>$\vec{l}$：负电荷到正电荷的矢量线段</p><p>电偶极矩：$\vec{p}=q\vec{l}$</p><p>$E=-\frac{ql}{4\pi \varepsilon_0 (r^2 + l^2/4)^{\frac{3}{2}}}$，若$r\gg l$，<strong>$\color{forestgreen}{E=-\frac{ql}{4\pi \varepsilon_0r^3}}$</strong></p></li><li><p>均匀带电直线</p><blockquote><p>利用$dq=\lambda dy$进行积分</p></blockquote><p>无限长：$\color{forestgreen}E=\frac{\lambda}{2\pi\varepsilon_0x}$</p></li><li><p>均匀带电平面</p><p>无限大：$\color{forestgreen}E=\frac{\sigma}{2\varepsilon_0}$</p></li><li><p>均匀带电圆环</p><blockquote><p>利用$dq=\lambda dy$进行积分</p></blockquote><p>沿轴线：$E=\frac{xQ}{4\pi\varepsilon_0(x^2+R^2)^{\frac{3}{2}}}$  ，若$x\gg R$：$\color{forestgreen}E=\frac{Q}{4\pi\varepsilon_0 x^2}$</p></li><li><p>均匀带电圆盘</p><blockquote><p>圆盘是由圆环组成，对dr进行积分</p></blockquote><p>沿轴线：$\color{forestgreen}E=\frac{\sigma}{2\varepsilon_0}(1-\frac{x}{\sqrt{R^2+x^2}})$</p><ul><li>当$x\ll R$，圆盘可视为无限大的平面，$E=\frac{\sigma}{2\varepsilon_0}$</li><li>当$x\gg R$，圆盘可视为点电荷，$E=\frac{q}{4\pi \varepsilon_0 x^2}$（q为圆盘的总带电量$q=\sigma \pi R^2$</li></ul></li><li><p>均匀带电球面</p><blockquote><p>$dq=\sigma 2\pi r’dl, r’=R\sin\theta$，对圆盘上的圆环进行积分</p></blockquote><p>当$x&gt;R$时，$\color{forestgreen}E=\frac{Q}{4\pi\varepsilon_0 x^2}$</p><p>当$x&lt;R$时，$E=0$</p></li></ol><h1 id="高斯定理"><a href="#高斯定理" class="headerlink" title="高斯定理"></a>高斯定理</h1><p>$\Phi<em>e=\oint_S\vec{E}\cdot d\vec{S}=\frac{1}{\varepsilon_0}\sum\limits</em>{S_{\text{内}}}q_i$​</p><p>——揭示了静电场是有源场</p><p>注意：</p><ol><li>$\Phi_E只取决于S面包围的电荷，S面外的电荷对\Phi_E无贡献$</li><li>$\vec{E}$是所取封闭面S（高斯面）上的场强，它是由全部电荷$\color{red}{S内外}$​共同产生的合场强</li></ol><h2 id="高斯面的选取"><a href="#高斯面的选取" class="headerlink" title="高斯面的选取"></a>高斯面的选取</h2><p>高斯面（封闭面）应该选在场强相等的封闭曲面上，如果场强相等的曲面不封闭，则应该添加与场强方向垂直的面共同形成封闭曲面</p><ol><li>球对称：选与带电体同心的球面</li><li>轴对称：选与带电体同轴的圆柱面</li><li>面对称：选轴与带电面垂直，两底与带电面等距平行的圆柱面</li></ol><blockquote><p>对于一个球体中挖去一个小球体，求空腔内一点的电场强度：先将球体补齐，算大球体和补进去的小球体产生的场强，一减即可</p></blockquote><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406122012174.png" alt=""></p><p>$\color{red}{不能直接取高斯面，因为E和r不是平i平行的的}$</p><h1 id="环路定理"><a href="#环路定理" class="headerlink" title="环路定理"></a>环路定理</h1><p>——- 揭示了静电场的无旋性</p><p>$\oint_L\vec{E}\cdot d\vec{l}=0$</p><p>静电场做功：$\frac{A}{q_0}=\frac{q}{4\pi\varepsilon(\frac{1}{r_a}-\frac{1}{r_b})}(r_a,r_b表示场源电荷到被移动电荷的起点和终点距离)$</p><h1 id="电势差和电势"><a href="#电势差和电势" class="headerlink" title="电势差和电势"></a>电势差和电势</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>点电荷$q<em>0$从P到Q，电场力做功为：$A</em>{PQ}=q<em>0\int</em>{P}^Q\vec{E}\cdot d\vec{l}$</p><p>$W_P,W_Q$分别是$q_0$在P点和Q点的静电势能，$W_P-W_Q=q_0\int_P^Q\vec{E}\cdot d\vec{l}$</p><p>P、Q两点的电势差为$V<em>P-V_Q=\int</em>{P}^Q \vec{E}\cdot d \vec{l}$</p><h2 id="电势零点的选取"><a href="#电势零点的选取" class="headerlink" title="电势零点的选取"></a>电势零点的选取</h2><ol><li>场源电荷分布在有限空间，选取无穷远处为电势零点</li><li>电荷分布在无限空间，选有限远点为电势零点</li></ol><h2 id="电势的计算"><a href="#电势的计算" class="headerlink" title="电势的计算"></a>电势的计算</h2><ol><li><p>定义法求电势</p><p>$V<em>P=\int</em>{P}^{V=0处}\vec{E}\cdot d\vec{l}$</p></li><li><p>电势叠加法求电势</p><p>点电荷系场中的电势：$V<em>P=\sum\limits</em>{i}\frac{q_i}{4\pi\varepsilon_0 r_i}$</p><p>任意带电体场中的电势：$V_P=\int_q\frac{dq}{4\pi\varepsilon_0r}$</p></li></ol><h2 id="电势梯度"><a href="#电势梯度" class="headerlink" title="电势梯度"></a>电势梯度</h2><p>电视梯度是电势的最大空间变化率</p><p>$\vec{E}=-grad\,V=-(\frac{\partial}{\partial x}\vec{i}+\frac{\partial}{\partial y}\vec{j} +\frac{\partial}{\partial z}\vec{k})V$</p><h1 id="静电场中的导体"><a href="#静电场中的导体" class="headerlink" title="静电场中的导体"></a>静电场中的导体</h1><blockquote><p>静电感应$\rightarrow$静电平衡$\rightarrow$等势体</p></blockquote><h2 id="静电平衡的条件"><a href="#静电平衡的条件" class="headerlink" title="静电平衡的条件"></a>静电平衡的条件</h2><p>静电平衡：导体表面和内部都没有电荷的定向移动</p><ol><li>导体内部 $\vec{E}=0$</li><li>外表面 $\vec{E}\bot表面$</li></ol><p>推论：导体是等势体，导体表面是等势面</p><p><strong>静电平衡时导体上的电荷分布：</strong></p><ol><li><p>导体内部没有静电荷，电荷分布在外表面上</p></li><li><p>导体内有空腔，腔内无其他带电体，电荷全分布在导体外表面</p></li><li><p>导体表面附近$\vec{E}$的大小与该处的面电荷密度$\sigma$成正比：$\vec{E} = \frac{\sigma}{\varepsilon_0}$</p><p>$\color{red}{\vec{E}}是导体表面电荷和外部电荷的合场强$​</p></li><li><p>孤立导体表面各处的面电荷密度$\sigma$与各处曲率半径R成反比，即$\sigma \propto \frac{1}{R}$</p></li></ol><p><strong>求解静电平衡时的电荷分布：</strong></p><ol><li>取两板之间的高斯柱面，得两板电荷之和为0</li><li>导体内任一点电场为0</li></ol><h2 id="静电屏蔽"><a href="#静电屏蔽" class="headerlink" title="静电屏蔽"></a>静电屏蔽</h2><ol><li><p>腔内无带电体</p><ul><li>内表面无电荷</li><li>腔内$\vec{E} = 0$</li></ul></li><li><p>腔内有带电体</p><ul><li>内表面电荷和腔内电荷等值异号</li><li>外表面电荷与腔内电荷等值同号</li></ul><p>$\color{red}{外表面电荷分布和曲率有关和腔内电荷位置无关}$</p></li></ol><h1 id="静电场中的电介质"><a href="#静电场中的电介质" class="headerlink" title="静电场中的电介质"></a>静电场中的电介质</h1><blockquote><p>电介质是绝缘体，不导电，在外电场$\vec{E}\neq 0$</p></blockquote><h2 id="电介质分子的分类"><a href="#电介质分子的分类" class="headerlink" title="电介质分子的分类"></a>电介质分子的分类</h2><ol><li>无极分子：在无外场作用下，整个分子无电矩</li><li>有极分子：在无外场作用下，整个分子存在固有电矩</li></ol><h2 id="电极化现象"><a href="#电极化现象" class="headerlink" title="电极化现象"></a>电极化现象</h2><p>宏观：电介质表面出现电荷</p><p>端面上束缚电荷越多，电极化程度越强</p><ol><li><p>有极分子</p><p>取向极化：$\vec{E}=0,\sum\vec{p}=0;\vec{E}\neq 0,\vec{M}=\vec{p}\times\vec{E}$</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011444076.png" alt=""></p><p>$\vec{E}\uparrow$，$\vec{p}$排列越整齐</p></li><li><p>无极分子</p><p>位移极化：</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011444423.png" alt=""></p></li></ol><h2 id="电极化强度矢量-vec-P"><a href="#电极化强度矢量-vec-P" class="headerlink" title="电极化强度矢量$\vec{P}$"></a>电极化强度矢量$\vec{P}$</h2><ol><li><p>$\vec{P} = \frac{\sum p_i}{\Delta V}$，单位体积内所有分子的电偶极矩之矢量和，单位$C/m^2$</p></li><li><p>无极分子介质极化的过程中，穿过ds的束缚电荷为$dq=\vec{p}\cdot \vec{e_n}ds$，$\frac{dq}{ds}=\vec{p}\cdot \vec{e_n}$$\Rightarrow$由于电介质极化，在其表面上单位面积所出现的一层束缚电荷，即束缚电荷的面密度$\sigma$和该处电极化强度P在表面法线上的分量值相同$\sigma =\vec{p}\cdot \vec{e_n}$</p></li><li><p>$\vec{P}$与$\vec{E}$成正比，对于各向同性的电介质：$\vec{P} = \varepsilon_0(\varepsilon_r-1)\vec{E}$</p><p>$\chi_e=\varepsilon_r-1$，$\chi_e$—电极化率，$\varepsilon_r$—相对介电常数</p><p>即：$\vec{P}=\chi<em>e \varepsilon_r\vec{E}$，$\overrightarrow{E} = \overrightarrow{E</em>{\text{外}}}+\overrightarrow{E’}$</p></li><li><p>电击穿—电介质的击穿</p><p>当$\vec{E}$足够强的时候，分子中正负电荷被拉开$\rightarrow$自由电荷</p><p>绝缘体$\rightarrow$导体 $\Longrightarrow$ 电介质的击穿</p><p>电介质所能承受的不被击穿的最大的电场强度$\rightarrow$击穿场强</p></li></ol><h2 id="有电介质存在时的静电场的计算​"><a href="#有电介质存在时的静电场的计算​" class="headerlink" title="有电介质存在时的静电场的计算​"></a>有电介质存在时的静电场的计算​</h2><p>在有介质存在空间的电场由自由电荷和介质上的束缚电荷共同产生</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011507578.png" alt=""></p><p>放入介质两极板间的电位差为$\rightarrow$V</p><p>未放入介质两极板间的电位差为$\rightarrow V_0$</p><p>$\Longrightarrow$ $\color{red}{V=\frac{V_0}{\varepsilon_r}}$​</p><h3 id="介质中的高斯定理"><a href="#介质中的高斯定理" class="headerlink" title="介质中的高斯定理"></a>介质中的高斯定理</h3><p>通过高斯面的电位移通量等于高斯面所包围的$\color{red}{自由电荷}$的代数和，与极化电荷和高斯面外的电荷无关</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011528093.png" alt=""></p><p>电介质内的合场强为$\vec{E}=\vec{E’}+\vec{E_0}$​</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849786.png" alt=""></p><p>电位移矢量：$\vec{D}$</p><p>$\vec{D}$线：电场线始于正电荷，止于负电荷；$\vec{D}$线始于正自由电荷，止于正自由电荷</p><p>$\vec{D}$的通量：（均匀）$\Phi_D=\vec{D}\cdot \Delta \vec{S}$，（非均匀）$\Phi_D = \iint_S\vec{D}\cdot d\vec{S}$</p><p>$\color{red}{注：}$ 1. $\vec{D}$由空间所有电荷（自由、束缚、S面内、S面外）共同决定</p><p>​    2. $\iint_S\vec{D}\cdot d\vec{S}$由面内自由电荷决定</p><p>​    3.$\vec{D} = \varepsilon\vec{E}$，$\vec{D}$与$\vec{E}$处处对应方向一致</p><p>​    4.$\oint\vec{D}d\vec{S}=\sum q<em>{\text{自}}$与 $\oint \vec{E}d\vec{S}=\frac{\sum q</em>{\text{自}}+\sum q_{\text{束}}}{\varepsilon_0}$</p><h3 id="环路定理-1"><a href="#环路定理-1" class="headerlink" title="环路定理"></a>环路定理</h3><p>$\oint\vec{E}d\vec{l} = 0$，束缚电荷产生的场强与自由电荷产生的场强相同</p><h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><ol><li><p>$\vec{P}=\chi_E\varepsilon_0\vec{E}$</p></li><li><p>$\vec{D}=\varepsilon_0\varepsilon_r \vec{E}$</p></li><li><p>$\vec{D} = \varepsilon_0 \vec{E}+\vec{P}$</p></li><li><p>空间某点处的$\vec{E}$仅与该点的电介质有关，而该处的$\vec{V}$与积分路径上所有电介质有关</p></li></ol><h1 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h1><h2 id="孤立导体的电容"><a href="#孤立导体的电容" class="headerlink" title="孤立导体的电容"></a>孤立导体的电容</h2><p>若一孤立导体带电$+q$，  该导体具有一定的电势$V$，电容$C=\frac{q}{V}$</p><p>电容的物理意义：孤立导体每升高一个单位的电势所需要的电量</p><h2 id="电容器及其电容"><a href="#电容器及其电容" class="headerlink" title="电容器及其电容"></a>电容器及其电容</h2><p>$C_{AB} = \frac{q}{V_a-V_B}$</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849544.png" alt=""></p><p>增大电容：多个电容并联$C = C_1+C_2+ …+C_k$</p><p>增强耐压：多个电容串联$\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}+…+\frac{1}{C_k}$​</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849265.png" alt=""></p><p><strong>平行板</strong>电容器C：$C=\frac{\varepsilon S}{d}$</p><p><strong>平行板电容器</strong>中有介质时的C：$C = \frac{\varepsilon_0 S}{b-\frac{\varepsilon_r-1}{\varepsilon_r}t}$</p><p><strong>圆柱形电容器</strong>：$C=\frac{2\pi \varepsilon L}{ln(R_B/R_A)}$​</p><blockquote><p>设内外极板所带电荷线密度为$+\lambda$和$-\lambda$，取同轴的高斯柱面$\vec{E} = \frac{\lambda}{2\pi\varepsilon r}\vec{e_r}$</p></blockquote><p><strong>球形电容器</strong>：$C=\frac{4\pi \varepsilon R_AR_B}{R_B-R_A}$​</p><blockquote><p>设内外球壳分别带$+q,-q$</p></blockquote><h3 id="求解电容的方法"><a href="#求解电容的方法" class="headerlink" title="求解电容的方法"></a>求解电容的方法</h3><ol><li>假设极板的上下面电荷密度，利用电势差的关系$\rightarrow$场强$\rightarrow$面电荷密度</li><li>假设极板的上下面电荷密度，利用$D=\sigma$ $\rightarrow$ E $\rightarrow$ $\Delta V$ $\rightarrow$​ C</li><li>根据串并联的规则</li></ol><h1 id="静电场的能量"><a href="#静电场的能量" class="headerlink" title="静电场的能量"></a>静电场的能量</h1><h2 id="电容器的能量"><a href="#电容器的能量" class="headerlink" title="电容器的能量"></a>电容器的能量</h2><p>$W=\frac{1}{2}\frac{Q^2}{C}=\frac{1}{2} CV^2=\frac{1}{2}QV$</p><h2 id="电场的能量"><a href="#电场的能量" class="headerlink" title="电场的能量"></a>电场的能量</h2><p>电场能量密度：$w_e=\frac{1}{2}\varepsilon E^2=\frac{1}{2}\vec{D}\cdot\vec{E}$</p><p>电场能量：$W=\frac{1}{2}\int\varepsilon E^2dV=\frac{1}{2}\int \vec{D}\cdot\vec{E}dV$</p><h2 id="电荷在外电场中的电势能"><a href="#电荷在外电场中的电势能" class="headerlink" title="电荷在外电场中的电势能"></a>电荷在外电场中的电势能</h2><p>$1eV=1.6\times 10^{-19}J$</p><p><strong>电势能</strong>：$W=qV$</p><p><strong>静电互能</strong>：一个点电荷在外电场中的电势能，属于该电荷和场源电荷所共有</p><h2 id="带电体系的静电能"><a href="#带电体系的静电能" class="headerlink" title="带电体系的静电能"></a>带电体系的静电能</h2><p><strong>静电能</strong>：系统中所有电荷之间相互作用能的总和成为该电荷系统的静电能</p><ul><li>将系统中各电荷从现有位置到彼此分散到无限远的过程中，他们之间的静电力所做的功</li><li>将各电荷从彼此分散在无限远处移动到现有位置过程，外力做的功</li></ul><p>$W<em>{\text{总静电能}}=W</em>{\text{互}}+W_{\text{自}}$</p><p><strong>自能</strong>：单一带电体自身电荷元相互作用的静电能</p><p><strong>互能</strong>：不同带电体上电荷的相互作用的静电能</p><h3 id="点电荷的互能"><a href="#点电荷的互能" class="headerlink" title="点电荷的互能"></a>点电荷的互能</h3><p>两个点电荷组成的系统：因为$A<em>{12}=A</em>{21}$ ,所以$W=\frac{1}{2}(q_1V_1+q_2V_2)$</p><p>n个点电荷组成的系统：第i个电荷的电荷量为$q<em>i$，其他电荷在$q_i$处产生的电势为$V_i$，则点电荷系的静电能为$W=\frac{1}{2}\sum\limits</em>{i-1}^{n}q_iV_i$</p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 静电场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静电场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲线积分与曲面积分</title>
      <link href="/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/"/>
      <url>/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一型曲线积分">第一型曲线积分</h1><h2 id="形式">形式</h2><p><span class="math inline">\(\int_{L}f ds\)</span>​ --表示曲线L的质量，f是密度函数</p><h2 id="方法">方法</h2><ol type="1"><li><strong>化为定积分</strong></li></ol><p><span class="math inline">\(\int_{L}f ds =\int_{\alpha}^{\beta}f(x(t),y(t),z(t))\sqrt{x(t)&#39;^{2} +y(t)&#39;^{2} +z(t)&#39;^{2}}dt\)</span>​</p><ul><li>极坐标：<span class="math inline">\(ds=\sqrt{r(\theta)^2 +r(\theta)&#39;^2}d\theta\)</span></li><li>xy平面曲线：<span class="math inline">\(ds =\sqrt{1+y(t)&#39;^2}dx\)</span>​</li></ul><ol start="2" type="1"><li><strong>对称性</strong></li></ol><ul><li>平面曲线L关于<spanclass="math inline">\(y=x\)</span>对称，且被积函数在L上连续：可以交换x，y</li><li>空间曲线L关于<spanclass="math inline">\(y=x=z\)</span>对称，且被积函数在L上连续：x,y,z具有轮换对称性</li></ul><ol start="3" type="1"><li><p><strong>质心</strong></p><p>当被积函数是只有一次参变量时，可以利用已知质心进行计算</p></li></ol><h1 id="第二型曲线积分">第二型曲线积分</h1><h2 id="形式-1">形式</h2><p><span class="math inline">\(\int_{L}\vec{F} \cdot d\vec{r} = \int_L\vec{F} \cdot \vec{\tau}ds = \int_LPdx+Qdy+Rdz = \int_L Pcos\alpha +Qcos\beta + Rcos\gamma ds\)</span></p><p><spanclass="math inline">\(\vec{\tau}\)</span>为L的切矢量，其方向余弦为<spanclass="math inline">\({cos\alpha,cos\beta,cos\gamma}\)</span>，<spanclass="math inline">\(\vec{F} = \left\{P,Q,R\right\}\)</span>，<spanclass="math inline">\(d\vec{r} = \left\{dx,dy,dz\right\}\)</span> --变力沿​曲线做功</p><h2 id="方法-1">方法</h2><ol type="1"><li><p><strong>化为定积分</strong></p></li><li><p>Green公式</p><p><span class="math inline">\(\oint_L Pdx + Qdy = \iint_\limits{D}(Q_x- P_y)dxdy\)</span></p><ul><li>简单闭曲线</li><li>函数P，Q在D上包括边界有连续一阶偏导数</li></ul></li><li><p>积分与路径无关</p></li></ol><ul><li>可化成全微分</li><li><span class="math inline">\(Q_x = P_y\)</span></li><li>D内任何分段光滑闭曲线C，<span class="math inline">\(\oint_C Pdx+Qdy= 0\)</span></li></ul><ol start="4" type="1"><li>除<spanclass="math inline">\(M_0\)</span>点外，P，Q处处有一节连续偏导数，<spanclass="math inline">\(Q_x = P_y\)</span>，<spanclass="math inline">\(\color{red}{任何}\)</span>包围<spanclass="math inline">\(M_0\)</span>的<spanclass="math inline">\(\color{red}{正向}\)</span>简单闭曲线L，积分<spanclass="math inline">\(\oint_L Pdx+Qdy\)</span>取同一值</li></ol><h1 id="第一型曲面积分">第一型曲面积分</h1><h2 id="形式-2">形式</h2><p><span class="math inline">\(\iint_\limits{S}f(x,y,z)dS\)</span> --曲面质量</p><h2 id="方法-2">方法</h2><ol type="1"><li><p>化为二重积分</p><p>将曲面投影到某个坐标面，将<spanclass="math inline">\(\iint_\limits{S}\)</span>改成<spanclass="math inline">\(\iint_\limits{D}\)</span></p><p><span class="math inline">\(dS = \sqrt{1+z_x^2 +z_y^2}d\sigma\)</span></p></li></ol><h1 id="第二型曲面积分">第二型曲面积分</h1><h2 id="形式-3">形式</h2><p><span class="math inline">\(\iint_\limits{S} \vec{F}\cdot \vec{n}ds =\iint_\limits{S}Pcos\alpha + Qcos\beta + Rcos\gamma dS =\iint_\limits{S}Pdydz + Qdzdx + Rdxdy\)</span></p><p>-- 流量问题</p><h2 id="方法-3">方法</h2><ol type="1"><li>化为二重积分</li><li>分散投影</li><li>统一投影法</li></ol><p>​ <span class="math inline">\(\vec{n} = \left\{cos\alpha,cos\beta,cos\gamma\right\}=\pm \frac{1}{\sqrt{1+z_x^2 + z_y^2}}\left\{-z_x, -z_y, 1\right\}\)</span></p><p>​ <span class="math inline">\(dydz=\cos\alphadS=-z_x(x,y)dxdy\)</span></p><p>​ <span class="math inline">\(dzdx = \cos\beta dS =-z_y(x,y)dxdy\)</span></p><p>​ <span class="math inline">\(dxdy = \cos\gamma dS\)</span></p><ol start="4" type="1"><li>散度与旋度</li></ol><p>​ <span class="math inline">\(\nabla = \left\{\frac{\partial}{\partialx} ,\,\frac{\partial}{\partial y} ,\,\frac{\partial}{\partial z}\right\}\)</span></p><p>​ <span class="math inline">\(\nabla f(r) = \left\{\frac{\partialf(r)}{\partial x} ,\,\frac{\partial f(r)}{\partial y} ,\,\frac{\partialf(r)}{\partial z} \right\}\)</span> = <spanclass="math inline">\(f&#39;(r)\cdot \frac{1}{\sqrt{x^2 + y^2 + z^2}}\left\{x,y,z\right\}\)</span>=<spanclass="math inline">\(\frac{f&#39;(r)}{r} \vec{r}\)</span> （其中<spanclass="math inline">\(\vec{r} = \left\{x,y,z\right\}\)</span>）</p><p>​ 散度：<span class="math inline">\(div\, \vec{F} = P_x+Q_y+R_z=\nabla\cdot \vec {F}\)</span></p><p>​ 旋度：<span class="math inline">\(\overrightarrow{rot\,F}=\)</span><span class="math inline">\(\  \left|\begin{array}{cccc}     i&amp;    j    &amp; k \\     \frac{\partial}{\partial x}&amp;    \frac{\partial}{\partial y}   &amp; \frac{\partial}{\partialz}\\     P &amp; Q &amp; R  \end{array}\right|\)</span><spanclass="math inline">\(=\nabla \times \vec{F}\)</span></p><ol start="5" type="1"><li><p>Gauss公式</p><p>S应该是正向闭曲面</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405232047414.png" /></p></li><li><p>Stokes公式</p></li></ol><p>​ <span class="math inline">\(\oint_L \,\vec{F}\cdot d\vec{r} =\iint\limits_{s}(\nabla\times \vec{F})\cdot \vec{n}dS\)</span></p><p>​ <span class="math inline">\(\oint_L Pdx+Qdy+Rdz =\iint_\limits{S}\)</span> <spanclass="math inline">\(\  \left|\begin{array}{cccc}     dydz&amp;    dzdx    &amp; dxdy \\     \frac{\partial}{\partial x}&amp;    \frac{\partial}{\partial y}   &amp; \frac{\partial}{\partialz}\\     P &amp; Q &amp; R  \end{array}\right|\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分与曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绪论">绪论</h1><h2 id="概念">概念</h2><p><strong>数据</strong>：所有能输入到计算机中并被计算机程序加工、处理的符号的总称。如：整数、实数、字符、声音、图象、图形等。</p><p><strong>数据项</strong>：数据的不可分割的最小单位</p><p><strong>数据元素</strong>：数据的基本单位，一个数据元素可以由若干个数据项组成</p><p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集</p><p><strong>数据结构</strong>：相互之间存在一种或多种特定关系的数据元素的集合。</p><p><strong>结构</strong>：数据元素之间的关系称为结构。</p><p><strong>数据类型</strong>：是一个值的集合和定义在这个值上的一组操作的总称。</p><ol type="1"><li>原子类型(如：int,char,float等)</li><li>结构类型(如：数组,结构,联合体等）</li></ol><h2 id="抽象数据类型">抽象数据类型</h2><p><strong>抽象数据类型（ADT）</strong>：与计算机的实现无关的数据类型</p><p>形式定义：</p><p>ADT 抽象数据类型名 {</p><ol type="1"><li><p>数据对象</p></li><li><p>数据关系:一个或多个关系</p></li><li><p>基本操作：一组基本操作/运算</p></li></ol><p>} ADT 抽象数据类型名</p><p>其中数据对象和数据关系的定义用<strong>伪码</strong>描述，基本操作的定义格式为：</p><p>基本操作名（参数表）</p><p>​ 初始条件：<初始条件描述></p><p>​ 操作结果：<操作结果描述></p><p>参数表中有两种操作：</p><ol type="1"><li>赋值参数：只为操作提供输入值</li><li>引用参数：以&amp;打头，除可提供输入值外，还将返回操作结果</li></ol><h2 id="算法与算法分析">算法与算法分析</h2><p>算法的特征：</p><ol type="1"><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入：有0或多个输入量</li><li>输出：至少有一个输出量</li></ol><p>算法设计要求：</p><ol type="1"><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效与低存储量</li></ol><p>时间复杂度比较</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281632685.png" style="zoom: 50%;" /></p><h1 id="线性表">线性表</h1><h2 id="adt">ADT</h2><p>ADT List</p><p>{</p><p>数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n&gt;=0\right\}\)</span></p><p>数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span></p><p>基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitList</span>(&amp;L) <span class="comment">//构造空表L。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyList</span>(&amp;L) <span class="comment">//销毁线性表L</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearList</span>(&amp;L) <span class="comment">//置L为空表</span></span><br><span class="line"><span class="number">4.L</span>istEmpty(L) <span class="comment">//判断L是否为空表</span></span><br><span class="line"><span class="number">5.L</span>istLength(L) <span class="comment">//求表L的长度</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetElem</span>(L,i,&amp;e) <span class="comment">//取元素ai,由e返回ai</span></span><br><span class="line"><span class="number">7.L</span>ocateElem(L,e,<span class="built_in">compare</span>()) <span class="comment">//查找符合条件的元素</span></span><br><span class="line"><span class="number">8.L</span>istInsert(&amp;L,i,e) <span class="comment">//元素ai之前插入新元素e</span></span><br><span class="line"><span class="number">9.L</span>istDelete(&amp;L,i,&amp;e) <span class="comment">//删除第i个元素</span></span><br></pre></td></tr></table></figure><p>}ADT List</p><h2 id="顺序存储结构">顺序存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">    <span class="type">int</span> listsize;<span class="comment">//当前分配的存储容量</span></span><br><span class="line">&#125;Sqlist</span><br></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中的第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;<span class="comment">//i不合法</span></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt; L.listsize)<span class="comment">//当前存储空间已满，增加存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(L.elem,(L.listsize + ADD)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += ADD;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(l.elem[i - <span class="number">1</span>]);<span class="comment">//q是待插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; p--)</span><br><span class="line">    *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​ 设共有n个元素，在各个位置插入元素的概率相同，为<spanclass="math inline">\(p=\frac{1}{n +1}\)</span>，则插入一个元素时移动的平均值为<spanclass="math inline">\(\sum\limits_{i=1}^{n+1}p(n-i+1)=\frac{n}{2}\)</span></p><h3 id="删除操作">删除操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中删除第i个元素，并用e返回其值</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelte_Sq</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;<span class="comment">//如果i不合法</span></span><br><span class="line">    p = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = *p;</span><br><span class="line">    q = L.elem + L.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(++p; p &lt;= q; ++p)</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​ 设共有n个元素，在各个地方删除元素的概率为<spanclass="math inline">\(p=\frac{1}{n}\)</span>，则删除一个元素时移动元素的平均值为<spanclass="math inline">\(\sum\limits_{i=1}^{n}p(n-i) =\frac{n-1}{2}\)</span>​</p><h3 id="合并操作">合并操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线性表Lb中的且不再La中的元素合并到La中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(Sqlist&amp; La, Sqlist&amp; Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, i, e);<span class="comment">//从Lb中取第i个元素赋值给e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La, e, equal))</span><br><span class="line">        <span class="built_in">ListInsert</span>(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并并排序操作">合并并排序操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并非递减排序线性表La和Lb，得到Lc并且Lc按非递减排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(Sqlist La, Sqlist Lb, Sqlist&amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i = j = k = <span class="number">0</span>;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len &amp;&amp; j &lt;= Lb_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Getelem</span>(La, i, ai); <span class="built_in">Getelem</span>(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= La_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(La, i++, ai);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= Lb_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(Lb, j++, bj);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序结构存储的评价">顺序结构存储的评价</h3><ol type="1"><li>优点<ol type="1"><li>是一种随机存取结构，存取任何元素的时间是一个常数，速度快</li><li>结构简单，逻辑上相邻的元素，物理上也是相邻的</li><li>不使用指针，节省存储空间</li></ol></li><li>缺点<ol type="1"><li>插入和删除需要移动大量数据，消耗大量时间</li><li>需要一块连续的空间</li><li>插入元素时可能会“溢出”</li><li>自由区中的存储空间不能被其他数据占用（共享）</li></ol></li></ol><h2 id="链式存储结构">链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125;node, *Linklist;</span><br></pre></td></tr></table></figure><h3 id="建立单链表">建立单链表</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“先进先出”（尾插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, tail, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    tail = head;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“后进先出&quot;（头插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* create2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立递增有序链表">建立递增有序链表</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create3</span>(<span class="keyword">struct</span> node* head, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    q = <span class="literal">NULL</span>, p = head;<span class="comment">//扫描，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//空表</span></span><br><span class="line">            head = s;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//尾插</span></span><br><span class="line">            q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//头插</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        head = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//其他正常情况的插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create4</span><span class="params">(<span class="keyword">struct</span> node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">//可以直接插入，不讨论</span></span><br><span class="line">    q-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作-1">插入操作</h3><p>​ 伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在i之前插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在i之后插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-1">删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在带表头节点的链表中删除值为e的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete1</span><span class="params">(stuct node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* p, *q;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在单链表中删除指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete2</span><span class="params">(<span class="keyword">struct</span> node* head, <span class="type">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = head;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;<span class="comment">//q是待删除结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并操作-1">合并操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个带头节点的链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">Merge</span>(<span class="keyword">struct</span> node* La, <span class="keyword">struct</span> node* Lb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* pa, pb, pc;</span><br><span class="line">    pa = La-&gt;next, pb = Lb-&gt;next;</span><br><span class="line">    pc = La;</span><br><span class="line">    <span class="built_in">free</span>(Lb);<span class="comment">//释放Lb的头指针</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa) pc-&gt;next = pa;</span><br><span class="line">    <span class="keyword">else</span>  pc-&gt;next = pb; </span><br><span class="line">    <span class="keyword">return</span> La;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储结构评价">链式存储结构评价</h3><ol type="1"><li>优点：灵活地增加/插入，删除操作</li><li>缺点：使用显式顺序指针代替隐式的相邻存储的位置关系，增加了存储空间</li></ol><h2 id="循环链表">循环链表</h2><ol type="1"><li><p>一般形式</p><ol type="1"><li><p>带头结点的非空循环单链表，有：</p><p><code>head-&gt;next != head, head != NULL</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405291607660.png" /></p><ol type="1"><li><p>带表头结点的空循环单链表，有：</p><p><code>head-&gt;next == head, head != NULL</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048524.png" /></p></li><li><p>只有尾节点（带头）</p><ol type="1"><li><p>非空表，有：</p><p><code>tail-&gt;data ==an</code></p><p><code>tail-&gt;next指向表头结点</code></p><p><code>tail-&gt;next-&gt;next指向首节点</code></p><p><code>tail-&gt;next-&gt;next-&gt;data == a1</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048085.png" /></p><ol type="1"><li><p>空表，有：</p><p><code>tail-&gt;next == tail</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048479.png" /></p></li></ol><p>两循环链表首尾相连(时间复杂度<code>O(1)</code>)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048842.png" /></p><p>​ <code>p2 = tail2-&gt;next</code></p><p>​ <code>tail2-&gt;next = tail1-&gt;next</code></p><p>​ <code>tail1-&gt;next = p2-&gt;next</code></p><p>​ <code>free(p2)</code></p><h2 id="双向链表">双向链表</h2><ol type="1"><li><p>非空表</p><figure><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047040.png"alt="image-20240529163639637" /><figcaption aria-hidden="true">image-20240529163639637</figcaption></figure><p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p><p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p><p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == NULL</code></p></li><li><p>空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047672.png" /></p><p>​ <code>L-&gt;next == L-&gt;prior == NULL</code></p></li></ol><h2 id="双向循环链表">双向循环链表</h2><ol type="1"><li><p>非空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047950.png" /></p><p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p><p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p><p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == L</code></p></li><li><p>空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047389.png" /></p><p>​ <code>L-&gt;next == L-&gt;prior == L</code></p></li></ol><h2 id="各链表比较">各链表比较</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292049549.png" /></p><h1 id="栈">栈</h1><p>栈：限定在表尾做插入、删除的线性表 ---“后进先出”</p><h2 id="adt-1">ADT</h2><p>ADT Stack</p><p>{</p><p>​ 数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq0\right\}\)</span></p><p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<spanclass="math inline">\(a_n\)</span>端为栈顶端，<spanclass="math inline">\(a_1\)</span>端为栈底</p><p>​ 基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitStack</span>(&amp;S) <span class="comment">//构造一个空栈。 </span></span><br><span class="line"><span class="number">2.</span><span class="built_in">ClearStack</span>(&amp;S) <span class="comment">//置s为空栈。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">DestroyStack</span>(&amp;S) <span class="comment">//栈s被销毁</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">Push</span>(&amp;S,e) <span class="comment">//元素e进栈S。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">Pop</span>(&amp;S,&amp;e) <span class="comment">//删除栈S的顶元素，并送入e 。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetTop</span>(S,&amp;e) <span class="comment">//将非空栈S的栈顶元素拷贝到e（与（4）的Pop操作是不同的）。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">StackEmpty</span>(&amp;S) <span class="comment">//判断s是否为空栈。若s为空栈,则返回值为true；否则为false。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">StackLength</span>(S) <span class="comment">//栈S的长度</span></span><br></pre></td></tr></table></figure><p>}ADT Stack</p><h2 id="栈的输出特点">栈的输出特点</h2><p>一般地，输入序列<spanclass="math inline">\((...,a_i,...,a_j,...,a_k)\)</span>到栈中，不能得到<spanclass="math inline">\((...,a_k,...,a_i,...,a_j)\)</span>​</p><h2 id="栈的存储结构">栈的存储结构</h2><p>栈的范围为<code>s[0...maxlen- 1]</code></p><ol type="1"><li><p>顶指针指向栈顶元素所在的位置</p><p>栈顶元素：s[top]</p><p>进栈：先对top + 1，再将新数据指向top</p><p>出栈：先取栈顶元素，再对top - 1</p><p>空栈：<code>top == -1</code></p><p>非空栈：<code>top &gt;= 0</code></p><p>满栈：<code>top == maxlen - 1</code></p></li><li><p>顶指针指向顶元素上的一空位置</p><p>栈顶元素：s[top - 1]</p><p>进栈：先将新数据指向top，再对top + 1</p><p>出栈：先对top - 1，再取栈顶元素</p><p>空栈：<code>top == 0</code></p><p>非空栈：<code>top &gt;= 0</code></p><p>满栈：<code>top == maxlen</code></p></li></ol><p><strong><spanclass="math inline">\(\color{red}{顺序栈规定top指向栈元素上一空位置}\)</span>​</strong></p><h2 id="顺序栈">顺序栈</h2><p>存储表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>初始化栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base =(SElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SElemType)*STACK_INIT_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//内存分配失败</span></span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果内存不够</span></span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize) </span><br><span class="line">    &#123;</span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(S.base,(S.stacksize + STACK_INIT_SIZE)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINITSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    *(S.top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;<span class="comment">//如果栈为空</span></span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式栈">链式栈</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292207525.png" /></p><p>让top指向an，进栈将新节点作为首节点，出栈删除首节点，保证进出栈时间为常数</p><h2 id="栈的应用">栈的应用</h2><h3 id="数制转换">数制转换</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292226270.png" /></p><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,N);</span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, N % <span class="number">8</span>);</span><br><span class="line">        N /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号匹配">括号匹配</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292231643.png" /></p><h3 id="表达式求值">表达式求值</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292253188.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292254637.png" /></p><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OperandType <span class="title">EvaluateExpression</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR); <span class="built_in">Push</span>(OPTR, <span class="string">&#x27;#&#x27;</span>);<span class="comment">//初始化操作符的栈</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPND); c = <span class="built_in">getchar</span>();<span class="comment">//初始化操作数的栈</span></span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(c, OP))<span class="comment">//如果不是运算符就进栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(OPND, c);</span><br><span class="line">            c = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), c))<span class="comment">/*判断优先级*/</span></span><br><span class="line">             <span class="comment">/*栈顶优先级低*/</span></span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>&lt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Push(OPRT, c);</span></span><br><span class="line"><span class="string">            c = getchar();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">            /*脱括号并接收下一个字符*/</span></span><br><span class="line"><span class="string">            case&#x27;</span>=<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Pop(OPRT, x);</span></span><br><span class="line"><span class="string">            c = getchar();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">               /*退栈并将运算符结果入栈*/</span></span><br><span class="line"><span class="string">            case&#x27;</span>&gt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Pop(OPRT, theta);</span></span><br><span class="line"><span class="string">            Pop(OPND, b);</span></span><br><span class="line"><span class="string">            Pop(OPND, a);</span></span><br><span class="line"><span class="string">            Push(OPND, Operate(a, theta, b));</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return GetTop(OPND);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="队列">队列</h1><p>队列：只允许在表的一端插入一端删除的数据结构 ---“先进先出”</p><h2 id="adt-2">ADT</h2><p>ADT Queue</p><p>{</p><p>​ 数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq0\right\}\)</span></p><p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<spanclass="math inline">\(a_n\)</span>端为队列尾，<spanclass="math inline">\(a_1\)</span>端为队列头</p><p>​ 基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitQueue</span>(&amp;Q) <span class="comment">//初始化,构造空队列。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyQueue</span>(&amp;Q) <span class="comment">//销毁Q队列。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearQueue</span>(&amp;Q) <span class="comment">//置Q为空队列。</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">QueueEmpty</span>(Q) <span class="comment">//判断Q是否为空队列。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">EnQueue</span>(&amp;Q,e) <span class="comment">//将e插入队列Q的尾端。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">DeQueue</span>(&amp;Q,&amp;e) <span class="comment">//取走队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">GetHead</span>(Q,&amp;e) <span class="comment">//读取队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">QueueLengrh</span>(Q) <span class="comment">//返回队列长度</span></span><br></pre></td></tr></table></figure><p>}ADT Queue</p><h2 id="链式队列">链式队列</h2><p>用带头节点的单链表表示队列</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292334133.png" /></p><p>存储表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span>* next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>初始化队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349895.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349851.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;<span class="comment">//头插</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="comment">//如果是只有一个节点的情况</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><p><ahref="https://blog.csdn.net/qq_61959780/article/details/127332940?app_version=6.2.9&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127332940%22%2C%22source%22%3A%22luckyYY520%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">参考此篇blog</a></p><p>分辨队满&amp;队空</p><ol type="1"><li>rear指向的为空，留一个空位置<ol type="1"><li>队空：<code>q.rear == q.front</code></li><li>队满：<code>q.rear + 1 == q.front</code></li></ol></li><li>设置flag标志<ol type="1"><li>入队时如果<code>q.rear == q.front</code>，则队满，设置flag为true</li><li>出队时如果<code>q.rear == q.front</code>，则队空，设置flag为false</li></ol></li><li>记录length</li></ol><p>找到front, rear, length的关系</p><p><code>front = (rear + MAXSIZE - length) % MAXSIZE</code></p><h1 id="数组">数组</h1><h2 id="数组的递归定义">数组的递归定义</h2><ul><li><p>一维数组：<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>，其中<spanclass="math inline">\(a_i\)</span>为数据元素<spanclass="math inline">\(1\leq i\leq n\)</span></p></li><li><p>二维数组：<spanclass="math inline">\((\alpha_1,\alpha_2,...,\alpha_m)\)</span>，其中<spanclass="math inline">\(\alpha_i = (a_{i1},a_{i2},...,a_{in})\)</span>为行向量，<span class="math inline">\(1\leqi\leq m\)</span></p></li><li><p>三维数组：<spanclass="math inline">\((\beta_1,\beta_2,...,\beta_p)\)</span>，其中<spanclass="math inline">\(\beta_k=(\alpha_1,\alpha_2,...,\alpha_m)\)</span>，<spanclass="math inline">\(1\leq k\leq p\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301404268.png" /></p></li></ul><h2 id="数组的顺序表示">数组的顺序表示</h2><ol type="1"><li><p>以行序为主序的顺序存储方式</p><p><spanclass="math inline">\(\color{red}{左边的下标后变化，右边的下标先变化}\)</span></p></li><li><p>以列序为主序的顺序存储方式</p><p><spanclass="math inline">\(\color{red}{左边的下标先变化，右边的下标后变化}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301413278.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301415139.png" /></p></li></ol><h2 id="数组的映像函数">数组的映像函数</h2><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301418472.png" style="zoom: 67%;" /></p><ol type="1"><li><p>以行序为主序，<spanclass="math inline">\(a[i][j]\)</span>的地址为：</p><p><span class="math inline">\(Loc(i, j) = Loc(1, 1)+((i - 1)*n +(j -1))*s\)</span></p></li><li><p>以列序为主序，<spanclass="math inline">\(a[i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(i,j)=Loc(1,1)+((j-1)*m+(i-1))*s\)</span></p></li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301422772.png" style="zoom:67%;" /></p><ol type="1"><li><p>以行序为主序，<spanclass="math inline">\(a[k][i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((k-1)*m*n+(i-1)*m+(j-1))*s\)</span></p></li><li><p>以列序为主序，<spanclass="math inline">\(a[k][i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((j-1)*p*m+(i-1)*p+k-1)*s\)</span></p></li></ol><h2 id="矩阵的压缩存储">矩阵的压缩存储</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301905856.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301909749.png" /></p><p><span class="math inline">\(a_{ij}\)</span>在SA中的序号：</p><p><span class="math inline">\(k(i,j) =\)</span> <spanclass="math inline">\(\left\{\begin{aligned}i(i-1)/2 + j&amp; &amp;i\geq j\\ j(j-1)/2+i&amp; &amp;i&lt;j\end{aligned}\right.\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301916257.png" /></p><p>任意<span class="math inline">\(a_{ij}\neq0\)</span>，在SA中的序号：<spanclass="math inline">\(k=((i-1)*3-1)+(j-i+2)=2i+j-2\)</span></p><p><span class="math inline">\(A[i,j]=\)</span> <spanclass="math inline">\(\left\{\begin{aligned}k&amp; &amp;|i-j|\leq 1\\0&amp; &amp;其他\end{aligned}\right.\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301941684.jpg" /></p><h2 id="稀疏矩阵的存储">稀疏矩阵的存储</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405302304289.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;<span class="comment">//非零元的下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];<span class="comment">//非零元三元组表</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数和非零元的个数</span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"><span class="comment">//求稀疏矩阵的转置</span></span><br><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.mu = M.nu, T.nu = M.mu, T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span>(T.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt;= M.nu; col++) num[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t &lt;= M.tu; t++) ++num[M.data[t].j];</span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">2</span>;col &lt;= M.nu; ++col) cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= M.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j;</span><br><span class="line">            T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[p].e;</span><br><span class="line">            ++cpot[col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十字链接表">十字链接表</h2><p>[见此篇blog](<ahref="https://blog.csdn.net/qq_42185999/article/details/105083274">稀疏矩阵的十字链表存储表示和实现（第五章P104算法5.4）_用十字链表实现稀疏矩阵的存储,写出其创建和输出算法-CSDN博客</a></p><h1 id="广义表">广义表</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062335576.jpg" /></p><h1 id="二叉树">二叉树</h1><h2 id="二叉树的性质">二叉树的性质</h2><ol type="1"><li>二叉树第i层，最多有<spanclass="math inline">\(2^{i-1}\)</span>个结点</li><li>深度为k的二叉树，最多有<span class="math inline">\(2^k -1\)</span>个结点</li><li><span class="math inline">\(n_0=n_2+1\)</span></li><li>n个结点的满二叉树深度为<spanclass="math inline">\(log_2(n+1)\)</span></li><li>顺序编号的满二叉树<span class="math inline">\(1,2,...,n\)</span><ul><li>结点i的左孩子为2i，右孩子为2i+1</li><li>结点i的双亲为<span class="math inline">\(\lfloori/2\rfloor\)</span></li><li>结点i的层号<span class="math inline">\(\lfloorlog_2i\rfloor+1=\lceil log_2(n+1)\rceil\)</span>​</li></ul></li><li>n个结点可以组成<spanclass="math inline">\(\frac{(2n)!}{(n+1)!n!}\)</span>棵形态不同的二叉树</li></ol><h2 id="二叉树的存储">二叉树的存储</h2><h3 id="顺序存储">顺序存储</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323914.png" /></p><h3 id="链式存储">链式存储</h3><ol type="1"><li>二叉链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>三叉链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* parent;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>静态链表</li></ol><h2 id="二叉树的遍历">二叉树的遍历</h2><p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<spanclass="math inline">\(O(n)\)</span>​</p><blockquote><p>前序+中序 / 中序+后序可以唯一确定一个二叉树</p><p>前序+后序不能唯一确定一个二叉树(eg: 先序ABC 后序CBA)</p></blockquote><h3 id="先序遍历">先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历">中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历">后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历">非递归遍历</h3><p>中序遍历：</p><ol type="1"><li>第一次访问到根节点不访问，直接入栈</li><li>中序遍历左子树，左子树遍历结束之后，第二次遇到根节点，退栈进行访问，然后中序遍历右子树</li><li>退栈时栈为空结束</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><ol type="1"><li>沿着根的左孩子依次入栈，直到左孩子为空</li><li>如果没有右孩子，或者右孩子已经访问过，就访问该根节点</li><li>栈顶元素出栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree last;<span class="comment">//上一个访问的节点</span></span><br><span class="line">    BitTree st[maxlength];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        st[top++] = t;</span><br><span class="line">        t = t-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">BitTree tmp = st[--top];</span><br><span class="line">        <span class="keyword">if</span>((tmp-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; tmp-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">/*如果左右孩子均为空*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == last)<span class="comment">/*右孩子已经访问完*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == <span class="literal">NULL</span> &amp;&amp; tmp-&gt;lchild == last))<span class="comment">/*右孩子为空，左孩子访问了*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, tmp-&gt;data);<span class="comment">//访问</span></span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BitTree r = tmp-&gt;rchild;</span><br><span class="line">            <span class="keyword">while</span>(r)</span><br><span class="line">            &#123;</span><br><span class="line">                st[top++] = r;</span><br><span class="line">                r = r-&gt;l·child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><p>原理：使用队列进行存储，将根节点放入队列中，并且访问之后将该节点的左右孩子加入队列中</p><h2 id="创建二叉树">创建二叉树</h2><h3 id="递归法">递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == #) root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (BiTree)<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        root-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归法">非递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        q = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        q-&gt;data = e;</span><br><span class="line">        q-&gt;lchild = <span class="literal">NULL</span>, q-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        s[i] = q;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) root = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">2</span>) s[j]-&gt;rchild = q;</span><br><span class="line">            <span class="keyword">else</span> s[j]-&gt;lchild = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树">线索二叉树</h2><h3 id="概念-1">概念</h3><p>规则：</p><ol type="1"><li>若结点的左子树为空，则该结点的左孩子指向其前驱结点</li><li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li></ol><p>为了区别lchild/rchild是指向左右孩子还是前/后驱结点，添加标志位ltag,rtag：</p><ol type="1"><li><code>ltag == 0</code>，指向左孩子；<code>ltag == 1</code>，指向前驱结点</li><li><code>rtag == 0</code>，指向右孩子；<code>rtag == 1</code>，指向后继结点</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311434403.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311443551.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311444734.png" /></p><h3 id="线索化二叉树">线索化二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Thread</span>* lchild, rchild;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThreadTree</span><span class="params">(<span class="keyword">struct</span> Thread* node, <span class="keyword">struct</span> Thread* pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;lchild, pre);</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) node-&gt;ltag = <span class="number">0</span>;<span class="comment">//左孩子不是线索</span></span><br><span class="line">    <span class="keyword">else</span> node-&gt;ltag = <span class="number">1</span>, node-&gt;lchild = pre;</span><br><span class="line">    <span class="comment">//处理前驱结点</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) </span><br><span class="line">        pre-&gt;rchild = node, pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;rchild, pre);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历线索二叉树">遍历线索二叉树</h3><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span> *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//有左孩子</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有左孩子，指向右孩子或者后继结点</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span>* p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;<span class="comment">//找到最左边的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rchild)<span class="comment">//存在后继结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>) p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//找到最左边的结点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = p-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树和森林">树和森林</h1><h2 id="树的表示形式">树的表示形式</h2><ol type="1"><li>广义表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231516.png" />2. 嵌套集合</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231188.png" /></p><ol start="3" type="1"><li>凹入表/目录表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231758.png" /></p><h2 id="树的存储结构">树的存储结构</h2><ol type="1"><li>双亲表示法/数组表示法/顺序表示法</li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407567.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">snode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;t[maxlength + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>孩子表示法/链接表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407745.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408154.png" /></p><ol start="3" type="1"><li>孩子兄弟表示法/二叉树表示法/二叉链表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408655.png" /></p><ol start="4" type="1"><li>孩子链表表示法/单链表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408590.png" /></p><ol start="5" type="1"><li>带双亲的孩子链表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408034.png" /></p><h2 id="森林树和二叉树的转换">森林、树和二叉树的转换</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021424154.png" /></p><h2 id="树和森林的遍历">树和森林的遍历</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323277.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041324802.png" /></p><h2 id="哈夫曼树">哈夫曼树</h2><p>树T的路径长度：PL(T)从树T的跟到其余每个结点的路径长度之和</p><p>树的带权路径长度：WPL(T)每个叶子的权与根到该叶子的路径长度的乘积之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HTNode, *HuffmanCode;<span class="comment">//动态分配数组存储哈夫曼树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;<span class="comment">//存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode &amp;HC, <span class="type">int</span> *w, <span class="type">int</span> n)</span><span class="comment">/*w存放n个字符的权值*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HTNode) * (m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(p = HT + <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= n; i++, p++, w++)<span class="comment">//0号单元未用</span></span><br><span class="line">    *p = &#123;*w, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= m; i++, p++) *p = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);<span class="comment">//在HT[1,..,i-1]中选择parent为0且weight最小的两个结点，其序号分别是s1,s2</span></span><br><span class="line">        HT[s1].parent = i, HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1, HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight +HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从叶子到根逆向求每个字符的哈夫曼编码*/</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[i].parent)</span><br><span class="line">        <span class="keyword">if</span>(HT[f].lchild == c) cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        HC[i] = (<span class="type">char</span>*)<span class="built_in">mallov</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (n - start));<span class="comment">//为编码开辟空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="概念-2">概念</h2><p>强连通图：图G中每对结点都存在路径</p><p>强连通分量：图G'是图G的极大连通子图，G'是G的一个强连通分量</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002704.png" /></p><h2 id="图的存储结构">图的存储结构</h2><ol type="1"><li>邻接矩阵<ul><li>无向图中<span class="math inline">\(v_i\)</span> 的度<spanclass="math inline">\(TD=\sum\limits_{j=1}^{n}M[i][j]=\sum\limits_{i=1}^{n}M[i][j]\)</span></li><li>有向图中<span class="math inline">\(v_i\)</span> 的入度<spanclass="math inline">\(ID =\sum\limits_{i=1}^{n}M[i][j]\)</span>(每一列的和)，出度<spanclass="math inline">\(OD =\sum\limits_{j=1}^{n}M[i][j]\)</span>(每一行的和)</li></ul></li><li>邻接表/逆邻接表</li><li>十字链表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002846.png" /></p><ol start="4" type="1"><li><p>邻接多重表​</p><p><ahref="https://www.bilibili.com/video/BV1TL411b7V3/?spm_id_from=333.337.search-card.all.click">具体步骤见这个视频</a></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032019350.png" /></p></li></ol><p><strong>存储结构的优缺点</strong></p><p><strong>邻接矩阵</strong></p><p>优点：</p><ol type="1"><li>简单直观，好理解</li><li>便于计算一对顶点间是否有边，并且找到所有的邻接点</li><li>方便计算一个顶点的度</li></ol><p>缺点：</p><ol type="1"><li>不利于增加或者删除节点</li><li>存储稀疏图<spanclass="math inline">\((e&lt;nlogn)\)</span>较浪费空间</li><li>在统计边数等操作方面时间复杂度大</li></ol><p><strong>邻接表</strong></p><p>缺点：</p><ol type="1"><li>求节点度困难</li><li>每条边都要存两遍（无向图）</li></ol><h2 id="图的遍历">图的遍历</h2><p>DFS/BFS时间复杂度</p><ol type="1"><li>邻接矩阵存储<span class="math inline">\(O(n^2)\)</span></li><li>邻接表存储<span class="math inline">\(O(n+e)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038343.png" style="zoom: 67%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038662.png" style="zoom: 60%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032040296.png" style="zoom: 70%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032041338.png" style="zoom: 67%;" /></p><h2 id="最小生成树">最小生成树</h2><h3 id="prim">Prim</h3><p>时间复杂度：<spanclass="math inline">\(O(n^2)\)</span>，适合稠密图</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312202.jpg" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph G, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vertexNum; i++)<span class="comment">//遍历所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        shortEdge[i].lowcost = G.arc[start][i];<span class="comment">//初始化最短路的数组</span></span><br><span class="line">        shortEdge[i].adjvex = start;<span class="comment">//存储这个路径距离中这个节点的上一个节点  </span></span><br><span class="line">    &#125;</span><br><span class="line">    shortEdge[start].lowcost = <span class="number">0</span>;<span class="comment">//将start放入集合U</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vertexNum - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">minEdge</span>(shortEdge, G.vertexNum);<span class="comment">//寻找最短边的邻接点k</span></span><br><span class="line">        <span class="built_in">outputMST</span>(k, shortEdge[k]);<span class="comment">//输出最小生成树的路径</span></span><br><span class="line">        shortEdge[k].lowcast = <span class="number">0</span>;<span class="comment">//将k加入集合U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vertexNum; j++)<span class="comment">//调整shortEdge数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.arc[k][j] &lt; shortEdge[j].lowcast)</span><br><span class="line">            &#123;</span><br><span class="line">                shortEdge[j].lowcast = G.arc[k][j];</span><br><span class="line">                shortEdge[j].adjvex = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kruskal算法">Kruskal算法</h3><p>时间复杂度：<span class="math inline">\(O(eloge)\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312333.jpg" /></p><h2 id="拓扑排序">拓扑排序</h2><blockquote><p>有回路的有向图不存在拓扑排序</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312495.png" /></p><h2 id="aoe网">AOE网</h2><blockquote><p>先求点，再求边</p></blockquote><p>工程完成的最短时间是从开始点到完成点的最长路径长度，路径长度最长的路径叫做关键路径，关键路径上的点为关键点--开始时间等于结束时间</p><p><ahref="https://www.bilibili.com/video/BV1dy421a7S1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef5e5127819460e26182982933cfa21e">请参考这个视频</a></p><ol type="1"><li>ve(事件/节点的最早开始时间)，拓扑排序，每次选取<strong>入度</strong>为0的点，更新与之相邻的结点，ve是最长的那条路径长度</li><li>vl(事件/节点的最晚开始时间)，初始化所有结点的vl为终点的ve，<strong>逆</strong>拓扑排序，每次选取<strong>出度</strong>为0的点，更新与之相邻的结点，vl是选择使vl最小的那条路</li><li>e(活动/边的最早开始时间)，与发出这条边的结点的ve一致</li><li>l(活动/边的最晚开始时间)，用这条边指向的结点的vl减去这条边的边权</li></ol><h2 id="最短路径">最短路径</h2><h3 id="dijkstra算法">Dijkstra算法</h3><blockquote><p>解决单源最短路问题</p></blockquote><p><ahref="https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.999.0.0&amp;vd_source=ef5e5127819460e26182982933cfa21e">请参考这个视频</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//把起始点距离初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//用于找到当前距离起点最短的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新节点距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd算法">Floyd算法</h3><p><ahref="https://www.bilibili.com/video/BV19k4y1Q7Gj/?spm_id_from=333.788&amp;vd_source=ef5e5127819460e26182982933cfa21e">请参考这个视频</a></p><blockquote><p>求任意两个节点间的最短路径</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph G, PathMatrix&amp; p[], DistanceMatrix&amp; D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">        &#123;</span><br><span class="line">            D[v][w] = G.arcs[v][w];</span><br><span class="line">            <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                P[v][w][u] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(D[v][w] &lt; INFINITY)</span><br><span class="line">                &#123;</span><br><span class="line">                    P[v][w][v] = <span class="literal">true</span>;</span><br><span class="line">                    P[v][w][w] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(D[v][u] + D[u][w] &lt; D[v][w])</span><br><span class="line">                &#123;</span><br><span class="line">                    D[v][w] = D[v][u] + D[u][w];</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        P[v][w][i] = P[v][u][i] || P[u][w][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找">查找</h1><h2 id="静态查找表">静态查找表</h2><h3 id="顺序查找法">顺序查找法</h3><ol type="1"><li><p>不设置监视哨</p><p>判断条件：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">1</span> &amp;&amp; k != ST.elem[i].key)i--;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>设置监视哨</li></ol><p>​ <code>elem[0].key = k;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(k != ST.elem[i].key)i--;</span><br></pre></td></tr></table></figure><p>ASL成功 = (n + 1) / 2</p><p>ASL失败：使用监视哨 = n + 1, 不使用监视哨 = n</p><h3 id="折半查找法">折半查找法</h3><p>相当于二分查找</p><h3 id="判定树">判定树</h3><p>描述折半查找过程的二叉树(从1开始，放的是序号不是值)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051340541.png" /></p><p>若判定树为满二叉树：<span class="math inline">\(ASL =\frac{n+1}{n}log2(n + 1) - 1\)</span></p><p>证明：<imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051338386.jpg" /></p><h2 id="动态查找表">动态查找表</h2><h3id="二叉排序树二叉查找树"><strong>二叉排序树（二叉查找树）</strong></h3><p>特点：如果二叉树的任一结点大于其非空左子树的所有结点，而小于其非空右子树的所有结点，则这棵二叉树称为二叉排序树。<strong><spanclass="math inline">\({\color{red}(左小右大)}\)</span>​​</strong></p><p>平均ASL= O(logn)</p><h4id="删除二叉排序树中的结点"><strong><em>删除二叉排序树中的结点</em></strong></h4><p>设被删除的结点为*p，其双亲结点为*f，*s为*p的前驱结点，*p是*f的左孩子，有三种情况：</p><ol type="1"><li><p>*p为叶子结点：直接删除</p></li><li><p>*p只有左孩子PL或者右孩子PR：让PL/PR为*f的左孩子</p></li><li><p>*p的左孩子PL和右孩子PR均不为空：</p><ol type="1"><li><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071134367.png" /></p></li><li><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071135262.png" /></p></li></ol></li></ol><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是待删除的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果左子树为空，或者为叶子结点</span></span><br><span class="line">    &#123; q = p; p = p-&gt;rchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//如果右子树为空</span></span><br><span class="line">    &#123; q = p; p = p-&gt;lchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果左右子树均不为空 以方法二为例</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;<span class="comment">//设置s的双亲结点是q</span></span><br><span class="line">            s = s-&gt;rchild;<span class="comment">//遍历直到找到p的前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;<span class="comment">//将p替换成s</span></span><br><span class="line">        <span class="comment">//要判断是因为如果删除结点的左子树有右子树那么中序遍历的前驱结点是右孩子，否则前驱结点是左孩子，就会导致移动的不同</span></span><br><span class="line">        <span class="keyword">if</span>(p != q)<span class="comment">//表明删除节点的左子树有右子树</span></span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;<span class="comment">//不需要free因为原来的s占的是q-&gt;left，现在已经被替换了</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树avl树"><strong>平衡二叉树</strong>(<spanclass="math inline">\(AVL\)</span>树)</h3><ol type="1"><li>结点的平衡因子：结点的左右子树深度之差（左子树高度-右子树高度）</li><li>平衡二叉树：任意结点平衡因子的绝对值小于等于1的二叉树</li></ol><h4id="高度一定的avl树所含最小节点个数">高度一定的AVL树所含最小节点个数</h4><p>S(h)表示深度为h的平衡二叉树所含有的最少节点个数</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051555220.png" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051556641.png" style="zoom: 67%;" /></p><h4id="构造平衡二叉搜索树的方法"><strong><em>构造平衡二叉搜索树的方法</em></strong></h4><ul><li><p>左旋：向作左旋转，冲突的左孩变右孩</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081654715.png" /></p></li><li><p>右旋：向右旋转，冲突的右孩变左孩</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081656759.png" /></p></li><li><p><span class="math inline">\(LL\)</span>型，<spanclass="math inline">\(RR\)</span>型，<spanclass="math inline">\(LR\)</span>型，<spanclass="math inline">\(RL\)</span>​型</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081714341.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081716342.png" /></p><ul><li><span class="math inline">\(LL\)</span>型：右旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715912.png" /></p><ul><li><span class="math inline">\(RR\)</span>​型：左旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081849686.png" /></p><ul><li><span class="math inline">\(LR\)</span>​型：先左旋左孩子，再右旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715436.png" /></p><ul><li><span class="math inline">\(RL\)</span>​型：先右旋右孩子，再左旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715357.png" /></p></li><li><p>插入结点时平衡失调，调整离删除结点最近的失衡结点即可</p><p>删除结点时平衡失调，依次对每个祖先进行检查和调整</p></li></ul><h3 id="哈希表">哈希表</h3><h4 id="构造哈希函数的方法"><em>构造哈希函数的方法</em></h4><ol type="1"><li><p>直接定址法：取关键字或者关键字的某个线性函数值作为哈希地址</p></li><li><p>除留余数法：设哈希表HT[0,1,..,m-1]的表长为m，哈希地址为key除以p所得余数（p为接近m的素数或为不包含20以内质因数的合数）</p></li><li><p>平方取中法：取关键字平方后的中间某几位为哈希地址</p></li><li><p>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址</p><ol type="1"><li><p>边界折叠法：<span class="math inline">\(eg: k1 =056439527\)</span>对应的地址为<spanclass="math inline">\(650+439+725\)</span></p></li><li><p>移位折叠法：<span class="math inline">\(eg: k1 =056439527\)</span>对应的地址为</p><p><span class="math inline">\(056+439+527\)</span></p></li></ol></li><li><p>数字分析法：如果哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干分布均匀的位组成哈希地址</p></li><li><p>随机数法：利用<spanclass="math inline">\(random(key)\)</span>​</p></li></ol><h4 id="解决哈希冲突的方法"><em>解决哈希冲突的方法</em></h4><ol type="1"><li>开放地址法<ol type="1"><li>线性嗅探再散列</li><li>二次嗅探再散列</li></ol></li><li>链地址法</li><li>建立公共溢出区</li><li>再哈希法</li></ol><h4 id="哈希化的效率"><strong><em>哈希化的效率</em></strong></h4><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405132118931.png" /></p><h4id="哈希表的平均查找长度"><strong><em>哈希表的平均查找长度</em></strong></h4><p><ahref="%5B哈希表：线性探测法和链地址法求查找成功与不成功的平均查找长度_链地址法查找失败的平均查找长度怎么算-CSDN博客%5D(https://blog.csdn.net/KD35KD/article/details/107054474)">见此篇BLOG</a></p><p>散列表</p><p>查找成功的概率：</p><ul><li>分母：所有待插入的元素的个数</li><li>分子：每个位置元素出现的个数</li></ul><p>查找失败的概率：</p><ul><li>分母：mod的大小</li><li>分子：从0-m-1的每一个位置到下一个空位置需要查找的个数</li></ul><h1 id="排序">排序</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406052033580.png" /></p><h2id="插入排序朴素版--稳定排序-折半版--不稳定">插入排序（朴素版--稳定排序折半版--不稳定）</h2><blockquote><p>第n趟排序，保证前n + 1个元素有序</p></blockquote><p>操作：将新的元素插入到已排序的数组中</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span>​</p><ul><li><p>最好的情况：原n个记录递增有序</p><p>比较关键字次数：<span class="math inline">\(n-1\)</span>次</p><p>移动记录次数：<spanclass="math inline">\(2(n-1)\)</span>次（将数据复制到a[0]又复制回来）</p></li><li><p>最坏的情况：原n个记录递减有序</p><p>比较关键字次数：<span class="math inline">\(\sum_\limits{i = 2}^n i =2+3+...+n = \frac{(n-1)(n+2)}{2}\)</span></p><p>移动记录次数：<span class="math inline">\(\sum_\limits{i=2}^{n}(i-1+2)=3+4+...+n=\frac{(n-1)(n+4)}{2}\)</span></p><p>（+2是因为监视哨，先复制一遍，再加到合适的位置）</p></li></ul><p>朴素版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序 </span></span><br><span class="line"><span class="comment">//对1-n进行排序(n表示的是数组的最后一个元素的下标，不是元素个数) </span></span><br><span class="line"><span class="comment">//在a[0]设置监视哨</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">cur = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[cur];</span><br><span class="line">cur--;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半插入排序（不稳定）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="comment">//优化了比较次数，但是只有当n很大时使用折半插入效率更高</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>, m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)<span class="comment">//利用二分法折半查找</span></span><br><span class="line">&#123;</span><br><span class="line">m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[m])high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在high左边</span></span><br><span class="line"><span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在low的右边</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//high + 1即是待插入的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[high + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二路插入排序：</p><p>优点：可以减少移动的次数</p><p>操作：（排序长度为n的序列）相当于先开辟长度为n的数组，将该数组当做一个循环的空间，进行插入。</p><p>表插入排序：</p><h2 id="希尔排序colorred-不稳定排序">希尔排序<spanclass="math inline">\(\color{red} {（不稳定排序）}\)</span>​</h2><blockquote><p>第n趟排序后，能找到n个gap使元素每隔gap个元素就有序</p></blockquote><p>操作：每次排序相隔gap的元素，不断缩小gap，直至gap ==1，排序后退出循环</p><p>时间复杂度：<span class="math inline">\(O(n ^{1.3})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--希尔排序  O(n^1.3)</span></span><br><span class="line"><span class="comment">//1. gap &gt; 1 预排序</span></span><br><span class="line"><span class="comment">//2. gap == 1 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> gap, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> cur = i - gap;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + gap] = a[cur];</span><br><span class="line">cur -= gap;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + gap] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后记录位置的增量为dk</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellInsert</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = dk + <span class="number">1</span>; i &lt;= L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">LT</span>(L.r[i].key, L.r[i - dk].key))<span class="comment">//将L.r[i]插入有序增量子表</span></span><br><span class="line">         &#123;</span><br><span class="line">             L.r[<span class="number">0</span>] = L.r[i];<span class="comment">//暂存在L.r[0]中，不是哨兵位</span></span><br><span class="line">             <span class="keyword">for</span>(j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">LT</span>(L.r[j].key, L.r[<span class="number">0</span>].key)); j -= dk)</span><br><span class="line">             &#123;</span><br><span class="line">                 L.r[j + dk] = L.r[j];</span><br><span class="line">             &#125;</span><br><span class="line">             L.r[j + dk] = L.r[<span class="number">0</span>];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> delta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, delta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序colorred不稳定排序">快速排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>第n趟排序之后，有n个元素在它应该在的位置上</p></blockquote><p>操作：随机在数组中找一个数，利用递归，让左边的数都小于该数，右边的数都大于该数</p><ul><li>时间复杂度：<spanclass="math inline">\(O(nlogn)\)</span>，最坏的情况下（序列基本有序）时间复杂度为<spanclass="math inline">\(O(n^2)\)</span></li><li>空间复杂度：快排需要一个栈做辅助空间，平均情况下需要<spanclass="math inline">\(O(nlogn)\)</span>的空间，最坏的情况下，要递归n次，需要<spanclass="math inline">\(O(n)\)</span>的空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, left, right);<span class="comment">//找到在left，mid，right三个下标下大小是中间的那个的下标</span></span><br><span class="line"><span class="built_in">Swap</span>(a + keyi, a + left);</span><br><span class="line"><span class="comment">//左边当key 右边先走 ；右边当key 左边先走</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Swap</span>(a + left, a + right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(a + left, a + keyi);</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> part = <span class="built_in">PartSort</span>(a, begin, end);</span><br><span class="line"><span class="built_in">QuickSort</span> (part + <span class="number">1</span>, end);</span><br><span class="line"><span class="built_in">QuickSort</span>(begin, part - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.r[<span class="number">0</span>] = L.r[low];<span class="comment">//选最左边为pivotkey</span></span><br><span class="line">    pivotkey = L.r[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)</span><br><span class="line">           high--;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">pivotloc = <span class="built_in">partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">Qsort</span>(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三路划分的优化快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortThree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, begin, end);</span><br><span class="line"><span class="built_in">Swap</span>(a + keyi, a + begin);</span><br><span class="line"><span class="type">int</span> left = begin, right = end, cur = begin + <span class="number">1</span>, key = a[begin];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[cur] &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + cur, a + left);</span><br><span class="line">++cur, ++left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[cur] == key)</span><br><span class="line">&#123;</span><br><span class="line">++cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + cur, a + right);</span><br><span class="line">--right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">QuickSortThree</span>(a, begin,left - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSortThree</span>(a, right + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序colorred不稳定排序">选择排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>排序n趟之后，前n个元素应该是整个序列中最小的n个元素，并且顺序排列</p></blockquote><p>操作：每次选择未选择序列中最小的（最大的），放在已经排序的序列之后时间复杂度：</p><ul><li>比较次数：<spanclass="math inline">\(\frac{n(n-1)}{2}\)</span>即<spanclass="math inline">\(O(n^2)\)</span>​</li><li>移动次数：<ul><li>最好的情况，一开始就是升序，不需要移动</li><li>最坏的情况：每次都需要移动（不是降序的时候），交换记录数为n-1对，移动记录数为3(n-1)（因为swap里面有三条语句）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mini = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[mini]) mini = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[mini], &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序colorred不稳定排序">堆排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>排序n趟之后，数组的最后n个元素应该是最大且有序的</p></blockquote><p>对n较大的文件有效</p><p>操作：升序建大堆，降序建小堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">++child;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> child)</span><span class="comment">//造大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">AdjustUp</span>(a, i);</span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a, a + end);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, end , <span class="number">0</span>);</span><br><span class="line"><span class="comment">//因为end是交换过去的最后一个 所以循环应该到这个就结束 不应该传end+1</span></span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Sqlist HeapType;</span><br><span class="line"><span class="comment">//H[s...m]中除了H.r[s].key其他都满足堆的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType&amp; H, <span class="type">int</span> s, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rc = H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; <span class="built_in">LT</span>(H.r[j].key, H.r[j + <span class="number">1</span>].key)) j++;</span><br><span class="line">        <span class="keyword">if</span>(!(rc.key, H.r[j].key)) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s] = H.r[j]; s = j;<span class="comment">//向下遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType&amp; H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = H.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    <span class="keyword">for</span>(i = H.length; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        H.r[i]&lt;--&gt;H.r[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序稳定排序">归并排序（稳定排序）</h2><blockquote><p>第1趟排序之后，从开始起相邻两个元素为升序排列；第二趟排序之后，相邻4个元素为升序排列……第n趟排序之后，相邻<spanclass="math inline">\(2^n\)</span>个元素为升序排列</p></blockquote><p>操作：将它们划分为长度均为1的子序列，然后逐步二路归并</p><p>时间复杂度：</p><ul><li>对n个记录的文件进行归并排序，共需要<spanclass="math inline">\(log_2n\)</span>趟，每趟所需要比较的关键字次数不超过n，所以总比较次数为<spanclass="math inline">\(O(nlogn)\)</span></li><li>每趟移动n个记录，移动次数为<spanclass="math inline">\(O(nlogn)\)</span></li><li>归并排序需要一个大小为n的辅助空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin == end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">MergeSort</span>(a, begin, mid, tmp);</span><br><span class="line"><span class="built_in">MergeSort</span>(a, mid + <span class="number">1</span>, end, tmp);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = begin, end1 = mid;</span><br><span class="line"><span class="type">int</span> begin2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"><span class="type">int</span> i = begin;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line"><span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType&amp; TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将有序的SR[i...m]和SR[m + 1...n]归并为有序的TR[i...n]</span></span><br><span class="line">    <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">LQ</span>(SR[i].key, SR[j].key)) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= m) TR[k...n] = SR[i...m];</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= n) TR[k...n] = SR[j...n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MSort</span><span class="params">(RcdType SR[], ScdType&amp; TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将SR[s...t]归并为TR1[s...t]</span></span><br><span class="line">    <span class="keyword">if</span>(s == t) TR1[s] = SR[s];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (s + t)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Msort</span>(SR, TR2, s, m);</span><br><span class="line">        <span class="built_in">Msort</span>(SR, TR2, m + <span class="number">1</span>, t);</span><br><span class="line">        <span class="built_in">Merge</span>(TR2, TR1, s, m, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(Sqlist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Msort</span>(L.r, L.r, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序稳定排序">基数排序（稳定排序）</h2><p>操作：</p><ul><li>MSD：高位有效优先</li><li>LSD：低位有效优先</li></ul><p>MSD对应数字排序：下面以个位为例</p><p>数组形式：</p><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281546971.mp4" width="100%" height="100%" controls="controls"></video><p>队列形式：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936416.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936776.png" /></p><p>时间复杂度：设数字的有效位数为d</p><ul><li>需要d趟回收分配，每趟分配运算时间为<spanclass="math inline">\(O(n)\)</span></li><li>收集：基数为rd,即rd个队列。从rd个队列中收集，运算时间O(rd)</li><li>一趟分配、回收运算时间O(n+rd), 时间复杂度O(d*(n+rd))</li><li>辅助空间：每个队列首尾2个指针，共2rd个指针；n个记录需要n个指针域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/05/07/%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/07/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法基础">算法基础</h1><h2 id="读入优化">读入优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="离散化">离散化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//unique会将不重复的元素放在前面，重复的元素放在后面，并且返回第一个不重复元素的位置</span></span><br></pre></td></tr></table></figure><h2 id="stl">STL</h2><h3 id="vector">vector</h3><p>操作：</p><ul><li>push_back()</li><li>pop_back()</li><li>size()</li><li>clear()</li><li>insert()</li><li>erase()<ul><li>erase(_position) --删除某个元素</li><li>erase(position_start, position_end)--删除区间<spanclass="math inline">\([position\_start,position\_end)\)</span>内的元素</li></ul></li></ul><h3 id="set">set</h3><p>特点：</p><ol type="1"><li>set的含义是集合，所有操作都在<spanclass="math inline">\(O(logn)\)</span>的时间复杂度内完成</li><li>set插入的元素不能相同</li><li>所有元素会根据值排序（默认是从小到大）</li><li>set中元素的值不能被直接修改</li><li>set不支持下标访问操作，只支持迭代器</li><li>模版：set<type> s;</li></ol><p>操作：</p><ul><li>begin()--返回指向第一个元素的迭代器</li><li>end()--返回指向最后一个元素的迭代器</li><li>clear()<br /></li><li>empty() --如果集合为空，返回true，否则返回false</li><li>erase()</li><li>count()<br /></li><li>find(k)</li><li>insert()</li><li>lower_bound(k) -- 返回一个迭代器，指向键值大于等于k的第一个元素</li><li>upper_bound(k) --返回一个迭代器，指向键值大于k的第一个元素</li><li>size()</li></ul><h3 id="queue">queue</h3><p>操作：</p><ul><li>模板：queue&lt;数据类型，容器类型&gt; q</li><li>push()</li><li>pop()</li><li>size()</li><li>front()--返回队首</li><li>back()--返回队尾</li><li>empty()</li></ul><h3 id="priority_queue">priority_queue</h3><p>特点：</p><ol type="1"><li>包含头文件<span class="math inline">\(\verb|#include&lt;queue&gt;|\)</span>​</li><li>默认从大到小排序（less 从大到小，greater 从小到大）</li></ol><p>操作：</p><ul><li>push()</li><li>pop()</li><li>empty()</li><li>top()</li><li>size()</li></ul><h3 id="map">map</h3><p>特点：</p><ol type="1"><li><p>使用头文件<span class="math inline">\(\verb|#include&lt;map&gt;|\)</span></p></li><li><p>具有唯一键值对</p></li><li><p>模版：map&lt;key_type, value_type&gt;变量名</p></li><li><p>可以保证元素的有序性，默认按照键（key）从小到大排序</p><p>如果想从大到小排序：<span class="math inline">\(\verb|map&lt;string,int, greater&lt;string&gt; &gt; m;|\)</span></p></li></ol><p>操作：</p><ul><li>size()</li><li>count()</li><li>empty()</li><li>erase()</li><li>clear()</li><li>find()</li><li>insert()</li><li>begin()</li><li>end()</li><li>lower_bound()</li><li>upper_bound()</li></ul><h3 id="unordered_map">unordered_map</h3><p>特点：</p><ol type="1"><li>快速查找特定元素</li><li>存储时元素是无序的</li><li>头文件<span class="math inline">\(\verb|#include&lt;unordered_map&gt;|\)</span></li></ol><p>操作：</p><ul><li>插入：insert({key, value})/map[key] = value</li><li>删除：clear()/erase()</li><li>迭代器：begin()/end()</li><li>元素个数：size()/count()</li></ul><h3 id="pair">pair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; a;</span><br><span class="line"><span class="type">int</span> l = a[<span class="number">0</span>].first, <span class="type">int</span> r = a[<span class="number">0</span>].second;<span class="comment">//注意！！！是first和second </span></span><br></pre></td></tr></table></figure><h2 id="二分查找">二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到不小于k的最小的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dic_left</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到不大于k的最大的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dic_right</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; k) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和">前缀和</h2><p><strong>一维前缀和：</strong></p><p><code>s[i] = s[i - 1] + a[i]</code></p><p>数列a中任意<span class="math inline">\(\text\ [l,r]\)</span>的和为<code>s[r] - s[l - 1]</code></p><p><strong>二维前缀和：</strong></p><p><code>s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]</code></p><p>求以<span class="math inline">\(\text\ (x1,y1)\)</span>为左上角，<span class="math inline">\(\text\ (x2,y2)\)</span>为右下角的子矩阵元素和<code>s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p><h2 id="差分">差分</h2><blockquote><p>差分序列的前缀和序列就是原序列，利用差分数组将“区间操作”变成“单点操作”</p></blockquote><p><strong>一维差分数组：</strong></p><p><code>dp[i] = a[i] - a[i - 1]</code></p><p>把a数组的[l,r]上的每个数加上c，则<code>dp[l] += c, dp[r + 1] -= c;</code></p><p>对差分数组求前缀和<code>a[i] = dp[i] + a[i - 1]</code></p><p><strong>二维差分数组：</strong></p><p><code>dp[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]</code></p><p>把矩阵中左上角为<span class="math inline">\(\text\a[x1][y1]\)</span>右下角为<span class="math inline">\(\text\a[x2][y2]\)</span>的小矩形中每个元素加上c，则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[x1][y1] += c;</span><br><span class="line">dp[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">dp[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">dp[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure><p>对差分矩阵求前缀和得原矩阵</p><p>即<code>a[i][j] = dp[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]</code></p><h2 id="位运算">位运算</h2><h3 id="二进制状态压缩">二进制状态压缩</h3><figure class="highlight plaintext"><figcaption><span>&</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406301623301.png)</span><br><span class="line"></span><br><span class="line">### 位运算交换两数</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void swap(int&amp; a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lowbit运算">lowbit运算</h3><p>lowbit(n)运算表示非负整数n在二进制表示下“最低位的1和其后所有的0”所构成的数值<code>lowbit(n) = n &amp; (~n + 1) = n &amp; (-n)</code></p><h1 id="数据结构">数据结构</h1><h2 id="单调栈">单调栈</h2><p>寻找某个数左边第一个小于它的数</p><blockquote><p>维护一个栈，栈顶元素即是当前准备入栈元素的左边第一个小于它的数</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031233091.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> st[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; st[tt] &gt;= x) tt--;<span class="comment">//如果栈不为空，并且栈顶元素比当前元素大，就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(!tt) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st[++tt] = x;<span class="comment">//当前元素入栈，先++，保证tt==0的时候栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><blockquote><p>滑动窗口：找区间最大值和最小值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N], a[N];<span class="comment">//q是队列，a是存储数据的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断需不需要让窗口往后移</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为是找最小值，所以如果新出现的元素比左边的元素小，那么在窗口右移的过程中，左边的那个更大的元素必定用不到，所以删去</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//将新元素加进队列</span></span><br><span class="line">        <span class="comment">//整个队列单调增，所以hh位置元素最小</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前队列中的元素个数大于k，需要队首出队</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为找最大值，所以如果新出现元素更大，同上，删去左边的元素</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//在队列里面存下标</span></span><br><span class="line">        <span class="comment">//整个队列单调减，hh位置元素最大</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论">图论</h1><h2 id="最短路问题">最短路问题</h2><h3 id="dijkstra算法">Dijkstra算法</h3><p><strong><spanclass="math inline">\(\color{blue}（不能存在负权边）\)</span></strong></p><ul><li>朴素版本 ：时间复杂度 <spanclass="math inline">\(O(n^2)\)</span>，适合稠密图（利用邻接矩阵存储）<ol type="1"><li>将起点距离初始化为0，其他点的初始距离设置为无穷</li><li>每次找到距离起点距离最近的节点，将该点做标记，表示已经设置过</li><li>更新与该点有关的结点的距离</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//循环n-1次（除了开始的结点），每次都找到到某一个点的最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//寻找当前还未找的结点距离起点的最短路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">            <span class="comment">//找到一个距离起点更小的未被标记过的结点，就让t等于那个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//设置标记表示已经找到最小距离了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新与该结点有关结点的最小距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;<span class="comment">//n个结点m条边</span></span><br><span class="line">    <span class="built_in">memset</span>(g,  <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//初始化距离为无穷大</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);<span class="comment">//利用邻接矩阵进行存储，因为有重边所以取min</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用堆排序优化：时间复杂度<spanclass="math inline">\(O(mlogn)\)</span>，适合稀疏图（利用邻接表存储）<spanclass="math inline">\({\color{red}(除了找最小距离的时候利用堆优化，其他与朴素算法一致)}\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], w[N],idx;<span class="comment">//利用链式前向星存储</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//一个用来存距离，一个用来存结点</span></span><br><span class="line"><span class="comment">//只能将距离存在前面，因为要根据距离排序</span></span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><span class="comment">//存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = z;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII q = heap.<span class="built_in">top</span>();<span class="comment">//取堆顶元素</span></span><br><span class="line">        <span class="type">int</span> a = q.second, b = q.first;<span class="comment">//a是路径的尾节点，b是这条路径的长度</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();<span class="comment">//删除刚刚用过的堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(st[a]) <span class="keyword">continue</span>;</span><br><span class="line">        st[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[a]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[a] + w[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[a] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijsktra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellmanford算法">BellmanFord算法</h3><p>求出从 1号点到 n号点的最多经过 k 条边的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], cpy[N];<span class="comment">//一个同来记录最短距离，一个同来当做临时拷贝，防止出现连续更新的情况，因为该算法要保证循环k次只能走k条边，所以每次只能更新一条边的距离，如果只有一个dist就会出现，先用a更新b，再用b更新c的情况，导致循环k次只能走k条边条件不满足。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//设置初始距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cpy, dist, <span class="keyword">sizeof</span> dist);<span class="comment">//拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], cpy[e.a] + e.w);<span class="comment">//用上一次循环的距离cpy更新这一次的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        edges[i].a = x, edges[i].b = y, edges[i].w = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BellmanFord</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//因为可能存在负边所以是0x3f3f3f3f / 2</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa算法">Spfa算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//建立队列，保证每次更新的前一个结点是更新的</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//出队列 队列中无该结点 设置为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序">拓扑排序</h2><p>每次找到度为0的节点加入到最终的序列中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[tt++] = i;<span class="comment">//先找到一开始度为0的结点</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];<span class="comment">//删除t结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//更改与t结点有关的边的度数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[tt++] = j;<span class="comment">//如果度为0就加入序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        d[y]++;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">    &#125;<span class="comment">//存图</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopSort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论">数论</h1><h2 id="质数">质数</h2><h3 id="试除法判断质数">试除法判断质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a/ i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s++;</span><br><span class="line">                    a /= i;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//如果有一个比较大的因子，就输出</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法求质数">筛法求质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;<span class="comment">//如果未被标记过说明是质数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回质数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数">约数</h2><h3 id="试除法求约数">试除法求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;  cin &gt;&gt; a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//用来存储a的所有约数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(a / i != i) res.<span class="built_in">push_back</span>(a / i);<span class="comment">//保证不重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : res)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数个数为<spanclass="math inline">\((x_1+1)(x_2+1)...(x_k+1)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> +<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[i]++;</span><br><span class="line">                a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;<span class="number">1</span>) mp[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y] : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ret * (y + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ret % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数之和为<spanclass="math inline">\((    p_1^0+p_1^1+..._+p_1^{x_1})\times...\times(p_k^0+p_k^1+...+p_k^{x_k})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//存储质因数对应的个数</span></span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y]: mp)</span><br><span class="line">&#123;</span><br><span class="line">    ll t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y--)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (t * x + <span class="number">1</span>) % mod;<span class="comment">//得到每个质因子对应的加和值</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = res * t % mod;<span class="comment">//将所有质因子的加和值乘起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><h2 id="背包问题">背包问题</h2><p><ahref="https://blog.csdn.net/raelum/article/details/128996521">参考大佬的代码</a></p><h3 id="背包问题-1">01背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/28/hello-world/"/>
      <url>/2024/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405241310482.png" /></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
