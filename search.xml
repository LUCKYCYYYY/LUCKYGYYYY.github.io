<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Codeforces_976_Div2</title>
      <link href="/2024/10/03/Codeforces-976-Div2/"/>
      <url>/2024/10/03/Codeforces-976-Div2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="a.-find-minimum-operations">A. Find Minimum Operations</h1><p>输入n，k，不断用<span class="math inline">\(n-k^x\)</span>代替<spanclass="math inline">\(n\)</span>，直到n等于0，问最少要多少步</p><blockquote><p>快速幂计算，注意如果k=1，直接加上n，节省时间</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * c;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">c = c * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;i == <span class="number">0</span> || a[i - <span class="number">1</span>] &lt;= n; i++) a[i] = <span class="built_in">qmi</span>(k, i);</span><br><span class="line"><span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; n &gt; <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">step += n;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a[j] &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">n -= a[j];</span><br><span class="line">step++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; step &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="b.-brightness-begins">B. Brightness Begins</h1><p>输入k，假设一开始有n盏灯，全部是开的状态，即<spanclass="math inline">\(a[i]=1,1\leq i\leq n\)</span>，从<spanclass="math inline">\(1\sim n\)</span>进行遍历，如果<spanclass="math inline">\(a[i]\)</span>可以被i整除，就改变状态（开边关，关变开），要求输出n，保证n中有k盏灯亮着</p><blockquote><p>我们不难发现，</p><ol type="1"><li>如果i是素数，那么i只能被1和i整除，那么最后的状态一定是开</li><li>如果i的因子个数为偶数，那么最后的状态也是开</li></ol><p>也就是说，除了i的因子个数为奇数的，最后状态都是开；而因子个数为奇数的数一定是平方数，而平方数的分布有规律性：1,4,9,16,...依次隔了3,5,7,...所以可以按照3,5,7,...进行分组，除了第一个数状态是0，其他都是1，然后用二分查找即可</p><p>注意二分查找的边界条件！！！！！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//每3 5 7 ...个数为1组</span></span><br><span class="line"><span class="comment">//前x组的01总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">3</span> + (<span class="number">2</span> * x + <span class="number">1</span>)) * x / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算前x组中1的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(x) - x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">sum1</span>(mid);</span><br><span class="line"><span class="keyword">if</span> (t &gt; k) r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t &lt; k) l = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(mid) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(l) + k - <span class="built_in">sum1</span>(l) + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c.-bitwise-balancing">C. Bitwise Balancing</h1><p>给定三个整数b,c,d，要求求出一个a，让<spanclass="math inline">\((a|d)-(a\&amp;c)=d\)</span></p><blockquote><p>直接列举a的每一个二进制位即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, a[N];</span><br><span class="line"><span class="type">int</span> b, c, d;</span><br><span class="line">cin &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line"><span class="keyword">while</span> (b || c || d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t1 = b &amp; <span class="number">1</span>, t2 = c &amp; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans1 = t1, ans2 = <span class="number">1</span> - t2;</span><br><span class="line"><span class="keyword">if</span> (ans2 == (d &amp; <span class="number">1</span>)) a[cnt++] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans1 == (d &amp; <span class="number">1</span>)) a[cnt++] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>, c &gt;&gt;= <span class="number">1</span>, d &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="keyword">if</span>(a[i]) ans += <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="d.-connect-the-dots">D. Connect the Dots</h1><p>输入三个整数a,d,k，输入m条指令，每次将<spanclass="math inline">\(a,a+d,a+2d,...,a+kd\)</span>连接起来，问最后有多少个联通块，<spanclass="math inline">\(1\leq k\leq 10\)</span></p><blockquote><p>一开始我没有注意到k的特殊性，直接用并查集做，然后TLE了；然后看了题解，它是巧妙地应用了一个数组，<spanclass="math inline">\(ma[i][j]\)</span>，表示以i为起点每次跳跃j步的次数，将同一个步数的进行归类，每跳一次步数减1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N], ma[N][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">ma[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, d, k;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; d &gt;&gt; k;</span><br><span class="line">ma[a][d] = <span class="built_in">max</span>(ma[a][d], k);<span class="comment">//以a为起点，d为步长最多能走k次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i - j &lt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (ma[i - j][j]) p[<span class="built_in">find</span>(i - j)] = <span class="built_in">find</span>(i);<span class="comment">//如果可以从i - j跳到j</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ma[i][j] &gt; <span class="number">1</span> &amp;&amp; i + j &lt;= n) ma[i + j][j] = <span class="built_in">max</span>(ma[i + j][j], ma[i][j] - <span class="number">1</span>);<span class="comment">//继承前面没跳完的次数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">s.<span class="built_in">emplace</span>(<span class="built_in">find</span>(i));<span class="comment">//s中有该元素返回False，没有就加到s中返回true</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/10/02/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/10/02/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最大数">最大数</h1><p>给定一个正整数数列<code>a1,a2,…,an</code>，每一个数都在<code>0∼p−1</code>之间。</p><p>可以对这列数进行两种操作：</p><ol type="1"><li>添加操作：向序列后添加一个数，序列长度变成 <code>n+1</code>；</li><li>询问操作：询问这个序列中最后 L 个数中最大的数是多少。</li></ol><p>如果该行的内容是 <code>Q L</code>，则表示这个操作是询问序列中最后 L个数的最大数是多少;</p><p>如果是 <code>A t</code>，则表示向序列后面加一个数，加入的数是<code>(t+a) mod p</code>。其中，t是输入的参数，a是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则a=0）。</p><blockquote><p>基本模版</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> m, p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;tree[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[u] = &#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[u].l == x &amp;&amp; tree[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[u].v = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tree[u].l + tree[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">    tree[u].v = <span class="built_in">max</span>(tree[u &lt;&lt; <span class="number">1</span>].v, tree[u &lt;&lt;<span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[u].l &amp;&amp; r &gt;= tree[u].r) <span class="keyword">return</span> tree[u].v;</span><br><span class="line">    <span class="type">int</span> mid = (tree[u].l + tree[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;    cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, ((<span class="type">long</span> <span class="type">long</span>)t + last) % p);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> L;  cin &gt;&gt; L;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>, n - L + <span class="number">1</span>, n);</span><br><span class="line">            cout &lt;&lt; last &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="你能回答这些问题吗">你能回答这些问题吗</h1><p>给定长度为 N 的数列 A，以及 M条指令，每条指令可能是以下两种之一：</p><ol type="1"><li><code>1 x y</code>，查询区间 [x,y] 中的最大连续子段和，即<spanclass="math inline">\(\max\limits_{x\leq l\leq r \leqy}\left\{\sum\limits_{i=l}^r A[i]\right\}\)</span>。</li><li><code>2 x y</code>，把 A[x] 改成 y。</li></ol><p>对于每个查询指令，输出一个整数表示答案。</p><blockquote><ol type="1"><li><p>线段树结构体中要记录的有<code>l,r,max</code></p></li><li><p>max向上传递有三种情况</p><ul><li>问的区间恰好在区间的左半边</li><li>问的区间恰好在区间的右半边</li><li>问的区间横跨两个区间</li></ul><p>那么这个时候就需要记录左半边的右端点最大连续字段和以及右半边的左端点的最大连续字段和，以及整个区间的最大连续字段和</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lmax, rmax, tmax,sum;</span><br><span class="line">&#125;tree[N * <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">//重点！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node&amp; u, Node&amp; l, Node&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tree[u], tree[u &lt;&lt; <span class="number">1</span>], tree[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tree[u] = &#123;l, r, a[r], a[r], a[r], a[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[u].l &gt;= l &amp;&amp; tree[u].r &lt;= r) <span class="keyword">return</span> tree[u];</span><br><span class="line">    <span class="type">int</span> mid = (tree[u].l + tree[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        Node res;</span><br><span class="line">        <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[u].l == x &amp;&amp; tree[u].r == x) tree[u] = &#123;x, x, y, y, y, y&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (tree[u].l + tree[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间最大公约数">区间最大公约数</h1><p>给定一个长度为 N 的数列 A，以及 M条指令，每条指令可能是以下两种之一：</p><ol type="1"><li><code>C l r d</code>，表示把<code>A[l],A[l+1],…,A[r]A[l],A[l+1],…,A[r]</code>都加上<code>d</code>。</li><li><code>Q l r</code>，表示询问<code>A[l],A[l+1],…,A[r]A[l],A[l+1],…,A[r]</code>的最大公约数(GCD)。</li></ol><p>对于每个询问，输出一个整数表示答案。</p><blockquote><ol type="1"><li>涉及把一个区间都加上一个数，且求的是公约数，可以想到用差分；线段数结构体存储<code>l,r,sum,d</code>，sum用来计算差分数组的前缀和即原数组，d用来记录差分</li><li>查询操作：因为<code>gcd(a, b, c) = gcd(a, b - a, c - a)</code>，所以求<code>[l,r]</code>区间的最大公约数可以求<code>l.sum</code>即<code>a[i]</code>和<code>r.d</code>即<code>[l + 1, r]</code>差分的最大约数（在<code>l + 1 &lt;= r</code>的情况下）</li><li>更改操作：因为是差分，所以在第l个位置加上d，如果<code>r + 1 &lt;= n</code>就减去d</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, d;</span><br><span class="line">&#125;tree[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node&amp; u, Node&amp; l, Node&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tree[u], tree[u &lt;&lt; <span class="number">1</span>], tree[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tree[u] = &#123;l, r, a[r] - a[r - <span class="number">1</span>], a[r] - a[r - <span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[u].l &amp;&amp; r &gt;= tree[u].r) <span class="keyword">return</span> tree[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tree[u].l + tree[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[u].l == x &amp;&amp; tree[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = tree[u].sum + v;</span><br><span class="line">        tree[u] = &#123;x, x, b, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tree[u].l + tree[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;    cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, l);</span><br><span class="line">            Node right = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(l + <span class="number">1</span> &lt;= r) right = <span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r);</span><br><span class="line">            cout &lt;&lt; <span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum, right.d)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, v;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, v);</span><br><span class="line">            <span class="keyword">if</span>(r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(<span class="number">1</span>, r + <span class="number">1</span>, -v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统</title>
      <link href="/2024/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql">SQl</h1><h2 id="数据定义">数据定义</h2><h3 id="模式">模式</h3><h4 id="定义">定义</h4><p><code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义字句&gt;|&lt;授权定义子句&gt;]</code></p><p>即：在<code>CREATE SCHEMA</code>中可以接受<code>CREATE TABLE,CREATE VIEW,GRANT</code>子句</p><ul><li>如果没有指定<模式名>，那么<模式名>隐含为<用户名></li></ul><p><strong>eg</strong>：为用户ZHANG创建一个模式TEST，并且在其中定义一个表TAB1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>TEST<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>ZHANG<span class="operator">&gt;</span></span><br><span class="line">CREATER <span class="keyword">TABLE</span> TAB1(COL1 <span class="type">SMALLINT</span>,</span><br><span class="line">                   COL2 <span class="type">INT</span>,</span><br><span class="line">                   COL3 <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">                   COL4 NUMERUC(<span class="number">10</span>, <span class="number">3</span>),<span class="comment">-- 共10位，整数部分7位，小数点后3位</span></span><br><span class="line">                   COL5 <span class="type">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>)<span class="comment">-- 整数部分加小数部分总长度是5，小数部分长度是2，如果超过2会发生截断，不足2会补齐</span></span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><p><code>Drop SCHEMA &lt;模式名&gt;&lt;CASCADE|RESTRICT&gt;</code></p><ul><li><code>CASCADE</code>表示同时把该模式中所有的数据库对象全部删除</li><li><code>RESTRICT</code>表示如果模式中已经定义了下属的数据库对象，则拒绝执行删除该语句</li></ul><h3 id="基本表">基本表</h3><h4 id="定义-1">定义</h4><h5 id="表">表：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CEATE <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]</span><br><span class="line">                  [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[列级完整性约束条件]]</span><br><span class="line">                  ...</span><br><span class="line">                  [,<span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span>]);</span><br></pre></td></tr></table></figure><p><strong>eg</strong>：创建一个“课程”表Course</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course(</span><br><span class="line">    Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 列级完整性约束条件，Cno是主码</span></span><br><span class="line">    Cname <span class="type">CHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="comment">-- 列级完整性约束条件，Cname不能取空值</span></span><br><span class="line">    Cpno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Ccredit <span class="type">SMALLINT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(Cpno) <span class="keyword">REFERENCES</span> Course(Cno) <span class="comment">-- 表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno</span></span><br><span class="line">    <span class="comment">/*由此可见参照表和被参照表可以是同一个表*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="表所属模式">表所属模式：</h5><p><strong>法一</strong>：在表名中明显给出模式名</p><p>eg：<code>CREATE TABLE "S-T".Student(...);</code>表示<code>Student</code>所属的模式是<code>S-T</code></p><p><strong>法二</strong>：在创建模式语句同时建立表，例子见模式定义</p><p><strong>法三</strong>：根据搜索路径来确定对象所属模式</p><p>搜索路径默认是<code>$user, PUBLIC</code>，表示先搜索与用户名相同的模式名，如果该模式名不存在，就使用<code>PUBLIC</code>模式</p><p>数据库管理员也可以自己设置搜索路径，eg：<code>SET search_path To "S-T", PUBLIC;</code>，然后定义基本表；那么如果<code>S-T</code>存在基本表就定义在了<code>S-T</code>模式中</p><h4 id="修改">修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALERT <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束]]</span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span>RESTRICT]]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span>RESTRICT]]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><h4 id="删除-1">删除</h4><p><code>DROP TABLE &lt;表名&gt; [CASCADE|RESTRICT];</code></p><h3 id="索引">索引</h3><h4 id="建立">建立</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">-- UNIQUE表示每一个索引值只对应唯一的数据记录</span></span><br><span class="line"><span class="comment">-- CLUSTER表示建立的索引是聚簇索引</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>][,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]]...);</span><br></pre></td></tr></table></figure><p>次序：<code>ASC</code>（升序），<code>DESC</code>（降序）；默认<code>ASC</code></p><p><strong>eg</strong>：<code>CREATE UNIQUE INDEX Scno ON SC (Sno ASC, Cno DESC)</code>，表示SC表按学号升序和课程号降序建立唯一索引</p><h4 id="修改-1">修改</h4><p><code>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</code></p><h4 id="删除-2">删除</h4><p><code>DROP INDEX &lt;索引名&gt;</code></p><h2 id="数据查询">数据查询</h2><h3 id="单表查询">单表查询</h3><h4 id="选择表中的若干列">选择表中的若干列</h4><ol type="1"><li><p>查询指定列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列表题别名][,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列标题别名]]... <span class="comment">-- 目标表达式可以是算术表达式、字符串常量、函数等</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p><strong>eg</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname NAME, <span class="string">&#x27;Year of Birth:&#x27;</span>BIRTH, <span class="number">2014</span><span class="operator">-</span>Sage BIRTHDAY, <span class="built_in">LOWER</span>(Sdept) DEPARTMENT </span><br><span class="line"><span class="comment">-- 字符串常量&#x27;Year of Birth:&#x27;列的别名是BIRTH</span></span><br><span class="line"><span class="comment">-- 算术表达式2014-Sage列的别名是BIRTHDAY</span></span><br><span class="line"><span class="comment">-- 函数LOWER(Sdept)列的别名是DEPARTMENT </span></span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure></li><li><p>查询全部列：</p><p><code>SELECT *</code></p></li></ol><h4 id="选择表中若干元组">选择表中若干元组</h4><ol type="1"><li><p>消除取值重复的行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列表题别名][,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列标题别名]]...</span><br><span class="line"><span class="comment">-- DISTINCT消除重复的行</span></span><br><span class="line"><span class="comment">-- ALL保留重复的行</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查询满足条件的元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列表题别名][,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列标题别名]]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> <span class="comment">-- WHERE语句实现</span></span><br></pre></td></tr></table></figure><ul><li><p>确定集合：<code>IN/NOT IN</code></p></li><li><p>字符串匹配：<code>[NOT] LIKE'&lt;匹配串&gt;' [ESCAPE '&lt;换码字符&gt;']</code></p><ul><li><p><匹配串>中可以含有通配符%（表示任意长度的字符串，长度可以为0）和_（表示任意单个字符）</p></li><li><p>如果匹配串中不含通配符，<code>LIKE</code>可以用<code>=</code>代替</p></li><li><p>如果要查询的字符串中本身含有%或_，那么就要用<code>[ESCAPE '&lt;换码字符&gt;']</code>进行转义</p></li></ul><p><strong>eg</strong>：查询以"DB_"开头，且倒数第三个字符为i的课程的详细信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span><span class="string">&#x27;DB\_%i_ _&#x27;</span> <span class="keyword">ESCAPE</span><span class="string">&#x27;\&#x27;</span> </span><br></pre></td></tr></table></figure></li><li><p>空值的查询：<code>IS [NOT] NULL</code></p></li><li><p>多重条件查询：<code>AND/OR(AND优先级高于OR)</code></p></li></ul></li></ol><h4 id="order-by"><code>ORDER BY</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列表题别名][,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列标题别名]]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>] <span class="comment">-- ASC升序，DESC降序；默认为ASC</span></span><br></pre></td></tr></table></figure><h4 id="聚集函数">聚集函数</h4><h4 id="group-by"><code>GROUP BY</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列表题别名][,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列标题别名]]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span><span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>] <span class="comment">-- 将查询结果按某一列或多列的值进行分组，HAVING语句指定筛选条件 </span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><spanclass="math inline">\(\color{red}{注：}\)</span>WHERE作用于基本表或者视图；HAVING作用于组</p><h3 id="连接查询">连接查询</h3><h4 id="等值与非等值连接查询">等值与非等值连接查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词*/</span></span><br><span class="line"><span class="comment">-- 连接谓词：</span></span><br><span class="line">[<span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span>.]<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span><span class="operator">&lt;</span>比较运算符<span class="operator">&gt;</span>[<span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span>.]<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">[<span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span>.]<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span><span class="keyword">BETWEEN</span>[<span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span>.]<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span><span class="keyword">AND</span>[<span class="operator">&lt;</span>表名<span class="number">3</span><span class="operator">&gt;</span>.]<span class="operator">&lt;</span>列名<span class="number">3</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>自然连接：把目标列中重复的属性列去掉</p><h4 id="自身连接">自身连接</h4><p>给同一个表取两个别名，按照不同表的连接方式连接即可</p><h4 id="外连接">外连接</h4><p>连接两个表的时候，可能有的元素因为不满足条件，没有出现在最终的表格中；利用外连接可以在不满足条件的地方填上NULL。左外连接，保留左边的表，右边的表不足的时候填上NULL；右外连接同理。</p><p><strong>eg</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span>([表名<span class="number">1.</span>]<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;=</span>[表名<span class="number">2.</span>]<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>) <span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span>([表名<span class="number">1.</span>]<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;=</span>[表名<span class="number">2.</span>]<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>) <span class="comment">-- 右外连接</span></span><br><span class="line"><span class="comment">-- 可以用USING来去掉结果中的重复值：FROM &lt;表名1&gt; RIGHT OUTER JOIN &lt;表名2&gt; USING(列名)</span></span><br></pre></td></tr></table></figure><h4 id="多表连接">多表连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="嵌套查询">嵌套查询</h4><p><spanclass="math inline">\(\color{red}{注：}\)</span>子查询的SELECT语句中不能使用ORDERBY</p><ol type="1"><li><p>带有IN的子查询</p><p>不相关子查询：子查询条件不依赖父节点</p><p>相关子查询：子查询条件依赖父节点</p><p><strong>eg</strong>：找出每个学生超过他自己选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Sno--学号 Cno--课程号 SC--存储学号、课程号、成绩的表格 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> GRADE <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(GRADE)</span><br><span class="line">                <span class="keyword">FROM</span> SC y</span><br><span class="line">                <span class="keyword">WHERE</span> x.Sno <span class="operator">=</span> y.Sno <span class="comment">-- 表示是同一个学生的成绩</span></span><br><span class="line">               );</span><br></pre></td></tr></table></figure></li><li><p>带有比较运算符的子查询</p></li><li><p>带有ANY（SOME）或ALL的子查询</p><ul><li><p>ANY -- 某个 ； ALL -- 所有</p></li><li><p>可以用聚集函数+比较运算符代替ANY/ALL，且聚集函数效率更高</p><p>eg：<code>&lt;ANY 等价于 &lt;MAX</code></p></li></ul></li><li><p>带有EXISTS/NOT EXISTS的子查询</p><p>EXISTS：如果内层查询非空，返回真；否则返回假</p><p>NOT EXISTS：如果内层非空，返回假；否则返回真</p><p>由于没有全称量词，所以需要将题目转换成等价的用存在量词的形式</p><p><strong>eg</strong>：查询选修了全部课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*等价于查询 找到学生 没有一门课是ta不选的*/</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="comment">-- 不存在</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> Course</span><br><span class="line">        <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="comment">-- 有一门课程没有ta</span></span><br><span class="line">        (</span><br><span class="line">                <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                <span class="keyword">FROM</span> SC</span><br><span class="line">                <span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span> Cno <span class="operator">=</span> Course.Cno</span><br><span class="line">            )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>eg</strong>：查询至少选修了学生201215122选修的全部课程的学生号码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*等价于查询学生x： 不存在这样的课程y 学生201215122选修了y 但是学生x没选修*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC SCX <span class="comment">-- 查询学生x</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="comment">-- 查询课程y</span></span><br><span class="line">        <span class="keyword">FROM</span> SC SCY</span><br><span class="line">        <span class="keyword">WHERE</span> SCY.Sno <span class="operator">=</span> <span class="string">&#x27;201215122&#x27;</span> <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="comment">-- 20121522选修了</span></span><br><span class="line">                                (</span><br><span class="line">                                    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                                    <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">                                    <span class="keyword">WHERE</span> SCZ.Sno <span class="operator">=</span> SCX.Sno <span class="keyword">AND</span> SCZ.Cno <span class="operator">=</span> SCY.Cno <span class="comment">-- 就是查找学生x的学号是否在里面，以及201215122是否选修了这门课程；</span></span><br><span class="line"><span class="comment">-- 如果发现结果是后面的判断成立，前面的判断不成立，即“学生201215122选修了y 但是学生x没选修”，就返回空，又因为是NOT EXISTS所以表达式是True；于是第二层判断是True，那么又因为是NOT EXISTS所以第二层整体式False，那么这个就不是要找的学生x</span></span><br><span class="line">                                )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ol><h3 id="集合查询">集合查询</h3><p>集合操作主要包括：并<code>UNION</code>，交<code>INTERSECT</code>，差<code>EXCEPT</code></p><h3 id="基于派生表的查询">基于派生表的查询</h3><p>子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表成为主查询的查询对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列表题别名][,<span class="operator">&lt;</span>目标表达式<span class="operator">&gt;</span>[列标题别名]]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>...]<span class="operator">|</span>(<span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span>[<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span>)<span class="comment">-- 通过FROM生成派生表时AS关键字可以省略，但必须为派生表指定一个别名</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span><span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>] </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><strong>eg</strong>：找出每个学生超过自己选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC, (<span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">          <span class="keyword">FROM</span> SC</span><br><span class="line">          <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line">         )<span class="keyword">AS</span> Avg_sc(avg_sno, avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno <span class="operator">=</span> Avg_sc.avg_sno <span class="keyword">AND</span> SC.Grade <span class="operator">&gt;=</span> Avg_sc.avg_grade;</span><br></pre></td></tr></table></figure><h2 id="数据更新">数据更新</h2><h3 id="插入数据">插入数据</h3><p>插入元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>]...)]</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>]...);</span><br></pre></td></tr></table></figure><ol type="1"><li><code>INTO</code>中没有出现的属性列默认取空值</li><li>如果<code>INTO</code>语句中没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值</li><li><code>VALUES</code>子句对新元组的各属性赋值，字符串常数要用单引号括起来</li></ol><p>插入子查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span>)[,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>...]]</span><br><span class="line">子查询；<span class="comment">-- SELECT语句</span></span><br></pre></td></tr></table></figure><h3 id="修改数据">修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span><span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><h3 id="删除数据">删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><h2 id="视图">视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>[(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]...)]</span><br><span class="line"><span class="keyword">AS</span><span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION] <span class="comment">-- 表示在对视图进行操作时保证更新、插入或删除的行满足视图中子查询中的条件表达式</span></span><br></pre></td></tr></table></figure><ol type="1"><li>组成视图的属性名或者全省略或者全部指定</li><li>以下情况必须明确指定组成视图的所有列名<ul><li>某个列式聚集函数或列表达式</li><li>多表连接时选出了几个同名列作为视图的字段</li><li>需要在视图中为某个列启用新的更合适的名字</li></ul></li><li>把对视图的操作都转换成对基本表的操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces_970_Div3</title>
      <link href="/2024/09/27/Codeforces-970-Div3/"/>
      <url>/2024/09/27/Codeforces-970-Div3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-Sakurako’s-Exam"><a href="#A-Sakurako’s-Exam" class="headerlink" title="A. Sakurako’s Exam"></a>A. Sakurako’s Exam</h1><p>每次给两个数，第一个数表示序列中1的个数，第二个数表示序列中2的个数；在1和2前面加上+或者-，判断是否可以让整个序列的加减结果为0</p><ol><li>只有1或只有2的情况，个数必须为偶数</li><li>有1有2的情况，根据2的奇偶情况进一步讨论1的奇偶</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (!b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>)cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>)cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b % <span class="number">2</span>)<span class="comment">//有奇数个2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//有偶数个2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Square-or-Not"><a href="#B-Square-or-Not" class="headerlink" title="B. Square or Not"></a>B. Square or Not</h1><p>判断一个字符串转换成的矩形，能否是边界全为1内部全为0的正方形</p><ol><li>判断能否是正方形</li><li>转换成矩阵，遍历即可</li><li>注意边长小于等于2的矩阵的特殊性，没有内部</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">string s; cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> e = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">if</span> (e * e != n)<span class="comment">//如果不是正方形</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>) == string::npos) <span class="comment">//如果没找到0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">g[i / e][i % e] = s[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//建立矩形</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || i == e - <span class="number">1</span> || j == e - <span class="number">1</span>)<span class="comment">//边界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Longest-Good-Array"><a href="#C-Longest-Good-Array" class="headerlink" title="C. Longest Good Array"></a>C. Longest Good Array</h1><p>给定两个数，要求在这两个数间插入最多的数得到一个序列，并且满足该序列单调递增并且元素之间的间隔不断增大，求整个序列的个数</p><ol><li>利用二分，要数尽可能的多，那么间隔要尽可能的小，是从1开始的以1为等差的等差数列，二分间隔的和</li><li>注意：如果最后不是恰好等于边界，因为要间隔不断增大，所以只能到满足条件的前一个；如果最后一个恰好等于边界，那么就可以取最后一个间隔</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="type">int</span> gap = y - x;</span><br><span class="line"><span class="comment">//二分</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = <span class="built_in">sqrt</span>(<span class="number">2</span> * gap), mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; l + <span class="number">1</span>!= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((mid + <span class="number">1</span>) * mid / <span class="number">2</span> &lt;= gap) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((l + <span class="number">1</span>) * l / <span class="number">2</span> &lt;= gap) ans = <span class="built_in">max</span>(ans, l + <span class="number">1</span>);<span class="comment">//实际上讨论的时候是分&lt;和==的情况，然后发现这两个的式子是一样的，于是合并了</span></span><br><span class="line"><span class="keyword">if</span> ((r + <span class="number">1</span>) * r / <span class="number">2</span> &lt;= gap) ans = <span class="built_in">max</span>(ans, r + <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Sakurako’s-Hobby"><a href="#D-Sakurako’s-Hobby" class="headerlink" title="D. Sakurako’s Hobby"></a>D. Sakurako’s Hobby</h1><p>给定一个数组，根据数组的下标和数组的值进行不断递推，每个数都有黑白两种颜色，问$1\sim n$每个数可以到达的颜色为黑色的数的个数</p><ol><li>利用并查集，将能到达的放在一个集合</li><li>设置一个数组用来记录每个集合中颜色为黑色的数的个数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> s[N], c[N], p[N],ct[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//合并两个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin &gt;&gt; n;</span><br><span class="line"><span class="type">bool</span> st[N] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i];<span class="comment">//排列</span></span><br><span class="line">string color; cin &gt;&gt; color;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[i] = color[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>, ct[i] = <span class="number">1</span> - c[i];<span class="comment">//颜色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i])<span class="comment">//如果没有加入过某个集合</span></span><br><span class="line">&#123;</span><br><span class="line">st[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> j = s[i];</span><br><span class="line"><span class="keyword">while</span> (j != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">merge</span>(j, i);</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">ct[<span class="built_in">find</span>(j)] += <span class="number">1</span> - c[j];</span><br><span class="line">j = s[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cout &lt;&lt; ct[<span class="built_in">find</span>(i)] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Alternating-String"><a href="#E-Alternating-String" class="headerlink" title="E. Alternating String"></a>E. Alternating String</h1><p>对一个序列有两个操作方式：删除一个字母（最多进行一次该操作）；改变一个字母。让序列最终变成偶数个数且奇数位和偶数位上的字母分别相同</p><ol><li><p>分序列数本来是偶数和奇数进行讨论</p></li><li><p>在序列是奇数的情况下要进行第一个操作，而删除一个数会改变后面序列的奇偶，于是$\color{red}{我们从后往前枚举删除的数}$，这样在枚举删除前面的字母的时候后面的字母的奇偶已经是改变的了</p></li><li><p>本题应用了上篇Codeforces-971-G对数据类似的处理方法</p><p>$\color{red}{补充：}$为什么erase要用find？因为如果是删除数，而不是删除位置，那么multiset中的所有等于该数的数都会被删除</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin &gt;&gt; n;</span><br><span class="line">string s;cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//n &gt;= 3 的情况</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; e, o;<span class="comment">//记录所有字母出现的次数，升序排列</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; me, mo;<span class="comment">//记录每个字母出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)<span class="comment">//偶数位</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="built_in">count</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>])) e.<span class="built_in">erase</span>(e.<span class="built_in">find</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line">me[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">e.<span class="built_in">insert</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>)<span class="comment">//奇数位</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (o.<span class="built_in">count</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>])) o.<span class="built_in">erase</span>(o.<span class="built_in">find</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line">mo[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">o.<span class="built_in">insert</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span>)<span class="comment">//如果n是奇数，需要进行删除操作，会改变奇偶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>)<span class="comment">//如果i是奇数</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">//偶数位删除</span></span><br><span class="line">o.<span class="built_in">erase</span>(o.<span class="built_in">find</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line">mo[s[i] - <span class="string">&#x27;a&#x27;</span>]--;<span class="comment">//表示该点被删掉</span></span><br><span class="line"><span class="keyword">if</span> (mo[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) mo.<span class="built_in">erase</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> o.<span class="built_in">insert</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">ans = <span class="built_in">min</span>(ans, n - *o.<span class="built_in">rbegin</span>() - *e.<span class="built_in">rbegin</span>());</span><br><span class="line"><span class="comment">//转换到奇数位</span></span><br><span class="line"><span class="keyword">if</span> (me.<span class="built_in">count</span>(s[i] - <span class="string">&#x27;a&#x27;</span>)) e.<span class="built_in">erase</span>(e.<span class="built_in">find</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line">me[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">e.<span class="built_in">insert</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">e.<span class="built_in">erase</span>(e.<span class="built_in">find</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line">me[s[i] - <span class="string">&#x27;a&#x27;</span>]--;<span class="comment">//表示该点被删掉</span></span><br><span class="line"><span class="keyword">if</span> (me[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) me.<span class="built_in">erase</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> e.<span class="built_in">insert</span>(me[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">ans = <span class="built_in">min</span>(ans, n - *o.<span class="built_in">rbegin</span>() - *e.<span class="built_in">rbegin</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mo.<span class="built_in">count</span>(s[i] - <span class="string">&#x27;a&#x27;</span>)) o.<span class="built_in">erase</span>(o.<span class="built_in">find</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line">mo[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">o.<span class="built_in">insert</span>(mo[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//n是偶数，只进行变换操作</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n - *e.<span class="built_in">rbegin</span>() - *o.<span class="built_in">rbegin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces_971_Div4</title>
      <link href="/2024/09/25/Codeforces-971-Div4/"/>
      <url>/2024/09/25/Codeforces-971-Div4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="d.satyam-and-counting">D.Satyam and Counting</h1><p>在<span class="math inline">\(0\leq x\leq2e5, 0\leq y\leq1\)</span>中给定n个点，计算最多能有多少个直角三角形</p><p>一开始的想法：</p><ol type="1"><li>分直角点在 y = 0 和 y = 1 进行讨论</li><li>直角三角形又分横平竖直的直角三角形和斜着的直角三角形，因为高度一定，所以可以计算出来斜着的直角三角形的直角顶点一定在另两个顶点的中间且横坐标相差1</li><li>构造两个数组分别存放y = 0和y =1的横坐标，然后遍历两次，看某一个横坐标是否在另一行也有对应的横坐标，如果有，那么这一行的x的个数减1就是以该点为顶点的横平竖直的直角三角形；再利用横坐标判断斜直角三角形即可</li><li>在寻找另一行是否有对应横坐标的过程中，使用的方法是双指针，最终会TLE</li></ol><p>TLE代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; q0, q1;</span><br><span class="line"><span class="type">int</span> n;cin &gt;&gt; n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>) q0.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">else</span> q1.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!q1.<span class="built_in">size</span>() || !q0.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(q0.<span class="built_in">begin</span>(), q0.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(q1.<span class="built_in">begin</span>(), q1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; q0.<span class="built_in">size</span>(); i++)<span class="comment">//遍历y = 0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; q1.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; q0[i] &gt; q1[j]) j++;</span><br><span class="line"><span class="keyword">if</span> (q0[i] == q1[j]) ans += q0.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(q1.<span class="built_in">begin</span>(), q1.<span class="built_in">end</span>(), q0[i] - <span class="number">1</span>) != q1.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">find</span>(q1.<span class="built_in">begin</span>(), q1.<span class="built_in">end</span>(), q0[i] + <span class="number">1</span>) != q1.<span class="built_in">end</span>())</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; q1.<span class="built_in">size</span>(); i++)<span class="comment">//遍历y = 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; q0.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; q1[i] &gt; q0[j]) j++;</span><br><span class="line"><span class="keyword">if</span> (q1[i] == q0[j]) ans += q1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(q0.<span class="built_in">begin</span>(), q0.<span class="built_in">end</span>(), q1[i] - <span class="number">1</span>) != q0.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">find</span>(q0.<span class="built_in">begin</span>(), q0.<span class="built_in">end</span>(), q1[i] + <span class="number">1</span>) != q0.<span class="built_in">end</span>())</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后：</p><ol type="1"><li>使用map来记录坐标对，直接利用count函数来判断是否存在该横坐标</li><li>利用y ^ 1来表示另一行</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">map&lt;PII, <span class="type">int</span>&gt; e;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cnt[y]++;</span><br><span class="line">e[&#123;x, y&#125;] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : e)</span><br><span class="line">&#123;</span><br><span class="line">PII x = t.first;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="built_in">count</span>(&#123; x.first, x.second ^ <span class="number">1</span> &#125;)) ans += cnt[x.second] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="built_in">count</span>(&#123; x.first - <span class="number">1</span>, x.second ^ <span class="number">1</span> &#125;) &amp;&amp; e.<span class="built_in">count</span>(&#123; x.first + <span class="number">1</span>, x.second ^ <span class="number">1</span> &#125;)) ans += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e.klees-super-duper-large-array">E.Klee's SUPER DUPER LARGEArray!!!</h1><p>连续的n个数，从第i个数分开，前i个数的和减去剩下数的和的绝对值最小，求该值</p><p>利用二分，最后得到的l和r都可能是答案，计算出来进行比较即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="type">int</span> tot = (k + n + k - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> l = k, r = k + n - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">1</span> != r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot1 = (k + mid) * (mid - k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (tot1 &lt; tot - tot1) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ltot = (k + l) * (l - k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">abs</span>(tot - ltot - ltot);</span><br><span class="line"><span class="keyword">if</span> (r &lt; n + k - <span class="number">1</span>) ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(tot - ltot - r - ltot - r));</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="f.fireflys-queries">F.Firefly's Queries</h1><p>给定一个序列，轮换让每个数当“队头”，并列成一个新的长序列，给定l和r，计算l到r的所有数的和</p><p>分别计算<span class="math inline">\(1\sim l-1,1\simr\)</span>的和，然后相减即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], a[i] += a[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> lt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="comment">//计算1 ~l-1</span></span><br><span class="line">l = l - <span class="number">1</span>;</span><br><span class="line">lt += l / n * a[n];</span><br><span class="line"><span class="keyword">if</span> (l % n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> le = (l / n + l % n) % n == <span class="number">0</span> ? n : (l / n + l % n) % n;<span class="comment">//映射到1-n</span></span><br><span class="line"><span class="type">int</span> ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l / n) ls = ((l / n * n + <span class="number">1</span>) / n + (l / n * n + <span class="number">1</span>) % n) % n == <span class="number">0</span> ? n : ((l / n * n + <span class="number">1</span>) / n + (l / n * n + <span class="number">1</span>) % n) % n;</span><br><span class="line"><span class="keyword">if</span> (le &gt;= ls) lt += a[le] - a[ls - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> lt += a[n] - a[ls - <span class="number">1</span>] + a[le];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算1 ~ r</span></span><br><span class="line">rt += r / n * a[n];</span><br><span class="line"><span class="keyword">if</span> (r % n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> re = (r / n + r % n) % n == <span class="number">0</span> ? n : (r / n + r % n) % n;</span><br><span class="line"><span class="type">int</span> rs = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(r / n) rs = ((r / n * n + <span class="number">1</span>) / n + (r / n * n + <span class="number">1</span>) % n) % n == <span class="number">0</span> ? n : ((r / n * n + <span class="number">1</span>) / n + (r / n * n + <span class="number">1</span>) % n) % n;</span><br><span class="line"><span class="keyword">if</span> (re &gt;= rs) rt += a[re] - a[rs - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> rt += a[n] - a[rs - <span class="number">1</span>] + a[re];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; rt - lt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g.yunlis-subarray-queries">G.Yunli's Subarray Queries</h1><p>计算最长连续上升子序列的长度</p><ol type="1"><li>因为是“连续”上升，所以可以用<code>w[i]-i</code>，然后计算相同的数的个数的最大值</li><li>因为序列的长度是固定的，所以可以利用滑动窗口</li><li>那么就需要一个数据结构来记录每个数出现的次数，一个数据结构用来记录最大的出现次数</li><li>因为数有可能是负值，所以不能用数组，可以用map；记录次数可以用multiset（自行升序排列，可有重复数字）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> w[N], ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i], w[i] -= i;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;<span class="comment">//存储一个数到它个数的映射</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s;<span class="comment">//用来存储各个数的数量，使用multiset可以直接排好序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">find</span>(w[i]) != m.<span class="built_in">end</span>())<span class="comment">//如果m中存在，就先把旧的数量删除，再存储进新的数量</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(m[w[i]]));<span class="comment">//删除pos</span></span><br><span class="line">m[w[i]]++;</span><br><span class="line">s.<span class="built_in">insert</span>(m[w[i]]);<span class="comment">//存储进新的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = k; l &lt;= n; l++, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (r &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">find</span>(w[r]) != m.<span class="built_in">end</span>())</span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(m[w[r]]));</span><br><span class="line">m[w[r]]++;</span><br><span class="line">s.<span class="built_in">insert</span>(m[w[r]]);</span><br><span class="line">&#125;</span><br><span class="line">ans[l] = k - *s.<span class="built_in">rbegin</span>();<span class="comment">//因为是升序，找最大值用逆向迭代器</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(m[w[l]]));</span><br><span class="line">m[w[l]]--;</span><br><span class="line"><span class="keyword">if</span> (m[w[l]] == <span class="number">0</span>) m.<span class="built_in">erase</span>(w[l]);</span><br><span class="line"><span class="keyword">else</span> s.<span class="built_in">insert</span>(m[w[l]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt; ans[l] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络和因特网</title>
      <link href="/2024/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
      <url>/2024/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络边缘">网络边缘</h1><h2 id="端系统主机">端系统（主机）</h2><blockquote><p>与因特网相连的计算机和其他设备称为端系统</p></blockquote><p>包括：桌面计算机、服务器、移动计算机</p><h2 id="接入网">接入网</h2><blockquote><p>将端系统物理连接到边缘路由器的网络</p></blockquote><h3 id="家庭接入网">家庭接入网</h3><ul><li>数字用户线（DSL）<ul><li>使用DSL时用户的本地电话公司也是它的因特网服务供应商(ISP)</li><li>每个用户的DSL调制解调器使用现有的电话线与位于电话公司的本地中心距中的数字用户线接入复用器（DSLAM）交换数据</li><li>用户一侧：使用一个分频器把到达家庭的数据信号和电话信号分隔开来，并将数据信号转发给DSL调制解调器</li><li>本地中心局中：DSLAM把数据和电话信号分隔开</li><li>不对称接入，上行和下行速率不同</li></ul></li><li>电缆<ul><li>利用有线电视公司现有的有线电视基础设施</li><li>使用电缆调制解调器、电缆调制解调器端接系统（CMTS）</li><li>不对称接入</li></ul></li><li>光纤到户（FTTH）<ul><li>有源光纤网络（AON），本质上是交换以太网</li><li>无源光纤网络（PON）<ul><li>每个家庭有一个光纤网络端接器（ONT）</li><li>ONT由专门的光纤连接到邻近的分配器，该分配器把一些家庭连接到一根共享光纤，该光纤再连接到本地电话和公司的中心局中的ONT，该ONT提供光电信号的转换，经过本地电话公司路由器与因特网相连</li></ul></li></ul></li><li>5G<ul><li>采用波束成形级数，数据以无线方式从供应商的基站发送到家中的调制解调器，由一个无线路由器与该调制解调器相连</li></ul></li></ul><h3 id="企业接入">企业接入</h3><ul><li>以太网：使用双绞铜线与一台以太网交换机相连</li><li>WiFi：基于IEEE 802.11技术的无线LAN接入</li></ul><h2 id="物理媒介">物理媒介</h2><p>HFC：光缆和同轴电缆</p><p>DSL、以太网：双绞铜线</p><p>移动接入网：无线电频谱</p><h1 id="网络核心">网络核心</h1><blockquote><p>即由互联因特网端系统的分组交换机和链路构成的网状网络</p></blockquote><h2 id="分组交换">分组交换</h2><ul><li>将长报文划分成较小的数据块，每个分组都通过通信链路和分组交换机传送</li><li>存储转发传输：仅当路由器已经接收完该分组的所有比特后，它才能开始向出链路传输该分组</li><li>排队时延和分组丢失</li><li>转发表和路由选择协议：在分组的首部包含目的地的IP地址；每台路由器有一个转发表，用于将目的地址映射为输出链路，路由选择协议用于自动设置这些转发表</li></ul><h2 id="电路交换">电路交换</h2><ul><li>在端系统间通信会话期间预留了端系统间沿路径通信所需要的资源</li><li>频分复用（FDM）、时分复用（TDM）</li></ul><h1 id="分组交换网">分组交换网</h1><h2 id="分组交换网中的时延">分组交换网中的时延</h2><ul><li>处理时延</li><li>排队时延</li><li>传输时延：将所有分组的比特推向链路所需要的时间</li><li>传播时延：传播速率接近光速可近似忽略</li></ul><h2 id="计算机网络中的吞吐量">计算机网络中的吞吐量</h2><p>瞬时吞吐量：从主机A到主机B发文件，主机B收到该文件的速率就是瞬时吞吐量</p><p>瓶颈链路的传输速率：主机B收到Fbit的文件，以速率Rs到达路由器，以速率Rc离开路由器，那么吞吐量是<spanclass="math inline">\(min(Rs,Rc)\)</span>，传输文件的时间为<spanclass="math inline">\(F/min(Rs,Rc)\)</span></p><h1 id="协议层次及其服务模型">协议层次及其服务模型</h1><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稳恒磁场</title>
      <link href="/2024/09/18/%E7%A8%B3%E6%81%92%E7%A3%81%E5%9C%BA/"/>
      <url>/2024/09/18/%E7%A8%B3%E6%81%92%E7%A3%81%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="磁场与磁介质的相互作用">磁场与磁介质的相互作用</h1><h2 id="磁场对载流导线的作用">磁场对载流导线的作用</h2><p><span class="math display">\[\vec{F}=\int_L Id\vec{l}\times\vec{B}\]</span></p><p>两根直流电流的相互作用：</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409181325701.jpg" alt="202409181" style="zoom: 33%;" /></p><p><spanclass="math display">\[F_{12}=\int_LdF_{12}=\int_LI_2d\vec{l}\cdot\vec{B}=\int_a^{a+L\sin \theta}I_2\frac{\mu_0I_1}{2\pir}\cdot\frac{dr}{\sin\theta}=\frac{\mu_0I_1I_2}{2\pi\sin\theta}\ln\frac{a+L\sin\theta}{a}\]</span></p><h2 id="磁场对载流线圈的作用">磁场对载流线圈的作用</h2><p>磁偶极矩：<spanclass="math display">\[\vec{P_m}=IS\vec{n}，方向：同I方向右手定则\]</span></p><p>线圈总力矩：<spanclass="math display">\[\vec{M}=\vec{P_m}\times\vec{B}\]</span></p><h1 id="磁介质">磁介质</h1><p>相对磁导率：<spanclass="math inline">\(\mu_r=\frac{B}{B_0}\)</span></p><h2 id="顺磁质">顺磁质</h2><blockquote><p>微观：一个分子电流</p></blockquote><p>未加磁场：<spanclass="math inline">\(B_0=0,\vec{p_m}\neq0,\sum\vec{p_m}=0\)</span>，即每个磁矩均不为0，但是合磁矩为0</p><p>加磁场：<span class="math inline">\(B_0\neq0,\sum\vec{p_m}\neq0,\vec{M}=\vec{p_m}\times\vec{B}\)</span>，尽量使<spanclass="math inline">\(\vec{M}=0\)</span></p><p>外磁场越强，分子磁矩排列越整齐；磁化电流越大，附加磁场越强。</p><h2 id="抗磁质">抗磁质</h2><blockquote><p>微观：一对分子电流</p></blockquote><p>未加磁场：<spanclass="math inline">\(B_0=0,\vec{p_m}=\vec{p_{m1}}+\vec{p_{m2}}=0\)</span></p><p>加磁场：<span class="math inline">\(\Delta\vec{p_m}\)</span>的方向与<spanclass="math inline">\(\vec{B_0}\)</span>方向永远相反</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409181326883.jpg" /></p><h2 id="磁化强度">磁化强度</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409181326641.jpg" /></p><p>单位体积内分子磁矩的矢量和：<spanclass="math display">\[\vec{M}=\frac{\vec{p_m}}{\Delta V}\]</span></p><p>顺磁质：<span class="math inline">\(\vec{M}\)</span>与<spanclass="math inline">\(\vec{B}\)</span>同向；抗磁质：<spanclass="math inline">\(\vec{M}\)</span>与<spanclass="math inline">\(\vec{B}\)</span>反向</p><p>磁化强度的大小等于磁化面电流密度，即<spanclass="math inline">\(|\vec{M}|=i&#39;\)</span></p><p>磁化强度的环流：<spanclass="math inline">\(\oint_L\vec{M}d{\vec{l}}=i&#39;\cdot\overline{ab}=\sum\limits_{L内}I&#39;\)</span></p><h1id="有介质时的高斯定理和安培环路定理">有介质时的高斯定理和安培环路定理</h1><h2 id="高斯定理">高斯定理</h2><p><span class="math display">\[\oint_S\vec{B}\cdotd\vec{S}=0\]</span></p><h2 id="安培环路定理">安培环路定理</h2><p><span class="math display">\[\oint_L\vec{B}d\vec{l}=\mu_0\sumI+\mu_0\sum I&#39;\]</span></p><p>又<span class="math display">\[\oint_L\vec{M}\cdot d\vec{l}=\sumI&#39;\]</span></p><p><spanclass="math display">\[\oint_L(\frac{\vec{B}}{\mu_0}-\vec{M})\cdotd\vec{l}=\sum I\]</span></p><p>定义磁场强度<span class="math inline">\(\vec{H}\)</span>： <spanclass="math display">\[\vec{H}=\frac{\vec{B}}{\mu_0}-\vec{M}\]</span></p><p>安培环路定理：<span class="math display">\[\oint_L\vec{H}\cdotd\vec{l}=\sum I\]</span></p><blockquote><p>磁场强度沿任一闭合路径的环流等于该闭合路径所包围的自由电流的代数和</p></blockquote><h2 id="三矢量之间的关系">三矢量之间的关系</h2><p><spanclass="math display">\[\vec{M}=\chi_m\vec{H},\chi_m\rightarrow介质磁化率\]</span></p><p><spanclass="math display">\[\vec{B}=\mu_0\mu_r\vec{H},\mu_r=1+\chi_m\rightarrow相对磁化率\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 磁场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稳恒磁场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>积分不等式</title>
      <link href="/2024/09/08/%E7%A7%AF%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <url>/2024/09/08/%E7%A7%AF%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 微积分 </category>
          
          <category> 积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP校内选拔赛2024年5月</title>
      <link href="/2024/09/07/CSP%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94%E8%B5%9B2024%E5%B9%B45%E6%9C%88/"/>
      <url>/2024/09/07/CSP%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94%E8%B5%9B2024%E5%B9%B45%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="a-装饰品">A-装饰品</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409071014749.png" /></p><blockquote><ol type="1"><li>根据分析，在第一个盒子有m中放发，第二个盒子有<spanclass="math inline">\(m-1\)</span>种放发，在第三个盒子有<spanclass="math inline">\(m-2\)</span>种放发，在第四个盒子，我们也只需保证和第2、3两个盒子中的不同即可，即<spanclass="math inline">\(m-2\)</span>种选法，所以答案应该是<spanclass="math inline">\(m(m-1)(m-2)^{n-2}\)</span></li><li>显然我们需要用快速幂，但是<spanclass="math inline">\(n,m\)</span>的范围很大，我们需要先对它们取模</li><li><spanclass="math inline">\(\color{red}{费马小定理：当p是质数且a不是p的倍数，a^{p-1}\equiv1(mod\ p)}\)</span></li></ol><p>证明：</p><p><span class="math display">\[a^b\ mod\ p= (a\ mod\ p)^{b\ mod\(p-1)}\]</span></p><p><span class="math display">\[a^b\ mod\ p=a^{(p-1)k+h}\ mod \ p =(a^{p-1})^k\ mod \ p\cdot a^h\ mod\ p=a^h\ mod\ p\]</span></p><p><span class="math display">\[h = b\ mod\ (p-1)\]</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll T, m, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        m = m % mod, n = n % (mod - <span class="number">1</span>);<span class="comment">//??????为什么必须要在这里取模？？？？？？？，不能再qmi那里取模？？？？？？</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) cout &lt;&lt; m % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; m % mod * (m - <span class="number">1</span>) % mod * <span class="built_in">qmi</span>(m - <span class="number">2</span>, n - <span class="number">2</span>, mod) % mod&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数</title>
      <link href="/2024/09/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/2024/09/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给定 n 组询问，每组询问给定两个整数 a，b，请你输出<spanclass="math inline">\(C_a^b\mod(1e9 + 7)\)</span>的值。</p><h1 id="求组合数ⅰ">求组合数Ⅰ</h1><p>时间复杂度：O(<span class="math inline">\(n^2\)</span>)</p><p><span class="math inline">\(1\leq n\leq 10000,1\leq b\leq a\leq2000\)</span></p><blockquote><ol type="1"><li>数据量较小，直接将所有可能初始化</li><li><spanclass="math inline">\(C_a^b=C_{a-1}^{b-1}+C_{a-1}^b\)</span></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> C[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; C[a][b] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求组合数ⅱ">求组合数Ⅱ</h1><p>时间复杂度：O(nlogn)</p><p><span class="math inline">\(1\leq n\leq 1000,1\leq b\leq a\leq10^5,mod = 1e9 + 7\)</span></p><blockquote><p><span class="math inline">\(C_a^b=\frac{a!}{b!(a-b)!}=a!\timesb!^{-1}\times (a-b)!^{-1}\)</span></p><p><span class="math inline">\(b!^{-1} = ((b-1)!b)^{-1}=(b-1)!^{-1}b^-1= (b-1)!^{-1}b^{m-2}\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll f[N], inf[N], n;<span class="comment">//f用来存储阶乘，inf用来存储阶乘的逆元</span></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = inf[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1e5</span> + <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inf[i] = inf[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; f[a] * inf[b] % mod * inf[a - b] % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求组合数ⅲ">求组合数Ⅲ</h1><p>（适合p较小）</p><p>给定 n 组询问，每组询问给定三个整数 <spanclass="math inline">\(a,b,p\)</span>其中 p是质数，请你输出<spanclass="math inline">\(C_a^b\mod p\)</span>的值。</p><p><span class="math inline">\(1\leq n\leq 20,1\leq b\leq a \leq10^{18},1\leq p\leq 10^{5}\)</span></p><blockquote><p>lucas定理：<span class="math inline">\(C_a^b =C_{\frac{a}{p}}^{\frac{b}{p}}C_{a\ mod\ p}^{b\ mod\ p}(mod\p)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a, b, p, n;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * j % p;</span><br><span class="line">        res = res * <span class="built_in">qmi</span>(i, p - <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt;p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(a % p, b % p) * <span class="built_in">lucas</span>(a / p, b / p) % p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lucas</span>(a, b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求组合数ⅳ">求组合数Ⅳ</h1><p>输入a，b，求<span class="math inline">\(C_a^b\)</span>，其中<spanclass="math inline">\(1\leq b\leq a\leq 5000\)</span></p><blockquote><p>因为没有mod，所以结果可能会很大，所以需要用高精度</p><p>但是如果直接用高精会超时，所以将<spanclass="math inline">\(C_a^b=\frac{a!}{b!(a-b)!}\)</span>中的<spanclass="math inline">\(a!\ b!\(a-b)!\)</span>用质因子进行表示，只进行上标的减法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5100</span>;</span><br><span class="line"><span class="type">int</span> prime[N], st[N], cnt, num[N];</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//筛质数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= x / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> n)</span><span class="comment">//数n中含多少个因子p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">const</span> <span class="type">int</span> p)</span><span class="comment">//高精度乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i] * p;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; res.<span class="built_in">back</span>() == <span class="number">0</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">get_prime</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">        num[i] = <span class="built_in">count</span>(prime[i], a) - <span class="built_in">count</span>(prime[i], b) - <span class="built_in">count</span>(prime[i], a - b);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; num[i]; j++)</span><br><span class="line">            res = <span class="built_in">mul</span>(res, prime[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMC积分</title>
      <link href="/2024/09/03/CMC%E7%A7%AF%E5%88%86/"/>
      <url>/2024/09/03/CMC%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="求积分">求积分</h1><h2 id="常用公式">常用公式</h2><ol type="1"><li><p><spanclass="math display">\[\int_a^bf(x)dx=\int_a^bf(a+b-x)dx\]</span></p></li><li><p><span class="math display">\[\int_0^\pixf(sinx)dx=\pi\int_0^{\frac{\pi}{2}}f(sinx)dx=\pi\int_0^{\frac{\pi}{2}}f(cosx)dx\]</span></p><p><spanclass="math display">\[\int_0^{\pi}f(sinx)dx=2\int_0^{\frac{\pi}{2}}f(sinx)dx=2\int_0^{\frac{\pi}{2}}f(cosx)dx\]</span></p><p><spanclass="math display">\[\int_0^{\pi}f(cos)dx=\left\{\begin{array}{**lr**}2\int_0^{\frac{\pi}{2}}f(cosx)dx&amp; &amp;f偶\\0 &amp; &amp;f奇\end{array}\right.\]</span></p></li></ol><h2 id="改变参数法">改变参数法</h2><p><img src="../../../../008mypost/picture/202409031.jpg" /></p><h2 id="换元法">换元法</h2><blockquote><ul><li>出现<span class="math inline">\(1+x^2\)</span>的形式可考虑<spanclass="math inline">\(x=\tan t\)</span></li><li>对于<spanclass="math inline">\(\int_a^b\frac{f(x)}{f(x)+g(x)}dx\)</span>，可设<spanclass="math inline">\(x=a+b-u\)</span></li></ul></blockquote><p><img src="../../../../008mypost/picture/202409032.jpg" /></p><blockquote><p>利用对称区间，偶倍奇零</p></blockquote><p><img src="../../../../008mypost/picture/202409035.jpg" /></p><h2 id="待定系数法">待定系数法</h2><blockquote><p>存在<spanclass="math inline">\(e^x,sinx,cosx\)</span>等函数，要求原函数时可以用待定系数法</p></blockquote><p><img src="../../../../008mypost/picture/202409033.jpg" /></p><h2 id="结伴法">结伴法</h2><blockquote><p><spanclass="math inline">\(I_1,I_2\)</span>的两种不同线性组合可以积出来</p></blockquote><p><img src="../../../../008mypost/picture/202409034.jpg" /></p><h2 id="逐项积分法">逐项积分法</h2><p><img src="../../../../008mypost/picture/202409036.jpg" /></p><h2 id="利用定积分定义">利用定积分定义</h2><p><img src="picture/202409037.jpg" /></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMC中值问题与微分应用</title>
      <link href="/2024/09/02/CMC%E4%B8%AD%E5%80%BC%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BE%AE%E5%88%86%E5%BA%94%E7%94%A8/"/>
      <url>/2024/09/02/CMC%E4%B8%AD%E5%80%BC%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BE%AE%E5%88%86%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="中值问题">中值问题</h1><h2 id="单中值问题">单中值问题</h2><blockquote><p>利用微分方程 + 罗尔定理</p></blockquote><p><spanclass="math display">\[化成形式：f&#39;(x)+P(x)f(x)=Q(x)\]</span></p><p><span class="math display">\[辅助函数：F(x)=f(x)e^{\int P(x)dx}-\intQ(x)e^{\int P(x)dx}\]</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634572.jpg" /></p><blockquote><p>利用介值定理，凹凸性进行放缩判断范围</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634757.jpg" /></p><h2 id="双中值问题">双中值问题</h2><blockquote><p>观察法，凑出辅助函数</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634672.jpg" /></p><blockquote><p>设置双函数，运用拉格朗日中值定理</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634158.jpg" /></p><blockquote><p>利用微分中值定理的几何性质进行分析，大胆假设</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634018.jpg" /></p><h2 id="利用泰勒展开">利用泰勒展开</h2><blockquote><p>出现二阶及以上的项，考虑用泰勒展开</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021636140.jpg" /></p><h2 id="三中值问题">三中值问题</h2><blockquote><p>运用两次中值定理</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634750.jpg" /></p><h1 id="不等式问题">不等式问题</h1><h2 id="凹凸性">凹凸性</h2><p><span class="math display">\[连续：凸函数\LeftrightarrowJensen不等式，f(\sum\limits_{k=1}^{n}t_kx_k)\leq\sum\limits_{k=1}^{n}t_kf(x_k)\]</span></p><p><span class="math display">\[一阶可导：凸函数\Leftrightarrowf(x_2)\geq f(x_1)+f&#39;(x_1)(x_2-x_1)\]</span></p><p><span class="math display">\[二阶可导：凸函数\Leftrightarrowf&#39;&#39;(x)\geq 0\]</span></p><h2 id="泰勒展开">泰勒展开</h2><p>题目给了范围<spanclass="math inline">\([a,b]\)</span>：（根据已知哪一点的导数进行选择）</p><p><spanclass="math display">\[f(x)=f(a)+f&#39;(a)(x-a)+\frac{1}{2}f&#39;&#39;(a)(x-1)^2+...\]</span></p><p><spanclass="math display">\[f(x)=f(b)+f&#39;(b)(x-b)+\frac{1}{2}f&#39;&#39;(b)(x-b)^2+...\]</span></p><p><spanclass="math display">\[f(a)=f(x)+f&#39;(x)(a-x)+\frac{1}{2}f&#39;&#39;(x)(a-x)^2+...\]</span></p><p><spanclass="math display">\[f(b)=f(x)+f&#39;(x)(b-x)+\frac{1}{2}f&#39;&#39;(x)(b-x)^2+...\]</span></p><p>题目未给范围或范围为<span class="math inline">\(\infty\)</span>：</p><p><spanclass="math display">\[f(x+h)=f(x)+f&#39;(x)h+\frac{1}{2}f&#39;&#39;(x)h^2+...\]</span></p><p><spanclass="math display">\[f(x-h)=f(x)-f&#39;(x)h+\frac{1}{2}f&#39;&#39;(x)h^2+...\]</span></p><h1 id="函数性态与方程的根">函数性态与方程的根</h1><blockquote><p>充分利用极值点、最值点的导数性质</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021634872.jpg" /></p><blockquote><p>以方程的根的形式表示函数</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021635112.jpg" /></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微分中值定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2024/09/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2024/09/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="模版">模版</h1><h2 id="合并集合">合并集合</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409020844713.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//寻找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(pa != pb) p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;<span class="comment">//初始化自己的根节点是自己</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x; <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;M&#x27;</span>)  <span class="built_in">Merge</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">Query</span>(a, b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><h2 id="食物链">食物链</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021052139.png" /></p><blockquote><p>与根节点一共有三种关系，用0表示和根节点是同类；1表示根节点吃该结点；2表示该结点吃根节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="type">int</span> n, k, res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];<span class="comment">//将所有结点直接连接根节点</span></span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">D1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(px != py)</span><br><span class="line">    &#123;</span><br><span class="line">        p[px] = py;</span><br><span class="line">        d[px] = d[y] - d[x];<span class="comment">//到根节点距离都是0，表示是同类</span></span><br><span class="line">        <span class="comment">//d[x]+ d[px]表示x到根节点的距离；d[y]表示y到根节点的距离</span></span><br><span class="line">        <span class="comment">//x的旧根节点即父节点，所以x到新根节点的距离等于x到旧根节点的距离+旧根节点到新根节点的距离</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((d[y] - d[x] + <span class="number">3</span>) % <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果x，y到根节点的距离不同，证明不是同类</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">D2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//x吃y -&gt; 相当于y吃根节点，根节点吃x，x吃y -&gt; x到根节点距离是1，y到根节点距离是2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(px != py)</span><br><span class="line">    &#123;</span><br><span class="line">        p[px] = py;</span><br><span class="line">        <span class="comment">//d[px] + d[x] = d[y] - 1</span></span><br><span class="line">        d[px] = (d[y] - d[x] - <span class="number">1</span> + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((d[x] - d[y] + <span class="number">1</span> + <span class="number">3</span>) % <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;<span class="comment">//初始化让自己的父节点是自己</span></span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c, x, y;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">D1</span>(x, y)) res++;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>) <span class="comment">//注意！！！不要写else！！！</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">D2</span>(x, y)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="格子游戏">格子游戏</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409021121546.png" /></p><blockquote><ol type="1"><li>将二维变成一维<span class="math inline">\((x,y)=x*n+y\)</span></li><li>将一条线的两端加入一个联通块，如果发现已经在一个联通块说明形成闭环</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span> * <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b; <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> x = (a - <span class="number">1</span>) * n + b, y;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;D&#x27;</span>) y = a * n + b;</span><br><span class="line">        <span class="keyword">else</span> y = (a - <span class="number">1</span>) * n + b + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(px == py)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[px] = py;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;draw&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序自动分析">程序自动分析</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409031846308.png" /></p><blockquote><ol type="1"><li>因为数据量很大，但实际上没有那么多的数据，所以需要离散化</li><li>将相等的放在同一个联通块中，再遍历不相等的，如果发现不相等的两个节点在同一个联通块就输出“NO”</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> t, n, idx;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; e, ue;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!H.<span class="built_in">count</span>(x)) H[x] = ++idx;</span><br><span class="line">    <span class="keyword">return</span> H[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        H.<span class="built_in">clear</span>(), e.<span class="built_in">clear</span>(), ue.<span class="built_in">clear</span>();</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            a = <span class="built_in">Hash</span>(a), b = <span class="built_in">Hash</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">1</span>)<span class="comment">//相等</span></span><br><span class="line">                e.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//不相等</span></span><br><span class="line">                ue.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; i++) p[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : e)</span><br><span class="line">            p[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>[x, y] : ue)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奇偶游戏">奇偶游戏</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409031949073.png" /></p><blockquote><ol type="1"><li>用sum[n]存储前n个数的和，那么<span class="math inline">\(S[l\simr]\)</span>有奇数个1<span class="math inline">\(\Leftrightarrow\)</span><span class="math inline">\(sum[l-1]\)</span>和<spanclass="math inline">\(sum[r]\)</span>奇偶性不同；<spanclass="math inline">\(S[l\sim r]\)</span>有偶数个1<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(sum[l-1]\)</span>和<spanclass="math inline">\(sum[r]\)</span>奇偶性相同</li><li>因为依次递推不止两种情况，所以用距离表示奇偶关系，<spanclass="math inline">\(d[x]=0\)</span>表示和根节点奇偶性相同，<spanclass="math inline">\(d[x]=1\)</span>表示和根节点奇偶性不同</li><li>使用异或^更新<span class="math inline">\(d[x]\)</span></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="type">int</span> n, m, idx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!H.<span class="built_in">count</span>(x)) H[x] = ++idx;</span><br><span class="line">    <span class="keyword">return</span> H[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] ^= d[p[x]];</span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        a = <span class="built_in">Hash</span>(a - <span class="number">1</span>), b = <span class="built_in">Hash</span>(b);</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa == pb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[a] ^ d[b] != t) </span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            <span class="comment">//d[b] ^ d[a] ^ d[pa] ^ t = 0</span></span><br><span class="line">            d[pa] = d[b] ^ d[a] ^ t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2024/09/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/09/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分查找">二分查找</h1><blockquote><p>手写二分</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到该数的左边界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; x)  l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[l] != x) l = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到该数的右边界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; x) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[r] != x) r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用STl</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="built_in">lower_bound</span>(a, a + n, x) - a;</span><br><span class="line">        <span class="type">int</span> p2 = <span class="built_in">upper_bound</span>(a, a + n, x) - a - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[p1] != x) p1 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[p2] != x) p2 = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浮点数二分</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> l = <span class="number">-1e4</span>, r = <span class="number">1e4</span>, mid;</span><br><span class="line"><span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (l + r) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt; n) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><h2 id="最佳牛围栏">最佳牛围栏</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011053068.png" /></p><blockquote><ol type="1"><li>如果用前缀和+暴力的话肯定会超时，那这题用什么算法呢？</li><li>这题的题意可以简化为：选择不少于f个数，让他们的平均值最大。是否可以使用二分，判断是否存在一个平均值大于mid的选择方式，如果存在那么可以在大于mid的范围内继续寻找，如果不存在就在小于mid的范围内寻找，直到找到最后的mid。因为数据范围是<spanclass="math inline">\(10^5\)</span>所以使用二分<spanclass="math inline">\(nlogn\)</span>不会超时</li></ol><p><spanclass="math inline">\(\color{red}{对于二分，二分是二分性而不是单调性只要满足可以找到一个值一半满足一半不满足即可而不用满足单调性}\)</span></p><ol start="3" type="1"><li><p>至少f个数这个条件要如何在二分中体现呢？要平均值最大，就需要<spanclass="math inline">\(s[i]\)</span>尽可能大，<spanclass="math inline">\(s[j-1]\)</span>尽可能小，题目要求的是至少f个，所以可以在<spanclass="math inline">\(s[1]\sim s[j -1]\)</span>范围内寻找最小值<code>min_val</code>，使用<code>s[i]-min_val</code>即可</p></li><li><p>要判断mid是否可行，由3可知我们并未记录这段区间有多少数，所以要怎么判断呢？我们可以让每个<spanclass="math inline">\(a[i]\)</span>都减去mid这个待判断的平均值，那么最后只需判断那个区间和0的大小即可</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> a[N], s[N];</span><br><span class="line"><span class="type">int</span> n, f;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a[i] - mid;</span><br><span class="line">    <span class="type">double</span> min_val = <span class="number">1e8</span>, ans = <span class="number">-1e8</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = f; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min_val = <span class="built_in">min</span>(min_val, s[i - f]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, s[i] - min_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans &gt;= <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; f;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], r = <span class="built_in">max</span>(r, a[i]);</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)(r * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和和差分</title>
      <link href="/2024/08/31/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/"/>
      <url>/2024/08/31/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前缀和">前缀和</h1><p><strong>一维前缀和：</strong></p><p><code>s[i] = s[i - 1] + a[i]</code></p><p>数列a中任意<span class="math inline">\(\text [l,r]\)</span>的和为<code>s[r] - s[l - 1]</code></p><p><strong>二维前缀和：</strong></p><p><code>s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]</code></p><p>求以<span class="math inline">\(\text (x1,y1)\)</span>为左上角，<span class="math inline">\(\text (x2,y2)\)</span>为右下角的子矩阵元素和<code>s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p><h1 id="差分">差分</h1><blockquote><p>差分序列的前缀和序列就是原序列，利用差分数组将“区间操作”变成“单点操作”</p></blockquote><p><strong>一维差分数组：</strong></p><p><code>dp[i] = a[i] - a[i - 1]</code></p><p>把a数组的[l,r]上的每个数加上c，则<code>dp[l] += c, dp[r + 1] -= c;</code></p><p>对差分数组求前缀和<code>a[i] = dp[i] + a[i - 1]</code></p><p><strong>二维差分数组：</strong></p><p><code>dp[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]</code></p><p>把矩阵中左上角为<span class="math inline">\(\texta[x1][y1]\)</span>右下角为<span class="math inline">\(\texta[x2][y2]\)</span>的小矩形中每个元素加上c，则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[x1][y1] += c;</span><br><span class="line">dp[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">dp[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">dp[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure><p>对差分矩阵求前缀和得原矩阵</p><p>即<code>a[i][j] = dp[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]</code></p><h1 id="应用">应用</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408311357754.png" /></p><blockquote><ol type="1"><li>利用差分，相当求让差分数组d，从<spanclass="math inline">\(d[2]\)</span>到<spanclass="math inline">\(d[n]\)</span>全部为0的最少步数</li><li>从<span class="math inline">\(i\)</span>到<spanclass="math inline">\(j\)</span>进行加c的操作共有三种情况<ol type="1"><li><span class="math inline">\(2\leq i,j\leq n\)</span>，那么<spanclass="math inline">\(d[i]+=c,d[j+1]-=c\)</span></li><li><span class="math inline">\(i=1,2\leq j\leq n\)</span>，那么<spanclass="math inline">\(d[j+1]-=c\)</span></li><li><span class="math inline">\(2\leq i&lt;n,j=n+1\)</span>，那么<spanclass="math inline">\(d[i]+=c\)</span></li></ol></li><li>求出从<span class="math inline">\(d[2]\)</span>到<spanclass="math inline">\(d[n]\)</span>中正数的和a以及负数的和b，共可以进行<spanclass="math inline">\(min(a,b)\)</span>次的1操作，剩余的<spanclass="math inline">\(|a-b|\)</span>次可以进行2/3操作</li><li>因为队列的情况等价于求<spanclass="math inline">\(d[1]\)</span>有多少中情况，那么根据2/3的操作，可以让<spanclass="math inline">\(b[1]\)</span>加/减0,1,2，……，<spanclass="math inline">\(|a-b|\)</span>共<spanclass="math inline">\(|a-b|+1\)</span>种情况</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[N], d[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], d[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    ll a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i] &lt; <span class="number">0</span>) a -= d[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[i] &gt; <span class="number">0</span>) b += d[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(a, b) + <span class="built_in">abs</span>(a - b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="built_in">abs</span>(a - b) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心--区间问题</title>
      <link href="/2024/08/31/%E8%B4%AA%E5%BF%83-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/31/%E8%B4%AA%E5%BF%83-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="区间选点">区间选点</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408310936296.png" /></p><blockquote><p>相当于问最少有多少重叠区间的集合，根据观察我们可以根据下一个区间左端点和上一个区间右端点的比较，判断是否有重叠，为了更好的比较就需要排序，那么就有两种解决方法：按右端点排序/按左端点排序</p></blockquote><p>按右端点排序：</p><blockquote><ol type="1"><li>因为是按右端点排序的，所以在<code>ed &gt;= e[i].l</code>的情况下，<code>ed &lt;= e[i].r</code>是一定的，所以不需要特殊判断</li><li><code>ed = e[i].r</code>需要放在判断条件的里面，因为这个公共点不在新扩展的那部分区域；如果放在判断条件外面，就相当于默认那段新展开的区域也是有选择的点的，但是那一段新展开的区域显然不是和前面的区间的公共段，所以那个选择的公共点不在新展开的区域</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edges&amp; W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; e[i].l &gt;&gt; e[i].r;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; e[i].l) </span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed = e[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按左端点排序：</p><blockquote><ol type="1"><li>在<code>ed &gt;= e[i].l</code>情况下，需要更新公共点所在区间</li><li>在<code>ed &lt; e[i].l</code>情况下，证明当前区域和之前的区域没有重叠区间，集合数加1，更新区间边界</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edges&amp; W)<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; e[i].l &gt;&gt; e[i].r;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>, ed = e[<span class="number">0</span>].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &gt;= e[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            ed = <span class="built_in">min</span>(ed, e[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed = e[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大不相交区间的数量">最大不相交区间的数量</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408310956232.png" /></p><blockquote><ol type="1"><li>按照前一题区间选点的方式，将所有区间分成几个集合，每个集合中的各个区间都有公共区域。</li><li>若要选择不相交的区域，不相交的区域一定在不同的集合里，所以总集合数就是最大不相交的区域，即区间选点的数量</li><li>和区间选点代码相同</li></ol></blockquote><h1 id="区间分组">区间分组</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408311034472.png" /></p><blockquote><p>引入小根堆，对区间右端点进行操作比较，如果当前区间的左端点大于最小的区间右端点，可以直接加入到已有的组；否则，新开一个组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edges&amp; W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; e[i].l &gt;&gt; e[i].r;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>() || q.<span class="built_in">top</span>() &gt;= e[i].l)   q.<span class="built_in">push</span>(e[i].r);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(e[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间覆盖">区间覆盖</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408311113196.png" /></p><blockquote><ol type="1"><li><p>按照区间左端点进行排序，在包含start点的所有区间中找到右端点最大的区间</p></li><li><p>判断条件</p><ol type="1"><li><p>如果左端点小于start，就将它的右端点和当前最大右端点进行比较</p></li><li><p>得到的最大右端点如果仍小于start，说明没有包含start的区间，break，res= -1</p></li><li><p>得到的最大右端点如果大于end，那么表示整个区间都被表示了，可以退出</p></li><li><p><spanclass="math inline">\(\color{red}{注意：}\)</span>因为可能存在</p><p>1 5</p><p>2</p><p>-1 2</p><p>2 4</p><p>这种情况，即待表示的区间右端点5大于目前拥有的区间的最大右端点，所以需要再大于end的情况下加一个判断，表示走到了结尾</p></li></ol></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edges&amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> n, s, t, res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; e[i].l &gt;&gt; e[i].r;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + n);</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, st= <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; e[j].l &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            st = <span class="built_in">max</span>(st, e[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st &lt; s) </span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">if</span>(st &gt;= t) </span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = st;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!success) res = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMC常用定理</title>
      <link href="/2024/08/26/CMC%E5%B8%B8%E7%94%A8%E5%AE%9A%E7%90%86/"/>
      <url>/2024/08/26/CMC%E5%B8%B8%E7%94%A8%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="stolz">Stolz</h1><blockquote><p>设数列<span class="math inline">\(\{a_n\}\)</span>与<spanclass="math inline">\(\{b_n\}\)</span>满足：</p><ol type="1"><li>（<span class="math inline">\(\frac{*}{\infty}\)</span>适用）<spanclass="math inline">\(\{b_n\}\)</span>严格单调递增，<spanclass="math inline">\(\lim\limits_{n\to \infty}b_n=+\infty\)</span></li><li>（<span class="math inline">\(\frac{0}{0}\)</span>适用）<spanclass="math inline">\(\{b_n\}\)</span>严格单调递减，<spanclass="math inline">\(\lim\limits_{n\to \infty}b_n=0\)</span>，<spanclass="math inline">\(\lim\limits_{n\to \infty}a_n=0\)</span></li></ol><p><spanclass="math inline">\(\lim\limits_{n\to\infty}\frac{a_{n+1}-a_n}{b_{n+1}-b_n}=A\)</span>（其中A可以是有限实数，也可以是<spanclass="math inline">\(+\infty\)</span>或者<spanclass="math inline">\(-\infty\)</span>，但不能是笼统的<spanclass="math inline">\(\infty\)</span>），那么，<spanclass="math inline">\(\lim\limits_{n\to\infty}\frac{a_n}{b_n}=A\)</span></p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409191635639.jpg" /></p><h1 id="三角求和">三角求和</h1><p><span class="math display">\[2\sin \alpha\cos \beta =\sin({\alpha+\beta})+\sin(\alpha -\beta)\]</span></p><p><span class="math display">\[2\cos \alpha\sin \beta =\sin({\alpha+\beta})-\sin(\alpha -\beta)\]</span></p><p><span class="math display">\[2\sin \alpha\sin \beta =\cos({\alpha-\beta})-\cos(\alpha +\beta)\]</span></p><p><span class="math display">\[2\cos \alpha\cos \beta =\cos({\alpha+\beta})+\cos(\alpha -\beta)\]</span></p><p><span class="math display">\[\sin A + \sin B =2\sin\left(\frac{A+B}{2}\right)\cos\left(\frac{A-B}{2}\right)\]</span></p><p><span class="math display">\[\sin A - \sin B =2\cos\left(\frac{A+B}{2}\right)\sin\left(\frac{A-B}{2}\right)\]</span></p><p><span class="math display">\[\cos A + \cos B =2\cos\left(\frac{A+B}{2}\right)\cos\left(\frac{A-B}{2}\right)\]</span></p><p><span class="math display">\[\cos A - \cos B =-2\sin\left(\frac{A+B}{2}\right)\sin\left(\frac{A-B}{2}\right)\]</span><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409191635232.jpg" /></p><h1 id="abel分布求和">Abel分布求和</h1><blockquote><p>记<spanclass="math inline">\(A_n=\sum\limits_{k=1}^{n}a_k\)</span>，<spanclass="math inline">\(A_0=0\)</span>，则<spanclass="math inline">\(\sum\limits_{k=1}^na_kb_k=A_nb_n-\sum\limits_{k=1}^{n-1}A_k(b_{k+1}-b_k)\)</span></p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409191635565.jpg" /></p><h1 id="伯努利不等式">伯努利不等式</h1><p><spanclass="math display">\[当x_i(i=1,2,...,n)&gt;-1，且符号相同时，(1+x_1)(1+x_2)...(1+x_n)\geq1+x_1+x_2+...+x_n\]</span></p><p>证明：</p><p><spanclass="math display">\[a_n=(1+x_1)(1+x_2)...(1+x_n)-(1+x_1+x_2+...+x_n)\]</span></p><p><spanclass="math display">\[a_{n+1}-a_n=x_{n+1}[(1+x_1)(1+x_2)...(1+x_n)-1]\]</span></p><p><spanclass="math display">\[若x_i&gt;0,a_{n+1}&gt;a_n,a_1=0，所以a_n&gt;0，不等式成立\]</span></p><p><spanclass="math display">\[若-1&lt;x_1&lt;0,(1+x_1)(1+x_2)...(1+x_n)-1&lt;0,a_{n+1}&gt;a_n,a_1=0，所以a_n&gt;0，不等式成立\]</span></p><h1 id="琴生不等式">琴生不等式</h1><p>凸函数性质：</p><p><span class="math display">\[f(\lambda a+(1-\lambda)b)\leq \lambdaf(a)+(1-\lambda)f(b)\]</span></p><p>琴生不等式：（利用归纳法证明）</p><p><span class="math display">\[f(a_1x_1+a_2x_2+...+a_nx_n)\leqa_1f(x_1)+a_2f(x_2)+...+a_nf(x_n)\]</span></p><p>特别的：</p><p><spanclass="math display">\[f(\frac{x_1+x_2+...+x_n}{n})\leq\frac{f(x_1)+f(x_2)+...+f(x_n)}{n}\]</span></p><h3 id="定理">定理：</h3><p>若函数<span class="math inline">\(f(x)\)</span>是<spanclass="math inline">\([a,b]\)</span>上的可积函数，且<spanclass="math inline">\(m\leq f(x)\leq M\)</span>，又<spanclass="math inline">\(g(x)\)</span>是上的连续下凸函数，则有</p><p><span class="math display">\[g(\frac{1}{b-a}\int_a^bf(x)dx)\leq\frac{1}{b-a}\int_a^bg(f(x))dx\]</span></p><h1 id="young不等式">young不等式</h1><p>若<span class="math inline">\(a,b&gt;0,p,q&gt;0\)</span>且<spanclass="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>，则有<spanclass="math inline">\(ab\leq\frac{a^p}{p}+\frac{b^q}{q}\)</span></p><p>证明：</p><p><span class="math display">\[因为f(x)=\lnx是凸函数，所以\ln(\frac{a^p}{p}+\frac{b^q}{q})\geq \frac{1}{p}\lna^p+\frac{1}{q}\ln b^q=\ln ab\]</span></p><h1 id="cauchy-schwarz不等式">Cauchy-Schwarz不等式</h1><h2 id="二维离散形式">二维离散形式</h2><p><span class="math display">\[(ac+bd)^2\leq(a^2+b^2)(c^2+d^2)\]</span></p><h2 id="定理1">定理1</h2><p><span class="math display">\[(\int_a^bf(x)g(x)dx)^2\leq\int_a^bf^2(x)dx\cdot \int_a^bg^2(x)dx\]</span></p><p>证明：（判别式法）</p><p><span class="math display">\[(f(x)+\lambda g(x))^2\geq 0\]</span></p><p><span class="math display">\[\Delta \geq 0\]</span></p><h2 id="推论1">推论1</h2><p>设二元函数<spanclass="math inline">\(f(x,y),g(x,y)\)</span>在平面区域D上可积，则成立不等式</p><p><span class="math display">\[(\iint\limits_D f(x,y)g(x,y)dxdy)^2\leq\iint\limits_D f^2(x,y)dxdy\cdot \iint\limits_Dg^2(x,y)dxdy\]</span></p><p>等号成立的条件为存在常数k使得<spanclass="math inline">\(f(x,y)=kg(x,y)\)</span></p><h2 id="推论2">推论2</h2><p>设二元函数<spanclass="math inline">\(f(x,y),g(x,y)\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，且连续函数<spanclass="math inline">\(h(x)\geq 0\)</span>连续，则成立不等式</p><p><span class="math display">\[(\int_a^b f(x)g(x)h(x)dx)^2\leq \int_a^bf^2(x)h(x)dx\cdot \int _a^b g^2(x)h(x)dx\]</span></p><p>等号成立的条件为存在常数k使得<spanclass="math inline">\(f(x,y)=kg(x,y)\)</span></p><h2 id="推论3">推论3</h2><p>设二元函数<spanclass="math inline">\(f(x,y)\)</span>在平面区域D内非负可积，且可积函数<spanclass="math inline">\(g(x,y)\geq m&gt;0\)</span>，则不等式</p><p><spanclass="math display">\[(\iint\limits_Df(x,y)dxdy)^2\leq\iint\limits_Df(x,y)g(x,y)dxdy\cdot\iint\limits_D\frac{f(x,y)}{g(x,y)}dxdy\]</span></p><p>或者</p><p><spanclass="math display">\[(\iint\limits_Df(x,y)dxdy)^2\leq\iint\limits_Dg(x,y)dxdy\cdot\iint\limits_D\frac{f^2(x,y)}{g(x,y)}dxdy\]</span></p><h2 id="推论4holder不等式">推论4（Holder不等式）</h2><p>设函数<span class="math inline">\(f(x),g(x)\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上可积，则有</p><p><span class="math display">\[\int_a^bf(x)g(x)dx\leq(\int_a^bf^p(x)dx)^{\frac{1}{p}}(\int_a^bg^q(x)dx)^{\frac{1}{q}}\]</span></p><p>其中<spanclass="math inline">\(\frac{1}{p}+\frac{1}{q}=1,p,q&gt;0\)</span></p><p>证明：利用young不等式</p><h2 id="推论5minkovski不等式">推论5（Minkovski不等式）</h2><p>设函数<span class="math inline">\(f(x),g(x)\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上可积，<spanclass="math inline">\(p\geq 1\)</span>，则有</p><p><spanclass="math display">\[(\int_a^b[f(x)+g(x)]^pdx)^{\frac{1}{p}}\leq(\int_a^bf^p(x)dx)^{\frac{1}{p}}+(\int_a^bg^p(x)dx)^\frac{1}{p}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMC级数</title>
      <link href="/2024/08/26/CMC%E7%BA%A7%E6%95%B0/"/>
      <url>/2024/08/26/CMC%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用结论">常用结论</h1><p><span class="math display">\[H_n=1+\frac{1}{2}+...+\frac{1}{n}=\lnn+\gamma+\varepsilon_n\sim \ln n\]</span></p><p><spanclass="math display">\[H_n=1+\frac{1}{2^{\alpha}}+...+\frac{1}{n^{\alpha}}\sim\frac{1}{1-\alpha}n^{1-\alpha}\]</span></p><p><spanclass="math display">\[\sum\limits_{n=2}^{\infty}\frac{1}{n\ln^pn},\sum\limits_{n=3}^{\infty}\frac{1}{n\lnn(\ln\ln n)^p},\sum\limits_{n=2}^{\infty}\frac{\lnn}{n^p}，仅当p&gt;1时收敛\]</span></p><h1 id="解题技巧">解题技巧</h1><h2 id="数列与级数的转换">数列与级数的转换</h2><blockquote><p>数列<span class="math inline">\(\{x_n\}\)</span>收敛<spanclass="math inline">\(\Leftrightarrow\)</span>级数<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}(x_{n+1}-x_n)\)</span>收敛，且<spanclass="math inline">\(\lim\limits_{n\to\infty}x_n=x_1+\sum\limits_{n=1}^{\infty}(x_{n+1}-x_n)\)</span></p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011926694.jpg" /></p><h2 id="运用裂项">运用裂项</h2><p><span class="math display">\[\arctan\frac{a-b}{1+ab}=\arctana-\arctan b\]</span></p><p><spanclass="math display">\[\frac{n}{(2n+1)!!}=\frac{1}{2}(\frac{1}{(2n-1)!!}-\frac{1}{(2n+1)!!})\]</span></p><p><spanclass="math display">\[\ln\frac{n^3-1}{n^3+1}=\ln\frac{(n-1)(n^2+n+1)}{(n+1)(n^2-n+1)}=\ln\frac{n(n+1)+1}{n(n+1)}-\ln\frac{(n-1)n+1}{(n-1)n}\]</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011926774.jpg" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011926383.jpg" /></p><h1 id="判断敛散性">判断敛散性</h1><h2 id="利用积分估计">利用积分估计</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011926781.jpg" /></p><h2 id="abel-dini">Abel-Dini</h2><p><spanclass="math display">\[设正项级数\sum\limits_{n=1}^{\infty}u_n发散，S_n=u_1+u_2+...+u_n，则p&gt;1时，级数\sum\limits_{n=1}^{\infty}\frac{u_n}{S_n^p}收敛；p\leq1时，级数\sum\limits_{n=1}^{\infty}\frac{u_n}{S_n^p}发散\]</span></p><p><spanclass="math display">\[设正项级数\sum\limits_{n=1}^{\infty}u_n收敛，S_n=u_1+u_2+...+u_n，则p&lt;1时，级数\sum\limits_{n=1}^{\infty}\frac{u_n}{S_n^p}收敛；p\geq1时，级数\sum\limits_{n=1}^{\infty}\frac{u_n}{S_n^p}发散\]</span></p><p>证明：<imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011926833.jpg" /></p><p>应用：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011927623.jpg" /></p><h2 id="kummer判别法">Kummer判别法</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409011927575.jpg" /></p><h2 id="raabe判别法">Raabe判别法</h2><p><span class="math display">\[设u_n&gt;0,且n(\frac{u_n}{u_{n+1}}-1)\tor,则\sum u_n,当r&gt;1时收敛，r&lt;1时发散\]</span></p><p><spanclass="math display">\[比较定理：正项级数\sum\limits_{n=1}^{\infty}u_n,\sum\limits_{n=1}^{\infty}v_n,若\frac{u_{n+1}}{u_n}\leq\frac{v_{n+1}}{v_n}，则\sum\limits_{n=1}^{\infty}u_n收敛可得\sum\limits_{n=1}^{\infty}v_n收敛\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing动态规划提高版</title>
      <link href="/2024/08/25/AcWing%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%8F%90%E9%AB%98%E7%89%88/"/>
      <url>/2024/08/25/AcWing%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%8F%90%E9%AB%98%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数字三角形模型">数字三角形模型</h1><h2 id="方格取数">方格取数</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408251124285.png" /></p><blockquote><p>分析：</p><ol type="1"><li><p>因为要走两次，并且走之后会重新更新为0，所以让两个同时走</p></li><li><p>如果要同时走，就需要四维，如何优化呢？根据观察，因为两者同时走，所以走的步数是一样的，即<spanclass="math inline">\(i1+j1=i2+j2\)</span>，所以可以设置一维是<spanclass="math inline">\(k,k=i1+j1=i2+j2\)</span>，就优化成了三维</p></li><li><p>通过判断<span class="math inline">\(i1\)</span>是否等于<spanclass="math inline">\(i2\)</span>，决定最终要加几次权重</p></li><li><p>因为<spanclass="math inline">\(i1,i2\)</span>都有可能从上或者左来，所以一共有4种状态</p></li><li><p>状态计算：<spanclass="math inline">\(f(k,i1,i2)=max(f(k-1,i1-1,i2-1),f(k-1,i1-1,i2),f(k-1,i1,i2-1),f(k-1,i1,i2))+w[i][j]\)</span></p><p>（依次表示都从上，i1从上i2从左，i1从左i2从上，都从左）</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span> * N][N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; x &gt;&gt; y &gt;&gt; z, x | y | z) g[x][y] = z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">2</span> * n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span>(j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    <span class="type">int</span> t = g[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1 != i2) t += g[i2][j2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">2</span> * n][n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传纸条">传纸条</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408251311381.png" /></p><blockquote><p>方格取数是同向一起走，传纸条是相向先后走，为什么所用的代码是一样的呢？</p></blockquote><p>~<imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408251314715.png" /></p><blockquote><p>既然答案中的i1一定不等于i2，为什么代码中还要写出来呢？</p><p>因为不想交的线是由相交的线得到的，所以相交的线是构成最优的必须过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span> * N][N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n + m; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= m; i1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= m; i2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span>(j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    <span class="type">int</span> t = g[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1 != i2) t += g[i2][j2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m + n][m][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长上升子序列">最长上升子序列</h1><h2 id="合唱队形">合唱队形</h2><figure><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408251432948.png"alt="image-20240825143237926" /><figcaption aria-hidden="true">image-20240825143237926</figcaption></figure><blockquote><p>分两步：先求以每个节点为结尾的最长上升子序列，再求以每个节点开始的最长下降子序列；最后相加即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> h[N], f[N], uf[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(h[j] &lt; h[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        uf[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">            <span class="keyword">if</span>(h[j] &lt; h[i]) uf[i] = <span class="built_in">max</span>(uf[i], uf[j] + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, f[i] + uf[i] - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; n - ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截导弹">拦截导弹</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408281601434.png" /></p><blockquote><p>方法一：</p><ol type="1"><li>第一问即求最长不上升子序列的长度</li><li>第二问要求最少有多少个不上升的子序列，可以<spanclass="math inline">\(\color{red}{等价于求最长上升子序列的长度}\)</span>（还不会证明QAQ）</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N], f[N], g[N];</span><br><span class="line"><span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans1, ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; w[n]) n++;</span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>, g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[j] &gt;= w[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>  g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans1 = <span class="built_in">max</span>(ans1, f[i]);</span><br><span class="line">        ans2 = <span class="built_in">max</span>(ans2, g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; ans2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法二：（第二问）</p><ol type="1"><li>维护一个所有子序列末尾的子弹高度的非递减数组</li><li>如果新的导弹高度高于现在最高的结尾高度，那就新开一个空间放这个导弹</li><li>如果新的导弹高度低于现在最高的结尾高度，找到大于它的最小高度，加在这个的后面，并修改最高高度</li><li>求大于它的最小值，可以使用二分进行优化</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> h[N], f[N], g[N];</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> ans1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; h[++n]);</span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第一问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(h[j] &gt;= h[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            ans1 = <span class="built_in">max</span>(ans1, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//第二问</span></span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lower_bound</span>(g, g + cnt, h[i]) - g;<span class="comment">//找到第一个大于h[i]的地方</span></span><br><span class="line">        <span class="keyword">if</span>(x == cnt) g[cnt++] = h[i];</span><br><span class="line">        <span class="keyword">else</span> g[x] = h[i];</span><br><span class="line">        cnt = <span class="built_in">max</span>(x, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL之bound</title>
      <link href="/2024/08/20/STL%E4%B9%8Bbound/"/>
      <url>/2024/08/20/STL%E4%B9%8Bbound/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lower_bound左边界取等">lower_bound（左边界取等）</h1><blockquote><p>在从小到大排序的数组中：lower_bound(begin, end, num)</p></blockquote><p>从数组的begin位置到end - 1位置二分查找第一个<spanclass="math inline">\(\color{red}{大于或等于}\)</span>num的数，找到返回该数的地址，不存在返回end；通过返回的地址减去begin，得到数字在数组中的下标</p><blockquote><p>在从大到小排序的数组中：lower_bound(begin ,end, num,greater<type>())</p></blockquote><p>从数组的begin位置到end - 1位置二分查找第一个<spanclass="math inline">\(\color{red}{小于或等于}\)</span>num的数</p><h1 id="upper_bound">upper_bound</h1><blockquote><p>在从小到大排序的数组中：upper_bound(begin, end, num)</p></blockquote><p>从数组的begin位置到end - 1位置二分查找第一个<spanclass="math inline">\(\color{red}{大于}\)</span>num的数，找到返回该数的地址，不存在返回end；通过返回的地址减去begin，得到数字在数组中的下标</p><blockquote><p>在从大到小排序的数组中：upper_bound(begin ,end, num,greater<type>())</p></blockquote><p>从数组的begin位置到end - 1位置二分查找第一个<spanclass="math inline">\(\color{red}{小于}\)</span>num的数</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2024/08/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背包">01背包</h1><blockquote><p>每个物品只能拿一次，求拿总容量不超过V的物品能得到的最大价值</p></blockquote><ol type="1"><li><p>二维状态方程：<code>f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i])</code>，</p><ul><li><code>f[i][j]</code>前i个物品中容量不超过j的最大价值</li><li><code>f[i-1][j]</code>表示不选第i个物品时，等价于求前i-1个物品容量不超过j的最大价值</li><li><code>f[i-1][j-v[i]]+w[i]</code>，表示选第i个物品，则容量减去v[i]，价值加上w[i]</li></ul></li><li><p>因为第i次的结果都是由第i-1次推出来的，所以可以用一维状态方程进行表示</p><p>一维状态方程：<code>f[j]=max(f[j], f[j-v[i]]+w[i])</code></p></li><li><p>如果直接按照二维的正向遍历方式遍历一维，是否等价呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以二维的方式正向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j], f[j-v[i]]+w[i])</span><br></pre></td></tr></table></figure><ul><li>假设<code>m = 5, v[1] = 1</code>，当外层循环到 i 的时候，内层的 j循环1 2 3 4 5</li><li>当<code>j = 2</code>时，判断<code>f[2] = max(f[2], f[1] + w[i])</code>，假设这里的<code>f[2]</code>更新了</li><li>当<code>j = 3</code>时，判断<code>f[3] = max(f[3], f[2] + w[i])</code>，这里的<code>f[2]</code>用的是刚刚更新的，即<code>f[i][2]</code>，而并不是上一层的<code>f[i-1][2]</code>，因为上一层的<code>f[i-1][2]</code>已经被更新成当前层的<code>f[i][2]</code></li><li>所以，因为我们是根据上一层更新下一层，所以采用逆序遍历的方式可以避免上一层使用时已经被更新</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以逆序的方式正向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j++)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j], f[j-v[i]]+w[i])</span><br></pre></td></tr></table></figure><p>完整代码：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包">完全背包</h1><blockquote><p>每个物品可以使用无数次，求拿总容量不超过V的物品能得到的最大价值</p></blockquote><ol type="1"><li><p>与01背包不同的是，它的物品可以使用无限次</p></li><li><p>二维状态方程（后面的式子中<code>v</code>表示<code>v[i]</code>，<code>w</code>表示<code>w[i]</code>）：<code>f[i][j] = max(f[i-1][j], f[i][j-v]+w)</code></p><p>推导：</p><ul><li><code>f[i][j] = max(f[i-1][j], f[i-1][j-v]+w,f[i-1][j-2v]+2w,……)</code></li><li><code>f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v]+w,f[i-1][j-3v]+2w),……</code></li><li>由前两个式子可知：<code>f[i][j] = max(f[i-1][j], f[i][j-v]+w)</code></li></ul></li><li><p>一维状态方程：<code>f[j] = max(f[j], f[j-v]+w)</code></p></li><li><p>因为我们需要的就是<code>f[i][j-v]</code>，所以正向遍历即可</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)<span class="comment">//与01背包代码唯一不同的地方</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多重背包">多重背包</h1><blockquote><p>每个物品只能拿一次，每个物品最多有s件，求拿总容量不超过V的物品能得到的最大价值</p></blockquote><ol type="1"><li>如果按朴素的做法，直接每次遍历s遍即可，但是这样的时间复杂度是<spanclass="math inline">\(O(n^3)\)</span>，太大</li><li>我们设想，将s件相同的物品当做独立的个体，即即使是相同的物品也视为不同的物品，那么该问题就变成了01背包问题</li><li>但是如果s的范围过大，就会导致超时，所以可以利用二进制的思想<ul><li>一个数s，最少需要多少个数可以将比s小的数都表示出来？</li><li>答案是<spanclass="math inline">\(log_2s\)</span>，以二进制的形式表示s，则每一位有取或者不取，如果s恰好是2的次方，那么可以直接用log()，但是如果不是，可以将最后一个“剩余”的数单独提出来，就可以表示完整的所有比s小的数了</li></ul></li><li>将s“拆分”后，使用01背包进行解题即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * k, w[cnt] = b * k;</span><br><span class="line">            s -= k, k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分组背包">分组背包</h1><blockquote><p>每组有若干个物品，每组只能选一个物品，求拿总容量不超过V的物品能得到的最大价值</p></blockquote><ol type="1"><li>一维状态方程：<code>f[j] = max(f[j], f[j-v[1]]+w[1], f[j-v[2]]+w[2],……)</code><ul><li><code>f[j]</code>表示这一组不取</li><li><code>f[j-v[1]]</code>表示这一组取第一个</li><li>以此类推</li></ul></li><li>直接三层循环遍历即可，因为是01背包的变式（只能取1个），所以<code>j</code>用逆序遍历</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing动态规划模版题</title>
      <link href="/2024/08/19/AcWing%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E7%89%88%E9%A2%98/"/>
      <url>/2024/08/19/AcWing%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E7%89%88%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背包问题">背包问题</h1><h2 id="背包">01背包</h2><blockquote><p>每个物品只能拿一次，求拿容量不超过V的物品能得到的最大价值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><blockquote><p>每个物品可以使用无数次，求拿容量不超过V的物品能得到的最大价值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)<span class="comment">//与01背包代码唯一不同的地方</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包">多重背包</h2><blockquote><p>每个物品只能拿一次，每个物品最多有s件，求拿总容量不超过V的物品能得到的最大价值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * k, w[cnt] = b * k;</span><br><span class="line">            s -= k, k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包">分组背包</h2><blockquote><p>每组有若干个物品，每组只能选一个物品，求拿总容量不超过V的物品能得到的最大价值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性dp">线性Dp</h1><h2 id="数字三角形">数字三角形</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408200914731.png" /></p><blockquote><p>方式一：从上往下“走”</p><ol type="1"><li>状态表示：<span class="math inline">\(f(i, j)\)</span><ul><li>集合：从<span class="math inline">\((1, 1)\)</span>到<spanclass="math inline">\((i, j)\)</span>的所有情况</li><li>属性：MAX</li></ul></li><li>状态计算<ul><li>这条路可以从<span class="math inline">\(f(i - 1,j)\)</span>走上来，也可以从<spanclass="math inline">\(f(i-1,j-1)\)</span>走上来</li><li>所以，<spanclass="math inline">\(f(i,j)=max(f(i-1,j),f(i-1,j-1))+g(i,j)\)</span></li></ul></li><li>答案：根据定义答案就是<spanclass="math inline">\(max(f[n][i])\)</span></li></ol><p><spanclass="math inline">\(\color{Red}{注意：}\)</span>因为存在边界的情况，所以需要初始化为<spanclass="math inline">\(-\infty\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j++)</span><br><span class="line">            f[i][j] = <span class="number">-1e9</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + g[i][j];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方式二：从下往上“走”</p><ol type="1"><li>状态表示：<span class="math inline">\(f(i,j)\)</span><ul><li>集合：从<span class="math inline">\((i,j)\)</span>到<spanclass="math inline">\((1,1)\)</span></li><li>属性：MAX</li></ul></li><li>状态计算<ul><li>这条路可以从<spanclass="math inline">\(f(i+1,j)\)</span>走上来，也可以从<spanclass="math inline">\(f(i+1,j+1)\)</span>走上来</li><li><spanclass="math inline">\(f(i,j)=max(f(i+1,j),f(i+1,j+1))+g(i,j)\)</span></li></ul></li><li>答案：<span class="math inline">\(f(1,1)\)</span></li></ol><p><spanclass="math inline">\(\color{red}{注意：}\)</span>因为是从下往上的遍历，边界都包括在内，不用考虑边界情况</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + g[i][j];</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列">最长上升子序列</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408200954016.png" /></p><blockquote><p>方式一：时间复杂度<span class="math inline">\(O(n^2)\)</span></p><ol type="1"><li>状态表示：<span class="math inline">\(f(i)\)</span><ul><li>集合：表示以<spanclass="math inline">\(w[i]\)</span>结尾的最大上升子序列</li><li>属性：MAX</li></ul></li><li>状态计算<ul><li>以i之前的、权值小于i的节点结尾的上升子序列的最大值 + 1</li><li><span class="math inline">\(f(i) = max(f(j)+1)\)</span>，其中<spanclass="math inline">\(w[j]&lt;w[i],j&lt;i\)</span></li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N], f[N];</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; w[j]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);<span class="comment">//找到以比w[i]小的节点结尾的最长上升子序列</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方式二：时间复杂度<span class="math inline">\(O(nlogn)\)</span></p><ol type="1"><li>状态表示<span class="math inline">\(f(i)\)</span><ul><li>集合：表示长度为i的序列的最小结尾</li><li>属性：序列中最后一个值的最小值</li></ul></li><li>状态计算：<ul><li>如果<span class="math inline">\(w[i]\)</span>大于<spanclass="math inline">\(f(cnt)\)</span>，直接加到cnt之后即可</li><li>如果小于等于<spanclass="math inline">\(f(cnt)\)</span>，找到f数组中第一个大于<spanclass="math inline">\(w[i]\)</span>的位置，进行替换</li></ul></li><li>答案：f数组的长度</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> w[N], f[N];</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i];</span><br><span class="line">    f[++cnt] = w[<span class="number">1</span>];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i] &gt; f[cnt]) f[++cnt] = w[i];</span><br><span class="line">        <span class="keyword">else</span> f[<span class="built_in">lower_bound</span>(f + <span class="number">1</span>, f + cnt + <span class="number">1</span>, w[i]) - f] = w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列">最长公共子序列</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408201136589.png" /></p><blockquote><p>状态表示：<span class="math inline">\(f(i,j)\)</span></p><ol type="1"><li>集合：表示A的前i个字符，B的前j个字符的公共子序列的最长长度</li><li>属性：min</li></ol><p>状态计算：</p><ol type="1"><li><span class="math inline">\(a[i] == b[j]\)</span>，<spanclass="math inline">\(a[i],b[j]\)</span>都在，那么最长子序列的长度是前一个+ 1，即<span class="math inline">\(f[i-1][j-1]+1\)</span></li><li><span class="math inline">\(a[i]!=b[j]\)</span><ul><li><span class="math inline">\(a[i]\)</span>在，<spanclass="math inline">\(b[j]\)</span>不在：那就是算A的前i个字符，B的前i -1个字符的公共子序列的最长长度，即<span class="math inline">\(f[i][j -1]\)</span></li><li><span class="math inline">\(a[i]\)</span>不在，<spanclass="math inline">\(b[j]\)</span>在：那就是算A的前i -1个字符，B的前i个字符的公共子序列的最长长度，即<spanclass="math inline">\(f[i-1][j]\)</span></li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短编辑距离">最短编辑距离</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408201136949.png" /></p><blockquote><p>状态表示：<span class="math inline">\(f(i,j)\)</span></p><ol type="1"><li>集合：表示<span class="math inline">\(A[1\sim i]\)</span>转换到<spanclass="math inline">\(B[1\sim j]\)</span>最少操作次数</li><li>属性：min</li></ol><p>状态计算：</p><ol type="1"><li>删：保证<span class="math inline">\(A[1\sim i-1]\)</span>和<spanclass="math inline">\(B[1\sim j]\)</span>匹配，即<spanclass="math inline">\(f[i-1][j]\)</span></li><li>替：保证<span class="math inline">\(A[1\sim i-1]\)</span>和<spanclass="math inline">\(B[1\sim j-1]\)</span>匹配，即<spanclass="math inline">\(f[i-1][j-1]\)</span></li><li>补：保证<span class="math inline">\(A[1\sim i]\)</span>和<spanclass="math inline">\(B[1\sim j-1]\)</span>匹配，即<spanclass="math inline">\(f[i][j-1]\)</span></li></ol><p>总结：<span class="math inline">\(f[i][j] =min(f[i-1][j-1]+1,f[i-1][j]+1,f[i][j-1]+1)\)</span></p><p>初始化：</p><ol type="1"><li><span class="math inline">\(f[0][i]\)</span>只能进行”补“操作</li><li><span class="math inline">\(f[i][0]\)</span>只能进行“删”操作</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a + <span class="number">1</span> &gt;&gt; m &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//if(a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);</span></span><br><span class="line">            <span class="comment">//else f[i][j] = min(f[i][j], f[i - 1][j - 1]);</span></span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间dp">区间Dp</h1><h2 id="石子合并">石子合并</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408231259768.png" /></p><blockquote><p>状态表示：<span class="math inline">\(f(i, j)\)</span></p><ol type="1"><li>集合：表示合并区间从i到j的最小代价</li><li>属性：min（记得初始化为<spanclass="math inline">\(\infty\)</span>）</li></ol><p>状态计算：</p><ol type="1"><li><p>涉及区间和问题，使用前缀和</p></li><li><p><span class="math inline">\(f(i,j) =f(i,k)+f(k+1,j)+s[j]-s[i-1]\)</span></p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> f[N][N], a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            f[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + a[j] - a[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数类dp">计数类Dp</h1><h2 id="整数划分">整数划分</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408231315817.png" /></p><blockquote><p>分析：可以看成完全背包问题的变式，把1,2,3，……，n看做n个物品，每个物品可以取无限次，问刚好取到体积为n的方案数</p><p>状态表示：f(i, j)</p><ol type="1"><li>集合：表示前i个物品体积恰好为j的方案数</li><li>属性：所有相加</li></ol><p>状态计算：</p><p><span class="math inline">\(f(i,j) =f(i-1,j)+f(i-1,j-i)+f(i-1,j-2i),……\)</span></p><p><spanclass="math inline">\(f(i,j-i)=f(i-1,j-i)+f(i-1,j-2i)+f(i-1,j-3i)+……\)</span></p><p><span class="math inline">\(\to\)</span><spanclass="math inline">\(f(i,j)=f(i-1,j)+f(i,j-i)\)</span></p><p>省去第一维：<span class="math inline">\(f(j)=f(j)+f(j-i)\)</span></p><p>初始化：</p><p>当一件都不选的时候方案数是1，所以<spanclass="math inline">\(f[0]=1\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    cout &lt;&lt; f[n];   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数位统计dp">数位统计Dp</h1><h2 id="计数问题">计数问题</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408231537747.png" /></p><blockquote><p>分析：</p><ol type="1"><li><p>将<span class="math inline">\(a\sim b\)</span>中<spanclass="math inline">\(1\sim9\)</span>出现的次数转换成<spanclass="math inline">\(1\sim a-1\)</span>和<spanclass="math inline">\(1\sim b\)</span>中每个数字出现的次数</p></li><li><p>对于求abcdefg中t在第4位出现的次数</p><p>例子：1 &lt;= xxxtyyy &lt;= abcdefg</p><ol type="1"><li>xxx = 0 ~ abc - 1, yyy = 000 ~ 999，次数：abc * 1000</li><li>xxx = abc<ol type="1"><li>d == t，yyy = 000 ~ efg ，次数：efg + 1</li><li>d &gt; t，yyy = 000 ~ 999，次数：10^3</li><li>d &lt; t，不成立</li></ol></li></ol></li><li><p>对于t是否等于0，如果是0，它不可能在首位，在算某一位数前面的xxx的时候，需要减去前面全是0的情况</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &gt;= r; i--)</span><br><span class="line">        res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow10</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">        ans *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        num[++len] = n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i != len) ans += <span class="built_in">get_num</span>(len, i + <span class="number">1</span>) * <span class="built_in">pow10</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num[i] == x) ans += <span class="built_in">get_num</span>(i- <span class="number">1</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] &gt; x) ans += <span class="built_in">pow10</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += (<span class="built_in">get_num</span>(len, i + <span class="number">1</span>) - <span class="number">1</span>) * <span class="built_in">pow10</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num[i] == x) ans += <span class="built_in">get_num</span>(i- <span class="number">1</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] &gt; x) ans += <span class="built_in">pow10</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b) &amp;&amp; a !=<span class="number">0</span> &amp;&amp; b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">work</span>(b, i) - <span class="built_in">work</span>(a - <span class="number">1</span>, i);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="状态压缩dp">状态压缩Dp</h1><blockquote><p>充分利用二进制</p></blockquote><h2 id="蒙德里安的梦想">蒙德里安的梦想</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408241103004.png" /></p><blockquote><p>分析：一旦横着摆放的地方确定了，那么竖着摆放的地方就确定了。所以，最终的方案数就是横着摆放的方案数</p><p>状态表示：<span class="math inline">\(f(i,j)\)</span></p><ol type="1"><li>我们按照列进行摆放，每一列由上一列更新</li><li>状态数：每一列的某行为1，表示横放，并伸出到下一列；某行为0，表示竖放或者由上一列伸出</li><li><spanclass="math inline">\(f(i,j)\)</span>表示第i行，状态数为j时的方案数；其中状态数j是01组成的二进制数</li></ol><p>状态计算：</p><ol type="1"><li><span class="math inline">\(f(i,j)=\sumf(i-1,k)\)</span>表示第i-1列的所有合法方案数之和</li><li>初值：<span class="math inline">\(f[0][0] =1\)</span>，第0列没有横放的</li><li>答案：<span class="math inline">\(f[m][0]\)</span></li></ol><p>判断是否合法：</p><ol type="1"><li>上一列横放伸出的地方为1，那么这一列的这一行只能是0，即<code>j &amp; k == 0</code></li><li>连续零的个数是偶数</li></ol><p>提前初始化：</p><ul><li>根据上述两个规则初始化st数组，将所有状态是否合法列举出来</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll f[N][M];</span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//记录每一列中连续0的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    st[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;<span class="comment">//判断前导零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态计算</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//枚举列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)<span class="comment">//枚举第i列的状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k++)<span class="comment">//枚举第i-1列的状态</span></span><br><span class="line">                <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k]) f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">    <span class="keyword">return</span> f[m][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n | m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">work</span>(n, m) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短hamilton路径">最短Hamilton路径</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408241236070.png" /></p><blockquote><p>状态表示：<span class="math inline">\(f(state,j)\)</span></p><ol type="1"><li>集合：终点为j，路径状态为state的距离；一共有20个点，以二进制形式进行表示，共有<spanclass="math inline">\(2^{20}\)</span>个情况</li><li>属性：min</li></ol><p>状态计算：</p><ol type="1"><li><p><span class="math inline">\(0\to j\)</span> 可以转换成 <spanclass="math inline">\(0\to k\to j\)</span></p></li><li><p><span class="math inline">\(0\tok\)</span>就是从state中减去j的路径情况</p></li><li><p>合法性判断：state减去j之后的路径中第k位是否是1，如果是则合法</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> f[M][N], w[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span>(((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k) &amp; <span class="number">1</span>)</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树形dp">树形Dp</h1><blockquote><p>状态表示是<span class="math inline">\(f[N][2]\)</span></p></blockquote><h2 id="没有上司的舞会">没有上司的舞会</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408241327759.png" /></p><blockquote><p>状态表示：</p><ol type="1"><li><spanclass="math inline">\(f(i,1)\)</span>表示在以i为根节点的子树中选择并且选择i</li><li><spanclass="math inline">\(f(i,0)\)</span>表示在以i为根节点的子树中选择并且不选择i</li></ol><p>状态计算：<span class="math inline">\((i,j)\)</span></p><ol type="1"><li>对于<spanclass="math inline">\(f(i,1)\)</span>，显然不能选择j，所以<spanclass="math inline">\(f(i,1)+=f(j,0)\)</span></li><li>对于<spanclass="math inline">\(f(i,0)\)</span>，j可选可不选，所以<spanclass="math inline">\(f(i,0)+=max(f(j,0),f(j,1))\)</span></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> head[M], ne[M], to[M], idx;</span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">bool</span> fa[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[idx] = head[a], to[idx] = b, head[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[r][<span class="number">1</span>] += happy[r];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[r]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = to[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[r][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        f[r][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; happy[i];</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        fa[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(fa[root]) root++;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="记忆化搜索">记忆化搜索</h1><h2 id="滑雪">滑雪</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408241356625.png" /></p><blockquote><p>状态表示：<span class="math inline">\(f(i,j)\)</span></p><ol type="1"><li><p>集合：表示最终滑到<spanclass="math inline">\((i,j)\)</span>的一条路径</p></li><li><p>属性：max</p></li></ol><p>状态计算：</p><ul><li>分成<spanclass="math inline">\(f(i-1,j)+1,f(i,j-1)+1,f(i+1,j)+1,f(i,j+1)+1\)</span></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N],f[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];<span class="comment">//用v代替f[x][y]方便</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    v = <span class="number">1</span>;<span class="comment">//注意把v变成1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx &gt; <span class="number">0</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &gt; <span class="number">0</span> &amp;&amp; yy &lt;= m &amp;&amp; g[x][y] &gt; g[xx][yy])</span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(xx, yy) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//因为每个点都可能是起点，所以都需要加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">    cout &lt;&lt; res ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMC极限</title>
      <link href="/2024/08/17/CMC%E6%9E%81%E9%99%90/"/>
      <url>/2024/08/17/CMC%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初等变形">初等变形</h1><ol type="1"><li>将 <span class="math inline">\(1\times 2 + 2\times 3 +……+n\times(n+1)\)</span> 化成 <spanclass="math inline">\((1^2+1)+(2^2+2)+……+(n^2+n)\)</span></li><li>无穷和的极限 + 三角函数<spanclass="math inline">\(\rightarrow\)</span>乘另一种三角函数凑成两个三角函数想乘的形式<spanclass="math inline">\(\rightarrow\)</span>利用积化和差，将乘积转换成两项之差</li></ol><ul><li><span class="math inline">\(2\cos\beta \sin\alpha = \sin(\alpha +\beta) - \sin(\alpha -\beta)\)</span></li><li><span class="math inline">\(2\sin\alpha\sin\beta =-\cos(\alpha+\beta) + \cos(\alpha - \beta)\)</span></li></ul><ol start="3" type="1"><li>巧妙应用<spanclass="math inline">\(1-t^i=(1-t)(1+t+……+t^{i-1})\)</span></li><li>要分从左趋近和从右趋近的情况：<ul><li><span class="math inline">\(\lim\limits_{x\to 0}[x]\)</span></li><li><span class="math inline">\(\lim\limits_{x\to 0}e^{-x}\)</span></li><li><span class="math inline">\(\lim\limits_{x\to\infty}e^x\)</span></li><li><span class="math inline">\(\lim\limits_{x\tox_0}\frac{1}{x-x_0}\)</span></li><li>分段函数的分段点</li></ul></li><li>在计算<spanclass="math inline">\(\lim\limits_{k\to+\infty}ln(1+k)\)</span>时提出一个k，变成<spanclass="math inline">\(\lim\limits_{k\to+\infty}lnk\cdot (1+\frac{1}{k})= \lim\limits_{k\to+\infty}lnk + ln(1+\frac{1}{k})\)</span></li><li>尝试将无穷和转换成有限的运算形式，如：见到<spanclass="math inline">\(\sum\limits_{k=1}^{n}C_n^k\cdotk^2\)</span>，则想到<spanclass="math inline">\(\sum\limits_{k=1}^{n}C_n^k\cdotx^k=(1+x)^n\)</span></li></ol><h1id="利用重要极限及等价无穷小的计算">利用重要极限及等价无穷小的计算</h1><ol type="1"><li><p><spanclass="math inline">\(\lim\limits_{x\to\infty}(1+\frac{1}{x})^{x}=e\)</span></p></li><li><p><spanclass="math inline">\(x\to1,x^{\alpha}-1\sim\alpha(x-1)\)</span></p><p><span class="math inline">\(x\to0,(1+x)^{\alpha}-1\sim\alphax\)</span></p></li><li><p><spanclass="math inline">\(\alpha\sim\alpha&#39;,\beta\sim\beta&#39;,lim\frac{\beta}{\alpha}=lim\frac{\beta&#39;}{\alpha&#39;}\)</span></p></li><li><p><span class="math inline">\(1^{\infty}\)</span>型 <spanclass="math inline">\(\rightarrow\)</span> 化成<spanclass="math inline">\(1+无穷小\)</span>的形式，即<spanclass="math inline">\(\lim [1+f(x)]^{g(x)}=e^{\limg(x)f(x)}\)</span></p></li><li><p><span class="math inline">\(\infty-\infty\rightarrow\)</span>化成<spanclass="math inline">\(\frac{0}{0}\)</span>，利用倒数换元</p></li></ol><h1id="利用极限存在的两个原理进行计算">利用极限存在的两个原理进行计算</h1><ol type="1"><li>分子分母一个存在阶乘，一个存在连乘，进行放缩，利用夹逼原理</li><li>同时出现<span class="math inline">\(\sum\frac{1}{k}\)</span>和<spanclass="math inline">\(\ln n\)</span>，利用<spanclass="math inline">\(\ln (n+1)\leq \sum\limits_{k=1}^n \frac{1}{k}\leq\ln n + 1\)</span><ul><li>$<em>k^{k+1}</em>{k-1}^{k} $</li></ul></li><li><span class="math inline">\(\frac{1}{n+1}&lt;\ln(1+\frac{1}{n})&lt;\frac{1}{n}\)</span></li><li>递推公式<span class="math inline">\(x_n=f(x_{n-1})\)</span><ol type="1"><li>方法一：先求出<spanclass="math inline">\(x=f(x)\)</span>的根，即<spanclass="math inline">\(x_n\)</span>的极限，然后利用带绝对值的夹逼原理进行证明</li><li>方法二：利用单调有界性，如果整个不单调就看奇偶子列的单调性<ul><li>可以使用递推式先假设，再判断是单增还是单减</li><li>令<span class="math inline">\(f(x)=f(x_{n-1})\)</span>，那么<spanclass="math inline">\(f(x)\)</span>相当于<spanclass="math inline">\(x_n\)</span>，而<spanclass="math inline">\(x\)</span>相当于<spanclass="math inline">\(x_{n-1}\)</span><ol type="1"><li><spanclass="math inline">\(x&gt;f(x),x_n&lt;x_{n-1}\)</span>，单减</li><li><spanclass="math inline">\(x&lt;f(x),x_n&gt;x_{n-1}\)</span>，单增</li></ol></li></ul></li></ol></li></ol><h1 id="用导数的定义进行计算">用导数的定义进行计算</h1><p><span class="math inline">\(f&#39;(x_0)=\lim\limits_{x\tox_0}\frac{f(x)-f(x_0)}{x-x_0}=\lim\limits_{\Delta x\to0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}\)</span></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL之permutation</title>
      <link href="/2024/08/15/STL%E4%B9%8Bpermutation/"/>
      <url>/2024/08/15/STL%E4%B9%8Bpermutation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="next_permutation">next_permutation</h1><blockquote><ol type="1"><li>依次按字典序升序进行排列的全排列</li><li>next_permutation()会取得[first,last)所标示之序列的下一个排列组合，如果没有下一个排列组合，便返回false;否则返回true。<strong><spanclass="math inline">\(\color{red}{注意！！！是左闭右开}\)</span></strong></li></ol></blockquote><p>使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="prev_permutation">prev_permutation</h1><blockquote><p>与next_permutation类似，只是是按字典序降序进行全排列</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing图论提高版</title>
      <link href="/2024/08/15/AcWing%E5%9B%BE%E8%AE%BA%E6%8F%90%E9%AB%98%E7%89%88/"/>
      <url>/2024/08/15/AcWing%E5%9B%BE%E8%AE%BA%E6%8F%90%E9%AB%98%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最优乘车">最优乘车</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408132126547.png" /></p><blockquote><ol type="1"><li>建图方式：因为要算的是最少换乘多少次，所以要考虑如何把换乘次数问题转换成最短距离问题。我们可以设置，让一辆车所走的路线之间距离都是1，比如：路线为25 74，则2-&gt;5，2-&gt;7，2-&gt;4，5-&gt;7，5-&gt;4，7-&gt;4全部设置为1；由此将换乘次数转换成最短路</li><li>读入方式：因为读入时的站点数量未知且不唯一，所以利用getline+stringstream进行读入，<spanclass="math inline">\(\color{red}{使用getlilne不要忘记读入最开始的换行符}\)</span></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> stop[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstral</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j])</span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;<span class="comment">//不要忘记读\n</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; p) stop[cnt++] = p;<span class="comment">//因为读入的数量未知，使用stringstream</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; cnt; j++)</span><br><span class="line">                g[stop[i]][stop[j]] = <span class="number">1</span>;<span class="comment">//只要一辆车能走到的地方距离就是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstral</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="昂贵的聘礼">昂贵的聘礼</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408151215017.png" /></p><blockquote><ol type="1"><li>建图方式：将一个物品可以用一个替代品和优惠后的价格购买，转换成一个节点（待购买的物品）由另一个节点（替代品）和指向（待购买物品）的边组成；因为每个物品由有本身的单价，于是创建虚拟原点，指向每个（物品的）节点，边权为物品的单价。</li><li>阶级问题：因为该题的数据量较小，可以直接用暴力的方式；我们可以在选择距离最小的点的时候判断level是否符合要求，但这个时候需要注意，如果没有符合要求的点，t可能是-1，导致数组越界，所以需要特判t== -1；也可以在更新距离的时候判断，这时候直接判断即可。</li><li>因为重复调用多次Dijsktral，所以需要每次重置st数组</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> level[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstral</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (level[j] &gt;= s &amp;&amp; level[j] &lt;= e) &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">            <span class="comment">//if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(level[j] &gt;= s &amp;&amp; level[j] &lt;= e)</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> price;</span><br><span class="line">        cin &gt;&gt; price &gt;&gt; level[i];</span><br><span class="line">        g[<span class="number">0</span>][i] = <span class="built_in">min</span>(g[<span class="number">0</span>][i], price);</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (x--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t, v;</span><br><span class="line">            cin &gt;&gt; t &gt;&gt; v;</span><br><span class="line">            g[t][i] = <span class="built_in">min</span>(g[t][i], v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    level[<span class="number">0</span>] = level[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level[<span class="number">1</span>] - m; i &lt;= level[<span class="number">1</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">Dijkstral</span>(i, i + m);</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新年好">新年好</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408161352959.png" /></p><blockquote><ol type="1"><li>只要是双向的路径，<spanclass="math inline">\(\color{red}{M一定要记得×2！！！！！！！！}\)</span></li><li>因为n的范围比较大，所以不能直接设置<spanclass="math inline">\(d[N][N]\)</span>的数组，需要利用映射的方式，让d的第一维从1到6变化</li><li>因为一共只有5个亲戚，所以可以直接全排列，使用STL中的next_permutation，在使用前记得排序</li><li>以每个亲戚作为原点，计算其他点到该点的距离</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, M = (<span class="number">1e5</span> + <span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> head[M], to[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>][N];</span><br><span class="line"><span class="type">int</span> source[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> rel[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstral</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">0</span>, s &#125;);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, t] = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; d + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = d + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; dist[j], j &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rel[<span class="number">0</span>] = <span class="number">1</span>, source[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) cin &gt;&gt; rel[i];</span><br><span class="line">    <span class="built_in">sort</span>(rel + <span class="number">1</span>, rel + <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)  source[rel[i]] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, t;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(x, y, t); <span class="built_in">add</span>(y, x, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) </span><br><span class="line">        <span class="built_in">Dijkstral</span>(rel[i], d[i]);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = d[<span class="number">0</span>][rel[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) res += d[source[rel[i]]][rel[i + <span class="number">1</span>]];</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, res);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(rel + <span class="number">1</span>, rel + <span class="number">6</span>));</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通信线路">通信线路</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408181433401.png" /></p><blockquote><ol type="1"><li>将题意转换成求：所有线路中，每条线路花费第k+1大的电缆所需要的最小花费</li><li>求第k大的最小值/第k小的最大值<spanclass="math inline">\(\rightarrow\)</span>利用二分的思想</li><li>二分的判断条件：花费大于x的电缆数小于等于k，找满足条件的x的最小值</li><li>建图方式：将花费大于x的边权值设置为1，求n号点的最短距离，判断和k比较的大小</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e4</span> + <span class="number">10</span>, N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[M], to[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, t] = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i], v = w[i] &gt; x;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; d + v)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = d + v;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1e6</span> + <span class="number">1</span>) r = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最优贸易">最优贸易</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408181433225.png" /></p><blockquote><ol type="1"><li>将问题转换成，求<span class="math inline">\(1\simi\)</span>路上水晶球的最小价格、<span class="math inline">\(i\simn\)</span>路上水晶球的最大价格，用遍历所有的i，用最大减最小即可</li><li>在刚拿到该题的时候，可能会觉得直接用最大价格减最小价格即可，但是因为有的路是单行线，所以有可能不能从最小价格的城市走到最大价格的城市</li><li>“dp问题都可以转换成最短路径”，那么是用Dijkstral还是spfa呢？Dijsktral的适用条件是，每次堆顶取出的是该点的最小值，但是该图可能存在环，且该图是点的权重不是边的权重，如果有一个环中后面点的权重小于前面点的权重（相当于有负权边），就会导致前一个点第一次出堆时不是该点的最小值，于是Dijsktral不适用；spfa一般情况都适用，于是适用spfa</li><li>因为后面是求<span class="math inline">\(i\simn\)</span>的最大价格，所以可以反向建图，求i到n的最大价格；只需要多加一个head数组即可</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> hs[N], he[N], ne[M], to[M], idx;</span><br><span class="line"><span class="type">int</span> price[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dmin[N], dmax[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> s, <span class="type">int</span> d[], <span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)<span class="comment">//求最小值 </span></span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dmin);</span><br><span class="line">    <span class="comment">//注意！！！！！！！！不能写sizeof d，因为在函数里面d是一个指针，只占4个字节，而不是d数组的大小</span></span><br><span class="line">    d[s] = price[s];</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    st[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span> &amp;&amp; d[j] &gt; <span class="built_in">min</span>(d[t], price[j]) || flag == <span class="number">1</span> &amp;&amp; d[j] &lt; <span class="built_in">max</span>(d[t], price[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">0</span>) d[j] = <span class="built_in">min</span>(d[t], price[j]);<span class="comment">//与求最短路的区别</span></span><br><span class="line">                <span class="keyword">else</span> d[j] = <span class="built_in">max</span>(d[t], price[j]);</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(he, <span class="number">-1</span>, <span class="keyword">sizeof</span> he);</span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; price[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(hs, x, y); <span class="built_in">add</span>(he, y, x);</span><br><span class="line">        <span class="keyword">if</span>(z == <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(hs, y, x);</span><br><span class="line">            <span class="built_in">add</span>(he, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">spfa</span>(hs, <span class="number">1</span>, dmin, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">spfa</span>(he, n, dmax, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, dmax[i] - dmin[i]);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择最佳路径">选择最佳路径</h1><blockquote><p>在求最短路的过程中，如果题目给出了多个起点</p><ol type="1"><li>可以用虚拟原点的方式，让虚拟原点到其他的所有起点，这时只需求一次最短路</li><li>如果终点只有一个，也可以利用反向建图的方式</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sstream库</title>
      <link href="/2024/08/13/sstream%E5%BA%93/"/>
      <url>/2024/08/13/sstream%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章参考<ahref="https://www.runoob.com/cplusplus/cpp-libs-sstream.html">菜鸟教程</a></p><blockquote><p>sstream提供了一种方便的方式用来处理字符串流（像处理流一样处理字符串）</p><p>分为3类：</p><ol type="1"><li><code>istringstream</code>：从字符串中读取数据</li><li><code>ostringstream</code>：将数据写入字符串</li><li><code>stringstream</code>：上面二者的结合，可同时进行读取和写入</li></ol></blockquote><h1 id="istringstream">istringstream</h1><p>从字符串读取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string data = <span class="string">&quot;10, 20.5&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    iss &gt;&gt; i &gt;&gt; d;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d;<span class="comment">//会输出10 20.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ostringstream">ostringstream</h1><p>向字符串中写入数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">20.5</span>;</span><br><span class="line">    ostringstream oss;</span><br><span class="line">    oss &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d;</span><br><span class="line">    string result = oss.<span class="built_in">str</span>();<span class="comment">//str()用来获取oss中的内容</span></span><br><span class="line">    cout &lt;&lt; result;<span class="comment">//输出 10 20.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stringstream">stringstream</h1><h2 id="类型转换">类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_string</span><span class="params">(string&amp; result, <span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ostringstream oss;<span class="comment">//创建一个流</span></span><br><span class="line">oss &lt;&lt; t;<span class="comment">//把值传递如流中</span></span><br><span class="line">result = oss.<span class="built_in">str</span>();<span class="comment">//获取转换后的字符转并将其写入result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1, s2, s3;</span><br><span class="line"><span class="built_in">to_string</span>(s1, <span class="number">10.5</span>);<span class="comment">//double到string</span></span><br><span class="line"><span class="built_in">to_string</span>(s2, <span class="number">123</span>);<span class="comment">//int到string</span></span><br><span class="line"><span class="built_in">to_string</span>(s3, <span class="literal">true</span>);<span class="comment">//bool到string</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; s3;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的拼接">字符串的拼接</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;string,&quot;</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot; second string&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出strResult is: first string,second string</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清空 sstream</span></span><br><span class="line">    sstream.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;third string&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After clear, strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出After clear, strResult is: third string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清空">清空</h2><blockquote><p>在多次使用类型转换之前必须使用clear()，不能使用str("")</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    <span class="type">int</span> first, second;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在进行多次类型转换前，必须先运行clear()</span></span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入bool值</span></span><br><span class="line">    sstream &lt;&lt; <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear-str">clear() &amp;&amp; str("")</h3><blockquote><ol type="1"><li><p><strong>str()：</strong>str()用于&lt;&lt;，将字符串替换成str中的内容，并且从起始位置开始书写；可以用于字符串的清空和初始化</p></li><li><p><strong>clear()：</strong>clear()用于&gt;&gt;，用来删除文件的结束标志，使&lt;&lt;可以继续追加（多用于连续的类型转换）</p></li></ol></blockquote><h4 id="str">str()</h4><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408131525361.png" /></p><ol type="1"><li><p>通过s可以看出，&lt;&lt;每次都在结尾追加</p></li><li><p>通过s1可以看出，str("")可以清空字符串</p></li><li><p>通过s2可以看出，使用str可以清空并重新设置字符串，并将“鼠标”移到字符串开头，从开头开始追加</p></li><li><p>通过s3可以看出clear对&lt;&lt;无用</p></li></ol><h4 id="clear">clear()</h4><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408131542661.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408131541546.png" /></p><ol type="1"><li>通过s2可知，类型转换之后遇到文件结尾，无法继续&lt;&lt;向后追加</li><li>通过s3可知，如果字符串后面有空格或者换行，则不是遇到文件尾结束，可以继续向后追加</li><li>通过s4可知，添加了clear()之后，删除了文件结束标志，可以继续追加；并且每次的类型转换会记下结束的位置，下次从结束的位置开始接着类型转换</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题</title>
      <link href="/2024/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dijkstral">Dijkstral</h1><blockquote><p>利用贪心的思想，不能处理存在负边权的情况</p><p>适用条件：每次从堆顶取出的节点可以保证当前节点已经拥有最小权值</p><p>结果：可以得到所有点到起点的最短距离</p></blockquote><h2 id="朴素版本">朴素版本：</h2><ul><li>时间复杂度<span class="math inline">\(O(n^2)\)</span></li><li>用邻接矩阵进行存储</li><li>外层循环n -1次，每次循环所有结点，找到一个到起点距离最短、不在集合中(st为false)的结点，将这个结点加入到集合中，并根据这个节点更新其它结点的距离</li></ul><h2 id="堆优化版">堆优化版：</h2><ul><li>时间复杂度<span class="math inline">\(O(mlogn)\)</span></li><li>用邻接表（链式前向星）进行存储</li><li>使用<code>priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;</code>，每次队头的就是距离最小的节点</li><li>使用标记数组st，st为true表示该结点加入过队列，即已经得到了该点到原点的最小值</li><li>先判断距离最小的结点的st数组是否为true，如果是说明已经得到最小值，就跳过后续步骤；否则，修改st的值为true，并用这个节点更新其他节点，更新的节点加入到队列中<spanclass="math inline">\(\color{red}{（先判断st，再判断距离）}\)</span></li></ul><h1 id="bellman_ford">Bellman_Ford</h1><blockquote><p>每次对所有的边进行松弛操作</p></blockquote><ul><li>时间复杂度<span class="math inline">\(O(mn)\)</span></li><li>用结构体进行存储</li><li>循环k次（边数限制为k），每次利用上一轮的dist数组更新这一轮的dist数组（所以需要拷贝一份）</li></ul><h1 id="spfa">Spfa</h1><blockquote><p>优化版的Bellman_Ford，每次只对上次更新过的点连接的边进行松弛操作</p></blockquote><ul><li>宽搜（默认边权全为1）<ul><li>时间复杂度<span class="math inline">\(O(mn)\)</span></li><li>用邻接表（链式前向星）进行存储</li><li>利用队列，因为边权都为1，所以哪条路先到，哪条就是最短路</li></ul></li><li>增强版<ul><li>时间复杂度<spanclass="math inline">\(O(mk)\)</span>，最坏k等于n</li><li>用邻接表（链式前向星）进行存储</li><li>使用队列，加入到队列中表示与该节点相连的边待松弛</li><li><spanclass="math inline">\(\color{red}{每次出队列需要重新设置st数组为false}\)</span></li><li><spanclass="math inline">\(\color{red}{先判断距离，再判断是否要加入队列（即判断st数组是否为false）}\)</span></li></ul></li><li>利用spfa判断负权回路<ul><li>时间复杂度<span class="math inline">\(O(n)-O(mn)\)</span></li><li>如果存在负环，那么一旦进入这个负环，就会一直循环，因为只要在负环里面dist就会一直减，所以可以计算每个节点距离最短的路上有几个结点，如果大于等于n必定存在负环，因为如果只存在正环或者不存在环，那么最长的应该是n-1；因为负环不一定是从结点1开始的，所以在起始的时候需要把所有结点加入到队列中</li></ul></li></ul><h1 id="floyd">Floyd</h1><blockquote><p>多源最短路，直接暴力遍历</p></blockquote><ul><li>时间复杂度<span class="math inline">\(O(n^3)\)</span></li><li>三层循环遍历，最先遍历k</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本指令</title>
      <link href="/2024/07/30/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
      <url>/2024/07/30/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本知识">基本知识</h1><p>路径分隔符：windows:  linux:/</p><p>根目录：/</p><p>./：表示当前目录下</p><p>上级目录：..可以返回当前目录的上级目录</p><p>清屏：clear</p><p>linux系统中磁盘上的文件和目录构成一颗目录树，通过tree指令可以查看对应的“目录树”</p><p>安装tree：<code>yum -y install tree(centos版本)</code></p><p>通配符<em>：表示任意内容，eg：file<span class="math inline">\(\text*\)</span>表示以file开头的任意内容；rm -rf</em>删除当前目录的所有内容</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407311632809.png" /></p><p>热键：</p><ol type="1"><li>Tab：连按两次Tab可以对命令/路径进行补齐</li><li>Ctrl + C：失控的状态，按Ctrl+C直接终止</li><li>Ctrl + R：查找功能，找到之前输入过的指令</li></ol><h1 id="ls指令">ls指令</h1><blockquote><p>显示当前目录下的指定文件或者目录</p></blockquote><p><strong><em>常用选项</em></strong></p><blockquote><p>选项可以拼接在一起，顺序随意</p></blockquote><p>-l：显示文件的详细信息（等价于ll）</p><p>-a：列出目录下的所有文件（包括以.开头的隐藏文件）</p><p>-d：只显示目录本身，而不是显示目录里的内容</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407301537499.png" /></p><p>+指定路径：显示指定路径下的文件和目录</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407301542279.png" /></p><h1 id="pwd指令">pwd指令</h1><blockquote><p>查看当前目录</p></blockquote><h1 id="cd指令">cd指令</h1><blockquote><p>改变当前路径</p></blockquote><p>cd ..：返回上层路径</p><p>cd -：跳转到最近的上一次的路径</p><p>cd~：回到自己的家目录下（root用户首次登录，所处的路径，叫做root的家目录/root；普通用户首次登录，所处的路径，叫做普通用户的家目录/home/cyy）</p><h1 id="touch指令">touch指令</h1><blockquote><p>创建普通文件，一次可以创建多个文件</p></blockquote><h1 id="mkdir指令">mkdir指令</h1><blockquote><p>创建目录</p></blockquote><p><strong><em>常用选项</em></strong></p><p>-p：一次可建多个目录</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407311451295.png" /></p><h1 id="rmdir指令">rmdir指令</h1><blockquote><p>删除空目录，非空不能删</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407311623602.png" /></p><h1 id="rm指令">rm指令</h1><blockquote><p>rm -r 可以递归式删除非空目录</p><p>rm -rf递归并强制删除目录，即没有询问</p></blockquote><h1 id="man指令">man指令</h1><blockquote><p>各种指令的用法</p></blockquote><p>如果未安装则输入指令：<code>yum install -y man-pages</code></p><h1 id="nano指令">nano指令</h1><blockquote><p>相当于记事本，可以快速打开一个文件并且在里面添加内容</p></blockquote><p>如果未安装则输入：<code>yum install -y nano</code></p><h1 id="cp指令">cp指令</h1><blockquote><p>cp src[文件、目录] dst[路径、文件]</p><p>将文件进行拷贝；如果想拷贝目录，需要加-r选项</p></blockquote><p><code>cp ../</code>：拷贝到上级目录</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408011925827.png" /></p><h1 id="cat指令">cat指令</h1><blockquote><p>查看目标文件的内容，默认从键盘读入数据</p><p>查看大文件会刷屏</p></blockquote><p><strong><em>基本选项</em></strong></p><p>-n：给每行前面加上行号</p><p>-s：将多个空行合并为一个空行</p><p>-b：只给非空行编号</p><p><code>&lt;</code>：表示输入重定向，本来应该从键盘读入数据，现在从指定文件中读入数据</p><p><code>cat &lt; test.txt</code>：从test.txt读入数据</p><h1 id="tac指令">tac指令</h1><blockquote><p>逆序打印文件</p></blockquote><h1 id="more指令">more指令</h1><blockquote><p>只会显示一屏的内容，按回车下翻，不能上翻</p></blockquote><p>q：退出</p><h1 id="less指令">less指令</h1><blockquote><p>只会显示一屏的内容，输入q退出，按上下箭头进行向上向下翻</p></blockquote><p>/：搜索功能，按n往后翻，N往前翻</p><p>q：退出</p><h1 id="head-tail-指令">head &amp;&amp; tail 指令</h1><blockquote><p>查看文件的开头结尾</p></blockquote><p>-n：后面跟数字，要看几行就输几</p><p>要看第5000-5020行，怎么操作？</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202408071609903.png" /></p><p>管道|：可以进行连续操作</p><p>比如解决上述问题： head -5020 log.txt | tail -21</p><h1 id="mv指令">mv指令</h1><blockquote><p>mv src[文件、目录] dst[路径、文件]</p><ol type="1"><li>剪切文件或者目录</li><li>重命名</li></ol></blockquote><h1 id="echo指令">echo指令</h1><p><code>&gt;</code>：表示输出重定向，将本来要输出到显示器文件的内容输出到指定文件；如果指定文件不存在就新建一个</p><blockquote><p>输出重定向，每次都从头开始，清空源文件的所有内容，再进行写入</p></blockquote><p><code>&gt;test.txt</code>：可以实现新建文件/将文件内容清空</p><p><code>echo "helloword"&gt;test.txt</code>将要输出的字符串内容，写到文件中</p><p><code>&gt;&gt;</code>：追加重定向</p><blockquote><p>每次在文件后面追加内容，不清空</p></blockquote><h1 id="时间相关的指令">时间相关的指令</h1><p>date：<code>date +%Y-%m-%d\ %H:%M:%S</code></p><p>查看时间戳为0时的时间：<code>date +%Y-%m-%d\ %H:%M:%S -d @0</code></p><p>cal：显示任意年份的日历</p><h1 id="find指令">find指令</h1><blockquote><p>find + 路径 + -name + 文件名，把所有该文件名的文件显示出来</p></blockquote><p>-o：表示或者，可以同时查找多个文件，如：<code>find /home/cy -name test1.c -o -name test2.c</code></p><h1 id="which指令">which指令</h1><blockquote><p>用来在linux系统中查找指定的指令</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 基本指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境配置</title>
      <link href="/2024/07/29/Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/07/29/Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="连接服务器">连接服务器</h1><ol type="1"><li><p>下载Xshell</p></li><li><p>购买云服务器，保留公网ip（注意！！！是linux的服务器！！不是windows！！！）</p></li><li><p>xshell链接服务器：<ahref="https://blog.csdn.net/qq_44847147/article/details/104737763">详细步骤见此篇博客</a></p></li><li><p>创建新用户+给新用户设置密码+删除用户：<code>adduser cy1</code>，<code>passwd cy1</code>，<code>userdel -r cy1</code></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407291624808.png" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing图论题解</title>
      <link href="/2024/07/24/AcWing%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/24/AcWing%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排列数字">排列数字</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121424620.png" /></p><blockquote><p>利用深搜，设置一个数组用来存储走过的“路径”，还有一个标记数组用来看这个数有没有用过</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N], st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; n)     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[x] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n皇后">n皇后</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121424900.png" /></p><blockquote><p>设置三个参数，一个用来表示横行、一个竖行、一个表示当前已经有的皇后个数，一有冲突就让y++，当y走到头就让y重新回到0，然后让x向下移，设置四个bool数组，表示横行、纵行、正斜线、反斜线是否已经放了皇后</p></blockquote><p>法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> place[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n) y = <span class="number">0</span>, x++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; place[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x - y + n] &amp;&amp; ! udg[x + y])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x - y + n] = udg[x + y] = <span class="literal">true</span>;</span><br><span class="line">        place[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">         row[x] = col[y] = dg[x - y + n] = udg[x + y] = <span class="literal">false</span>;</span><br><span class="line">        place[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x , y + <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//memset(place, &#x27;.&#x27;, sizeof place);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        place[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> place[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//遍历x行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)<span class="comment">//结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; place[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y++)<span class="comment">//遍历每一个列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[y - x + n])</span><br><span class="line">        &#123;</span><br><span class="line">            row[x] = col[y] = dg[x + y] = udg[y - x + n] = <span class="literal">true</span>;</span><br><span class="line">            place[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            row[x] = col[y] = dg[x + y] = udg[y - x + n] = <span class="literal">false</span>;</span><br><span class="line">            place[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            place[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="走迷宫">走迷宫</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423575.png" /></p><blockquote><p>广度优先搜索，利用队列，先将第一层的数加入到队列中，然后在出队的时候把与第一层有关的第二层的数加入到队列中，“探索”它的上下左右，遍历到的地方不遍历第二遍，因为是层序遍历，第一次遍历到的一定是最小的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [a, b] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i], y = b + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; !g[x][y] &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               d[x][y] = d[a][b] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八数码">八数码</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423535.png" /></p><blockquote><p>将初始的状态和最后的状态转换成字符串，找到字符串中字符的位置和9宫格中字符位置的关系，对字符串进行操作</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ed = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; d;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">string  start;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[start] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        string t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dis = d[t];</span><br><span class="line">        <span class="keyword">if</span>(t == ed) <span class="keyword">return</span> dis;</span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//找到x在字符串中的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = k / <span class="number">3</span>, b = k % <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i], y =  b + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[x * <span class="number">3</span> + y]);</span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))<span class="comment">//如果这个样子的字符串没有出现过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[t] = dis + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[x * <span class="number">3</span> + y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="comment">//因为输入的时候有空格，所以不能直接cin &gt;&gt; start</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        start += x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的重心">树的重心</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407111517293.png" /></p><blockquote><p>每个结点的每个分支都是一个连通块，剩下的上面那部分是另一个连通块；对于每个结点，找到它所区分的连通块中的最大值；对于所有结点，将他们对应的连通块最大值进行比较，找到其中的最小值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> h[N], to[M], ne[M], idx;<span class="comment">//链式前向星</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, ans = N;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//链式前向星</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//从u开始深搜</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;<span class="comment">//size用来记录连通块中的最大值，sum用来记录下面所有连通块所拥有的结点个数，用来计算上面剩下的结点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历，开始深搜</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = to[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j);<span class="comment">//这一条通路下面的所有结点数</span></span><br><span class="line">        size = <span class="built_in">max</span>(size, s);<span class="comment">//最大的连通块</span></span><br><span class="line">        sum += s;<span class="comment">//下面所有的结点个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="built_in">max</span>(size, n - sum - <span class="number">1</span>);<span class="comment">//将下面的最大连通块个数和上面那个剩余的连通块比较，看哪个大</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, size);<span class="comment">//最大连通块中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> sum + <span class="number">1</span>;<span class="comment">//返回下面连通块的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);<span class="comment">//构图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图中点的层次">图中点的层次</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121022089.png" /></p><blockquote><p>图的广度优先搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> to[N], h[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//构图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//广搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图的拓扑排序">图的拓扑排序</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059150.png" /></p><blockquote><p>每次将度为0的节点加入到“队列”中</p><p>用链式前向星存图，不要忘记初始化head数组！！！！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> to[N], ne[M], head[M], idx;</span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!d[i]) q[++tt] = i;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">TopSort</span>()) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dijkstra求最短路on2">Dijkstra求最短路<spanclass="math inline">\(O(n^2)\)</span></h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423082.png" /></p><blockquote><p>设置一个集合，st为true就是在集合里面，否则就是不在那个集合里面；每次求不在集合里面的点到1结点的最短距离，加入到集合中之后，更新与这个结点有关的距离，直到所有点都在集合中（贪心的策略）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//找到距离1距离最小的点，并且这个点不在集合中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//加入到集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="dijsktra求最短路堆优化版omlogm">Dijsktra求最短路（堆优化版）(O(mlogm))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407121423302.png" /></p><blockquote><p>用priority_queue进行优化，使得找到距离1最近点的时间复杂度变为O(1)，以类似于bfs的形式进行遍历，更新距离，加入到队列中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> to[N], h[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    w[idx] = z;</span><br><span class="line">    h[x] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> d = t.first, x = t.second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[x]) <span class="keyword">continue</span>;</span><br><span class="line">        st[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[x] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[x] + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="spfa处理存在负边权的情况omk">Spfa(处理存在负边权的情况)(O(mk))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059202.png" /></p><blockquote><p>因为边权可能为负值，只能用spfa算法，不能用dijkstra算法；spfa算法是以“层序”的方式进行不断更新节点距离，也就是说，会用某一层的所有结点去更新下一层次的节点，而不是像dijkstra一样使用贪心的策略，这样就可以保证即使前面的边权大、后面有负边权也可以更新到。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> to[N], ne[N], w[N], head[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spfa判断是否存在负环onomn">Spfa判断是否存在负环(O(n)~O(mn))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059864.png" /></p><blockquote><p>如果存在负环，那么一旦进入这个负环，就会一直循环，因为只要在负环里面dist就会一直减，所以可以计算每个节点距离最短的路上有几个结点，如果大于等于n必定存在负环，因为如果只存在正环或者不存在环，那么最长的应该是n-1；因为负环不一定是从结点1开始的，所以在起始的时候需要把所有结点加入到队列中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> to[M], ne[M], w[M], head[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spfa的slf优化">Spfa的SLF优化</h1><blockquote><p>对于要加入到队列中的u，如果dist[u]要小于队首元素v的dist[v]，则加入到队头，否则加入到队尾；这时候就需要用双端队列dque</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//添加部分</span></span><br><span class="line">                    <span class="keyword">if</span>(q.<span class="built_in">size</span>() &amp;&amp; dist[j] &lt; dist[q.<span class="built_in">front</span>()])</span><br><span class="line">                        q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                    <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="bellmanford处理有限制条件的情况omn">BellmanFord（处理有限制条件的情况）(O(mn))</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407181059705.png" /></p><blockquote><p>利用一个循环，保证循环k次，每一次只往后“走”一步，并且每次更新需要用上一次更新的结果更新这一次的结果（不是用这一次更新这一次），所以需要每次先拷贝再更新</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], cpy[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cpy, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], cpy[e.a] + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        edges[i].a = x, edges[i].b = y, edges[i].w = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BellmanFord</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="floydon3">Floyd<spanclass="math inline">\((O(n^3))\)</span></h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407191043155.png" /></p><blockquote><ol type="1"><li>不能处理负边权回路</li><li><span class="math inline">\(d[i][j]\)</span>表示从i到j的距离</li><li>floyd中必须先遍历k，因为最后遍历k会导致更新i、j时的距离不是最优距离</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">20010</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> n, m, x, y, z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        d[x][y] = <span class="built_in">min</span>(d[x][y], z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(d[x][y] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="prim求最小生成树">Prim求最小生成树</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407221034218.png" /></p><blockquote><p>类似于dijkstra算法，每次循环找到一个最近的节点加入到最小生成树中，要考虑孤立点！！！需判断这个点的距离是不是无穷大，即判断是否连通，如果不联通就输出impossible，如果符合要求就更新距离</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dist[N], st[N];</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n, m, u, v, w;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//每次找到一个节点加入到生成树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[t] == <span class="number">0x3f3f3f3f</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="number">1</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i] &gt; g[i][t] &amp;&amp; !st[i]) dist[i] = g[i][t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u][v] = g[v][u] = <span class="built_in">min</span>(g[u][v], w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kruskal求最小生成树">Kruskal求最小生成树</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407221033135.png" /></p><blockquote><ol type="1"><li>根据边的权值大小从小到大排序</li><li>每次取一条边，利用并查集判断是否会形成环（即它的两个节点是否在一个集合）</li><li>最后根据取的边的数量，如果小于n - 1就不连通，无最小生成树</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//保存并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> E&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="type">int</span> pb = <span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            res += edges[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edges[i] = &#123;u, v, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges + <span class="number">1</span>, edges + m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="染色法判定二分图">染色法判定二分图</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407231016778.png" /></p><blockquote><p>利用dfs，没染色设为0，a颜色为1，b颜色为2，两个相连，一个染a一个染b，即一个是1，另一个是3-1；进行遍历，未染就进行染色，并更改周围的颜色；染色了，就判断染的颜色是否有矛盾</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span> * <span class="number">2</span>;<span class="comment">//因为是无向图，存两遍</span></span><br><span class="line"><span class="type">int</span> to[N], ne[N], head[N], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">//0是未染色，1是红色，2是黑色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = to[i];</span><br><span class="line">        <span class="keyword">if</span>(!color[j])<span class="comment">//如果未涂色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//染色并递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] &amp;&amp; color[j] != <span class="number">3</span> - c)<span class="comment">//如果染色了并且矛盾 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span>(x, y);<span class="built_in">add</span>(y, x);<span class="comment">//无向图，一条边存两次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])<span class="comment">//这个点未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图的最大匹配">二分图的最大匹配</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407231014468.png" /></p><blockquote><p>好题解！</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407231015507.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407231015453.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407231015381.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> to[N], ne[N], head[N], idx;</span><br><span class="line"><span class="type">int</span> n1, n2 ,m;</span><br><span class="line"><span class="type">int</span> st[N], match[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = to[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//因为只从一边向另一边匹配，所以只用存一边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing数学知识题解</title>
      <link href="/2024/07/24/AcWing%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/24/AcWing%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="筛质数">筛质数</h1><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407251323023.png" style="zoom: 80%;" /></p><blockquote><p>利用最小质因子进行判断</p><p><code>if(i % prime[j] == 0) break;</code></p><ol type="1"><li>如果<code>i % primes[j]!=0</code>，说明<code>primes[j]</code>不是<code>i</code>的质因子，那么只可能是此时的<code>primes[j]*i</code>的最小质因子,所以<code>primes[j] * i</code>的最小质因子就是<code>primes[j]</code></li><li>如果<code>i % primes[j]==0</code>，说明i的最小质因子是<code>primes[j]</code>,因此<code>primes[j]*i</code>的最小质因子也就应该是<code>prime[j]</code>，之后接着用<code>st[primes[j+1]*i]=true</code>去筛合数时，就不是用最小质因子去更新了,因为<code>i</code>具有更小的质因子<code>prime[j]</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)<span class="comment">//把小于n的数进行判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;<span class="comment">//用最小质因子筛质数</span></span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_prime</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二次筛质数">二次筛质数</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409051443973.png" /></p><blockquote><ol type="1"><li>因为数据最大是<spanclass="math inline">\(2^{31}\)</span>，所以显然不能用线性筛，会TLE</li><li>用二次筛：假设一个数n是合数，那么它一定有<spanclass="math inline">\(d,\frac{n}{d}\)</span>两个因子，假设<spanclass="math inline">\(d&lt;\frac{n}{d}\)</span>，则<spanclass="math inline">\(d&lt;\sqrt{n}\)</span>，所以只需要找出<spanclass="math inline">\(1\sim\sqrt{n}\)</span>的所有素数，然后用这些素数更新<spanclass="math inline">\([l,r]\)</span>的所有合数即可</li><li>对于素数p，要找到<spanclass="math inline">\([l,r]\)</span>中所有以p为最小质因子的合数，可以从<code>max(2 * p, (l + p - 1) / p * p)</code>开始寻找，然后不断<code>+p</code>即可，其中<code>(l + p - 1) / p * p</code>等价于<spanclass="math inline">\(\lceil\frac{l}{p}\rceil\)</span></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line">ll prime2[N], k;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">get_prime</span>(<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="built_in">memset</span>(prime2, <span class="number">0</span>, <span class="keyword">sizeof</span> prime2);</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll p = prime[i];</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="built_in">max</span>(<span class="number">2</span> * p, (l + p - <span class="number">1</span>) / p * p); j &lt;= r; j += p)</span><br><span class="line">                st[j - l] = <span class="literal">true</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= r - l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i] &amp;&amp; i + l &gt; <span class="number">1</span>)</span><br><span class="line">                prime2[k++] = i + l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;There are no adjacent primes.&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> minp = <span class="number">0</span>, maxp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> d = prime2[i + <span class="number">1</span>] - prime2[i];</span><br><span class="line">                <span class="keyword">if</span>(d &lt; prime2[minp + <span class="number">1</span>] - prime2[minp]) minp = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; prime2[maxp + <span class="number">1</span>] - prime2[maxp]) maxp = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,%d are closest, %d,%d are most distant.\n&quot;</span>, prime2[minp], prime2[minp + <span class="number">1</span>], prime2[maxp], prime2[maxp + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阶乘分解">阶乘分解</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409061233025.png" /></p><blockquote><p>对于8！</p><p>1 2 3 4 5 6 7 8</p><p>平时的方法是每个数每个数地求，即每一列每一列地求，但是这样的效率太低，于是想到一行一行地求</p><ul><li>求出8！中2的倍数</li></ul><p>1 2 3 4 5 6 7 8</p><p>​ 1 1 1 1 首先我们<span class="math inline">\(1\sim8\)</span>中2的个数：<code>8 / 2</code></p><pre><code>           1                   1  然后求出$1\sim 8$中4的个数：```8 / 4```</code></pre><p>​ 1 最后求出<span class="math inline">\(1\sim8\)</span>中8的个数：<code>8 / 8</code></p><p>所以8！中因数2的个数：<code>8 / 2 + 8 / 4 + 8 / 8 = 7</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">prime</span>(i)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = i, ans = <span class="number">0</span>;<span class="comment">//因为n！可能很大，所以用long long存储x</span></span><br><span class="line">        <span class="keyword">while</span>(x &lt;= n) ans += n / x, x *= i;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数个数">约数个数</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407301332975.png" /></p><blockquote><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数个数为<spanclass="math inline">\((x_1+1)(x_2+1)...(x_k+1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a /= i;</span><br><span class="line">                mp[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) mp[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y] : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * (y + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约数之和">约数之和</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407301352984.png" /></p><blockquote><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数之和为<spanclass="math inline">\((  p_1^0+p_1^1+..._+p_1^{x_1})\times...\times(p_k^0+p_k^1+...+p_k^{x_k})\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                a /= i;</span><br><span class="line">                mp[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) mp[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[x, y] : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(y--)</span><br><span class="line">        &#123;</span><br><span class="line">            t = (t * x + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大公约数">最大公约数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="欧拉函数">欧拉函数</h1><blockquote><p>1∼N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)。若在算数基本定理中，<spanclass="math inline">\(N=p_1^{a_1}p_2^{a_2}…p_m^{a_m}\)</span>，则：<span class="math inline">\(ϕ(N) = N×\frac{p_1 -1}{p_1}×\frac{p_2−1}{p_2}×…×\frac{p_m−1}{p_m}\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin &gt;&gt; a;</span><br><span class="line">        ll res = a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>)res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>)a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="筛法求欧拉函数">筛法求欧拉函数</h1><p>给定一个正整数 n，求 1∼n中每个数的欧拉函数之和。欧拉函数是指<spanclass="math inline">\(1\sim N\)</span>中与N互质的个数。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. ```i % prime[j] == 0```，在此情况下```prime[j]```是```i```的质因子，所以```i```和```i * prime[j]```的质因子是相同的，所以根据公式，```ph[i * prime[j]] = ph[i] * prime[j]```，即只差N中的```prime[j]```</span><br><span class="line">2. ```i % prime[j] != 0```，在此情况下```prime[j]```不是```i```的质因子，所以```i```和```i * prime[j]```的质因子相差一个```prime[j]```，所以根据公式，```ph[i * prime[j]] = ph[i] * prime[j] * (1 - 1 / prime[j]) = ph[i] * (prime[j] - 1)```，即差N中的```prime[j]```和质因子的一项```1 - 1 / prime[j]```</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll phi[N], prime[N];</span><br><span class="line">bool st[N];</span><br><span class="line">ll n, cnt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   phi[1] = 1;</span><br><span class="line">   for(int i = 2; i &lt;= n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(!st[i])</span><br><span class="line">       &#123;</span><br><span class="line">           phi[i] = i - 1;</span><br><span class="line">           prime[cnt++] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int j = 0; prime[j] &lt;= n / i; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           st[prime[j] * i] = true;</span><br><span class="line">           if(i % prime[j] == 0) </span><br><span class="line">           &#123;</span><br><span class="line">               phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           else phi[i * prime[j]] = phi[i] * (prime[j] - 1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ll res = 0;</span><br><span class="line">   for(int i = 1; i &lt;= n; i++) res += phi[i];</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="快速幂">快速幂</h1><p>给定n组<spanclass="math inline">\(a_i,b_i,p_i\)</span>，对于某组数据，求出<spanclass="math inline">\(a_i^{b_i}modp_i\)</span></p><blockquote><ol type="1"><li>如果直接暴力枚举，时间复杂度是<spanclass="math inline">\(O(b*n)\)</span>，会TLE</li><li>将b用二进制表示，<span class="math inline">\(b =2^{x_1}+2^{x_2}+...2^{x_n}\)</span>；预处理出<spanclass="math inline">\(a^{2^0},a^{2^1},...a^{2^{logb}}\)</span></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a, b, p;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">qmi</span>(a, b, p) % p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂求逆元">快速幂求逆元</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202409051127024.png" /></p><blockquote><p>直接根据公式<spanclass="math inline">\(b^{m-2}\)</span>即为b的乘法逆元，求解即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a, p;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; p;</span><br><span class="line">        ll res = <span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">if</span>(a % p == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memset的使用</title>
      <link href="/2024/07/11/memset%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/07/11/memset%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="memset的赋值规则">memset的赋值规则</h1><blockquote><p>memset赋值时，是按字节赋值，是将参数转换成二进制之后填入一个字节</p></blockquote><p><code>eg: memset(g, 100, sizeof g);</code></p><p>100转换成二进制是0110 0100，而int是4个字节，</p><p>所以一个int被赋值为0110 0100, 0110 0100, 0110 0100, 0110 0100，</p><p>对应十进制是1684300900</p><h1 id="memset的赋值-100x3f">memset的赋值-1，0，0x3f</h1><ol type="1"><li>0赋值之后肯定还是0</li><li>-1因为它的补码是111……111，所以赋值之后还是-1</li><li>0x3f赋值之后是无穷大，即0x3f3f3f3f</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing数据结构题解</title>
      <link href="/2024/07/02/AcWing%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/02/AcWing%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单链表">单链表</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407022159322.png" /></p><blockquote><p>利用数组模拟链表，相当于链式前向星。head表示头结点的下标，e[i]表示i节点的值，ne[i]表示i节点指向的下一个节点的下标，idx表示当前可用的最后一个下标；因为idx从0开始不是从1开始，所以题目输入的k在用的时候需要-1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//头结点的插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span><span class="comment">//任意节点的插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x;cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> k, val;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; val;</span><br><span class="line">            <span class="built_in">add_to_head</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; val;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k) head = ne[head];<span class="comment">//如果k==0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">delete_k</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双链表">双链表</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407022202290.png" /></p><blockquote><p>根据单链表的经验，双链表只需要添加指向前一个结点的数组即可；这里我们省略head和tail，让0是左端点，1是右端点，那么idx就从2开始；在初始的时候head指向tail，tail指向head，因为前后节点都知道，所以只需要写一个插入函数即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], le[N], re[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span><span class="comment">//初始化，头尾是没有值的，只是标记</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    le[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//尾节点的前一个节点是头结点</span></span><br><span class="line">    re[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//头结点的后一个节点是尾节点</span></span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span><span class="comment">//插入到k的后面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    le[idx] = k;</span><br><span class="line">    re[idx] = re[k];</span><br><span class="line">    le[re[k]] = idx;</span><br><span class="line">    re[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    re[le[k]] = re[k];</span><br><span class="line">    le[re[k]] = le[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(<span class="number">0</span>, x);<span class="comment">//头插，0是头，插到0的后面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(le[<span class="number">1</span>], x);<span class="comment">//1是尾，插入到尾的前面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">Delete</span>(k + <span class="number">1</span>);<span class="comment">//因为idx从2开始，所以要+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(le[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IR&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = re[<span class="number">0</span>]; i != <span class="number">1</span>; i = re[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="表达式求值">表达式求值</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407022342608.png" /></p><blockquote><p>建两个栈，一个存数字，一个存运算符</p><p>需要注意：</p><ol type="1"><li>遇到一个字符是数字，需要判断后面是不是接着是数字，将字符串转换成数字</li><li>结束条件之一是没有剩余的运算符</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; sg;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp&#123; &#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125; &#125;;<span class="comment">//用来存储各运算符的优先级</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span><span class="comment">//进行运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">char</span> op = sg.<span class="built_in">top</span>();sg.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;<span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)  r = b + a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>) r = b - a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;*&#x27;</span>) r = b * a;</span><br><span class="line">    <span class="keyword">else</span> r = b / a;</span><br><span class="line">    num.<span class="built_in">push</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i])) <span class="comment">//如果是数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[j]))<span class="comment">//判断后面是否有跟着的数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)<span class="comment">//左括号直接入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            sg.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sg.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)<span class="comment">//右括号计算到左括号为止</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            sg.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还有没有用的运算符并且栈顶的优先级高，就计算</span></span><br><span class="line">            <span class="keyword">while</span>(sg.<span class="built_in">size</span>() &amp;&amp; mp[sg.<span class="built_in">top</span>()] &gt;= mp[s[i]])</span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            sg.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sg.<span class="built_in">size</span>()) <span class="built_in">eval</span>();<span class="comment">//计算剩下的表达式</span></span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031243104.png" /></p><p><strong>解析</strong>：<img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031244235.png" style="zoom: 50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> st[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; st[tt] &gt;= x) tt--;<span class="comment">//如果栈不为空，并且栈顶元素比当前元素大，就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(!tt) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st[++tt] = x;<span class="comment">//当前元素入栈，先++，保证tt==0的时候栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列">单调队列</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031420669.png" /></p><blockquote><p>首先根据题意我们知道可以用队列模拟滑动窗口，但是如果直接暴力的话，时间复杂度是O(nk)，显然会超时，这时候就可以用单调队列优化，即将不需要的数字删去，看最后队列中的数是否具有单调性，如果有，就可以用单调队列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N], a[N];<span class="comment">//q是队列，a是存储数据的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断需不需要让窗口往后移</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为是找最小值，所以如果新出现的元素比左边的元素小，那么在窗口右移的过程中，左边的那个更大的元素必定用不到，所以删去</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//将新元素加进队列</span></span><br><span class="line">        <span class="comment">//整个队列单调增，所以hh位置元素最小</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前队列中的元素个数大于k，需要队首出队</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为找最大值，所以如果新出现元素更大，同上，删去左边的元素</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//在队列里面存下标</span></span><br><span class="line">        <span class="comment">//整个队列单调减，hh位置元素最大</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kmp算法">KMP算法</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041040433.png" /></p><blockquote><ol type="1"><li>暴力，i指针遍历s字符串，j指针遍历p字符串；如果遍历不成功i就会回退，时间复杂度是O(mn)会超时</li><li>KMP优化，利用next数组，让i指针不回退，如果不成功就让j根据next数组跳转，next跳转的位置前面的字符串应该与当前匹配到的位置前面的字符串一致；时间复杂度O(m+ n)</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[M], p[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//生成next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"> <span class="comment">//前面有字符串并且当前字符串不匹配，就让j跳转到有相同前缀的子串后面，比如字符串abcabab，在倒数第二个a后面的b不匹配的时候跳转到第一个a</span></span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;<span class="comment">//如果相等就往后匹配，要找到最大的相同前后缀</span></span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//不匹配就让j跳转</span></span><br><span class="line">        <span class="keyword">if</span>(p[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i - n &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//因为题目要求的下标从0开始，但是程序写的时候是从1开始</span></span><br><span class="line">            j = ne[j];<span class="comment">//如果已经匹配完成，看要匹配的字符串里面有没有相同的前后缀，避免二次匹配，所以跳转到ne[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="trie树">Trie树</h1><blockquote><p>高效存储和查找字符串集合的数据结构</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041456057.png" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041339064.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;<span class="comment">//注意！N是最长字符串的长度！！！！！！！！</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">//son的第一维表示编号，一条一条递增，第二维表示字母；总体表示trie树</span></span><br><span class="line"><span class="comment">//cnt用来标记字符串的结尾，以及有几个字符串以这个字母结尾</span></span><br><span class="line"><span class="comment">//idx用来表示当前的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;<span class="comment">//相当于指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];<span class="comment">//让p到子节点的位置，寻找子节点的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;<span class="comment">//尾节点标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]) p = son[p][u];<span class="comment">//如果有这个字母，就接着往下遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//否则不存在这个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">Insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">Query</span>(s) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大异或对">最大异或对</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041423388.png" /></p><blockquote><p>利用Trie树，从高位到低位存储每一个数的二进制形式；利用遍历，尽量找每一位都不一样的数，从而找到每一个数与其他数异或中的最大值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">31</span> * N;</span><br><span class="line"><span class="type">int</span> a[N], son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//建立Trie树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; ~i; i--)<span class="comment">//~i相当于i &gt;= 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;<span class="comment">//判断这一位是0/1</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<span class="comment">///建树</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; ~i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])<span class="comment">//看是否有和这一位01相反的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = <span class="number">2</span> * res + <span class="number">1</span>;<span class="comment">//如果有，在结果中这一位是1，所以+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = <span class="number">2</span> * res + <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">Insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">Query</span>(a[i]));<span class="comment">//遍历判断</span></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集">并查集</h1><blockquote><ol type="1"><li>将两个集合合并</li><li>询问两个元素是否在同一个集合中</li></ol></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407041519626.png" /></p><blockquote><p>用p数组表示该集合中元素的父节点，当p[i] == i的时候，i是根节点</p><p>合并集合：让两个数的根节点合并</p><p>是否在同一个集合：判断根节点是否相等</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//找到根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归到根节点并且做路径压缩，让这条路上的所有结点直接指向根节点</span></span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> x; </span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> n, m;  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;<span class="comment">//不要忘记初始化！！！</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            <span class="built_in">Merge</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">Query</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="食物链">食物链</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407082202771.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407082203529.png" /></p><blockquote><ol type="1"><li>根据分析，如果将整个食物链连成一棵树，那么到根节点距离<ul><li>除3余0，就跟根节点为同类</li><li>除3余1，就被根节点吃</li><li>除3余2，就吃根节点</li></ul></li><li>返回值为bool的函数，一定要保证<strong>每条路径有返回值</strong></li><li>找到x，y的根节点，如果根节点不一样，则跟前面的话不可能冲突，所以一定是真话，将二者的关系加上即可；如果一样就通过到根节点的距离除3的余数判断</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> d[N], fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(fa[x]);<span class="comment">//找到fa[x]的根节点</span></span><br><span class="line">        <span class="comment">//设置一个新的变量t而不是直接更新x的父节点是根节点是因为后面更新d[x]需要用到x的fa[x]的距离值</span></span><br><span class="line">        d[x] += d[fa[x]];<span class="comment">//更新d[x]的距离，d[x]表示x到其父节点的距离</span></span><br><span class="line">        fa[x] = t;<span class="comment">//更新x的父节点为根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">D1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy &amp;&amp; (d[y] - d[x] + M) % M) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//因为d mod 3的余数相同表示是同一类，+M是怕d[y] - d[x] &lt; 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fx != fy)<span class="comment">//表示二者没有关系，一定不是假话，让x, y变成同类</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        <span class="comment">//(d[x] + ?) % 3 == d[y] % 3，其中?表示fx到fy的距离，即d[fx]</span></span><br><span class="line">        d[fx] = d[y] - d[x];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">D2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//x吃y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy &amp;&amp; (d[y] - d[x] - <span class="number">1</span> + M) % M)<span class="comment">//第0代吃第1代...，第二项等于0表示X吃Y</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fx != fy)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        d[fx] = (d[y] - <span class="number">1</span> - d[x] + M) % M;<span class="comment">//画个图，x吃y，可以知道x距离根节点比y距离根节点多1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true！！！！！！！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> D, x, y;</span><br><span class="line">        cin &gt;&gt; D &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (D == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">D1</span>(x, y)) cnt++;</span><br><span class="line">        <span class="keyword">if</span> (D == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">D2</span>(x, y)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序">堆排序</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407090944850.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = p * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt;= n &amp;&amp; a[c] &gt; a[c + <span class="number">1</span>]) c++;</span><br><span class="line">        <span class="keyword">if</span> (a[c] &lt; a[p])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[c], a[p]);</span><br><span class="line">            p = c;</span><br><span class="line">            c = p * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)  <span class="built_in">down</span>(i, n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        a[<span class="number">1</span>] = a[cnt--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟散列表">模拟散列表</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407090944936.png" /></p><blockquote><p>链地址法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">3</span>;<span class="comment">//大于1e5的质数</span></span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N], idx;<span class="comment">//链式前向星</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//将x映射到0~N</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x) <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">Insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">Query</span>(x) &lt;&lt; endl;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开放寻址法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span>(t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, null, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;    </span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[<span class="built_in">find</span>(x)] == null) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串哈希">字符串哈希</h1><p><imgsrc="C:\Users\cy\AppData\Roaming\Typora\typora-user-images\image-20240709104900995.png" /></p><blockquote><p>将字符串假设成为p进制的数，经过实验发现，当p=131或者p=1331的时候，可以当做没有冲突；然后就可以将字符串（p进制）转化成十进制数字，用p数组表示p的n次方，h数组存储前n个字符组成的字符串转换成的数字；可以利用前缀和的思想，发现h[s[l,r] ]= h[r] - h[l - 1] * p[r - l + 1];</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407100814057.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//冲突问题：通过巧妙设置P (131 或 13331) , Q (2^64)的值，一般可以理解为不产生冲突。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"><span class="type">char</span> s[N]; </span><br><span class="line"><span class="function">ULL <span class="title">Query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>]* p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i];</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>, h[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//p[i]表示p的i次方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + s[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, l2, r1, r2;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Query</span>(l1, r1) == <span class="built_in">Query</span>(l2, r2)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;<span class="comment">//如果两个字符串的哈希值相等，那么就说明两个字符串相等</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing基础算法题解</title>
      <link href="/2024/07/01/AcWing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/01/AcWing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="位整数乘法">64位整数乘法</h1><p>求a乘b对p取模的值，<span class="math inline">\(1 \leq a, b, p\leq10^{18}\)</span></p><blockquote><p>因为a，b的范围到了<spanclass="math inline">\(10^{18}\)</span>，相当于64位的整数，二者相乘之后就变成了128位的整数，计算机没有这么大的类型存储。虽然不能乘，但是我们可以想象成是b个a相加，将b写成二进制形式，那么答案就是<spanclass="math inline">\(a\times(2^{k_1}+2^{k_2}+...2^{k_n})\)</span></p></blockquote><p>上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULL a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">    ULL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (res + a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * <span class="number">2</span> % p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="费解的开关">费解的开关</h1><p>25盏灯排成一个 5×5的方形，每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。我们用数字1表示一盏开着的灯，用数字0表示关着的灯。给定一些游戏的初始状态，编写程序判断游戏者是否可能在6 步以内使所有的灯都变亮。</p><blockquote><p>如果第一行的(i, j)位置是0，那么改变(i + 1, j)就可以让(i,j)变成1，但是如果就按题目给定的25盏灯进行上述操作，因为第一行是给定的，那么只会有一种结果，所以我们需要把第一行的所有情况都考虑到，第一行共有32种情况，我们不管第一行题目给的是什么样都直接把那32种情况都改变一遍，然后再判断1~3 行改变第 2~4 行，最后判断第四行是不是全是开即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">char</span> g[N][N], cp[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//矢量，方便表示某个位置的上下左右和自己</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//改变这个位置和其上下左右位置的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">        g[a][b] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++) cin &gt;&gt; g[i];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">10</span>;<span class="comment">//初始化答案，大于6即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> op = <span class="number">0</span>; op &lt; <span class="number">32</span>; op++)<span class="comment">//第一行的32种情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(cp, g, <span class="built_in">sizeof</span>(g));<span class="comment">//拷贝一份</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)<span class="comment">//对第一行进行操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(op &gt;&gt; i &amp; <span class="number">1</span>)<span class="comment">//这个数的二进制哪一位是1就改变哪个位置的状态（不管它现在是什么状态） </span></span><br><span class="line">                &#123;</span><br><span class="line">                    step++;</span><br><span class="line">                    <span class="built_in">turn</span>(<span class="number">0</span>, <span class="number">4</span>-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//对2~4行进行操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    <span class="comment">//如果(i, j)是0，就改变(i + 1, j)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">turn</span>(i + <span class="number">1</span>, j);</span><br><span class="line">                        step++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断最后一行是不是都是1</span></span><br><span class="line">            <span class="type">bool</span> dark = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[<span class="number">4</span>][i] == <span class="string">&#x27;0&#x27;</span>) dark = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dark) res = <span class="built_in">min</span>(res, step);</span><br><span class="line">            <span class="built_in">memcpy</span>(g, cp, <span class="built_in">sizeof</span>(cp));<span class="comment">//拷贝回来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &lt;= <span class="number">6</span>) cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象</title>
      <link href="/2024/06/29/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/06/29/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="缺省参数">缺省参数</h1><ol type="1"><li>半缺省参数必须从右往左依次给出，不能间隔着给</li><li>缺省参数在函数声明的时候给出，不能声明定义同时给</li><li>缺省值必须是常量或者全局变量</li></ol><h1 id="引用">引用</h1><blockquote><ol type="1"><li>在使用引用时，权限可以平移和缩小，不能放大</li><li>引用定义时必须初始化</li><li>引用一旦引用一个实体就不能引用其他实体</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">2.234</span>;</span><br><span class="line">    <span class="comment">//类型转换，会生成一份临时拷贝，临时拷贝具有常性</span></span><br><span class="line">    <span class="type">int</span> i = d;</span><br><span class="line">    <span class="type">int</span>&amp; i = d;<span class="comment">//错误!!!!!</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;i = d; <span class="comment">//临时拷贝具有常性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表达式也会产生临时变量</span></span><br><span class="line">    <span class="type">int</span> x= <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;i = x + y;<span class="comment">//必须要加const</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内联函数">内联函数</h1><blockquote><p>用inline修饰的函数，inline只是一种建议，比较长的函数、递归函数等就算被定义为inline也会被编译器忽略</p></blockquote><p>在调用内联函数的地方进行展开，不需要建立函数栈帧，提升程序运行效率</p><h1 id="this指针">this指针</h1><ol type="1"><li>this指针被const修饰不能被修改，但是this指针指向的内容可以被修改</li><li>只能在“成员函数”的内部使用</li><li>this指针可以在类里面被引用，但是不能在函数形参里面定义，这个编译器会自动生成</li></ol><p><strong>练练手</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> _a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     A* p = <span class="literal">nullptr</span>;</span><br><span class="line">     p-&gt;<span class="built_in">Print</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>答案：C</p><p>在 p-&gt;Print() 这一步，可能会觉得是访问了空指针，但是实际上只是把this 指针赋为空，但是 Print 函数是直接打印的，并没有对 this指针进行访问，所以不会运行崩溃</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintA</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        cout&lt;&lt;_a&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;<span class="built_in">PrintA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>答案：B</p><p>因为打印的是_a，实际上就是this-&gt;_a，所以对this指针进行了访问，导致运行崩溃</p></blockquote><h1 id="默认成员函数">默认成员函数</h1><h2 id="构造函数">构造函数</h2><ol type="1"><li>构造函数不是开空间创造对象，而是初始化</li><li>函数名和类名相同</li><li>无返回值，不需要写void</li><li>对象实例化的时候编译器自动调用构造函数</li><li>构造函数可以重载</li><li>编译器自动生成的构造函数，对于<strong>内置类型</strong>成员变量(int,char, double...)不做处理，对于<strong>自定义类型</strong>成员变量(class,struct,...)会调用它的无参构造</li><li>如果类中没有显示定义构造函数，编译器会自动生成一个无参的构造函数，一旦用户显示定义编译器将不再生成</li></ol><h2 id="析构函数">析构函数</h2><ol type="1"><li>析构函数不是对对象本身的销毁，而是完成对象中资源清理工作</li><li>函数名是在类名前面加上~</li><li>在对象声明周期结束的时候自动调用</li><li>析构函数不能重载</li></ol><h2 id="拷贝构造">拷贝构造</h2><ol type="1"><li>参数只有一个且必须是类类型对象的引用，使用传值的方式会引发无穷递归，正确形式：Date(const Date&amp; d)</li><li>若未显示定义，则编译器会默认生成，但是只完成字节序的拷贝，即浅拷贝</li><li>如果类中没有涉及资源申请的时候，写不写拷贝构造都可以；但是如果涉及到资源申请，就必须写拷贝构造，否则会出现两个不同的对象指向同一块空间</li></ol><h2 id="赋值运算符重载">赋值运算符重载</h2><ol type="1"><li>函数名是operate后面加需要重载的运算符</li><li>".* " "::" "sizeof" "?:" "." 这5个运算符不能重载<br /></li><li>赋值运算符重载格式：<ul><li>参数类型：const T&amp;</li><li>返回值类型：T&amp;，有返回值是为了连续赋值</li><li>检测是否是自己给自己赋值</li><li>返回*this，要符合连续赋值的定义</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; d)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)</span><br><span class="line">       &#123;</span><br><span class="line">            _year = d._year;</span><br><span class="line">            _month = d._month;</span><br><span class="line">            _day = d._day;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>赋值运算符重载只能重载成类的成员函数，不能重载成全局函数</li><li>同拷贝构造一样，默认的赋值运算符重载只完成浅拷贝</li></ol><h2 id="const成员">const成员</h2><p>const修饰的“成员函数”成为const成员函数，实际上修饰的是this指针，表明在该成员函数中不能对类中的任何成员进行修改</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407011553818.png" /></p><h1 id="初始化列表">初始化列表</h1><blockquote><p>以一个冒号开始，接着是以一个逗号分隔的数据成员列表，每个“成员变量”后面跟一个放在括号中的初始值或者表达式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)     </span><br><span class="line">: _year(year)</span><br><span class="line">    , _month(month)</span><br><span class="line">    , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol type="1"><li>每个成员变量在初始化列表中只能出现一次，初始化只能初始化一次</li><li>类中包含以下成员，必须放在初始化列表中初始化<ul><li>引用成员变量</li><li>const成员变量</li><li>自定义类型成员（且该类没有默认构造函数时）</li></ul></li><li>成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中初始化的顺序无关</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 类和对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转曲线的侧面积和体积</title>
      <link href="/2024/06/10/%E6%97%8B%E8%BD%AC%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BE%A7%E9%9D%A2%E7%A7%AF%E5%92%8C%E4%BD%93%E7%A7%AF/"/>
      <url>/2024/06/10/%E6%97%8B%E8%BD%AC%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BE%A7%E9%9D%A2%E7%A7%AF%E5%92%8C%E4%BD%93%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406100931602.jpg" /></p><h1 id="曲线与x轴所围的面积">曲线与x轴所围的面积</h1><p>抽出微元<spanclass="math inline">\(\Longrightarrow\)</span><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406100935009.jpg" style="zoom:33%;" />，其中<spanclass="math inline">\(f(x+dx)=f(x)+f&#39;(x)dx\)</span></p><p><span class="math inline">\(\RightarrowdS=\frac{1}{2}[f(x)+f(x+dx)]dx =\frac{1}{2}[2f(x)+f&#39;(x)dx]dx\)</span></p><p><span class="math inline">\(\Rightarrow dS \sim f(x)dx\)</span></p><h1id="曲线绕x轴一周所围图形的侧面积">曲线绕x轴一周所围图形的侧面积</h1><p>求出微元<span class="math inline">\(\Longrightarrow ds =\sqrt{1+f&#39;(x)}dx\)</span></p><p>圆台面积：$(r_1+r_2)l $</p><p><span class="math inline">\(\Rightarrow d_{S\text{侧}}=\pi[f(x)+f(x+dx)]ds=\pi[2f(x)+f&#39;(x)dx]\sqrt{1+f&#39;(x)^2}dx\)</span></p><p><span class="math inline">\(\Rightarrow d_{s\text{侧}}\sim 2\pif(x)\color{red}{ds}\)</span> <span class="math inline">\(\sim 2\pif(x)\sqrt{1+f&#39;(x)^2}dx\)</span></p><h1 id="曲线绕x轴一周所围图形的体积">曲线绕x轴一周所围图形的体积</h1><p>圆台体积公式：<span class="math inline">\(\frac{1}{3}\pih(r_1^2+r_1r_2+r_2^2)\)</span></p><p><span class="math inline">\(\Rightarrow dV_x=\frac{1}{3}\pidx[f^2(x)+f(x)[f(x)+f&#39;(x)dx]+[f(x)+f&#39;(x)]^2]\)</span></p><p><span class="math inline">\(\Rightarrow dV_x\sim \pif^2(x)\color{red}{dx}\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旋转曲线的侧面积和体积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k叉树</title>
      <link href="/2024/06/07/k%E5%8F%89%E6%A0%91/"/>
      <url>/2024/06/07/k%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>含n个结点的k叉树，最小深度为 <spanclass="math inline">\(\color{blue}{\lfloor log_2[(k-1)n]+1\rfloor} +1\)</span>，最大深度为<spanclass="math inline">\(\color{blue}{n}\)</span></p><blockquote><p>解析：最小深度即使让前面的所有层是满的，最后一层尽可能满</p><p><span class="math inline">\(\frac{k^{h - 1}-1}{k-1}&lt;n \leq\frac{k^h-1}{k-1}\)</span> <spanclass="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(h-1&lt;log_k[n(k-1)+1]\leq h\)</span></p><p>最大深度即使每一层都只有一个元素</p></blockquote><p>满k叉树，根的编号为1</p><ol type="1"><li>求p的第i个孩子的编号<spanclass="math inline">\(\color{blue}{k(p-1)+1+i}\)</span></li></ol><blockquote><p>解析：k(p-1)表示前p-1个结点所拥有的所有孩子的数量，即p的第1个孩子之前的所有孩子的数量（除了根节点不是任何节点的孩子），加一加的是根节点</p></blockquote><ol start="2" type="1"><li>p的父亲节点的编号<span class="math inline">\(\color{blue}{\lfloor\frac{p+(k-2)}{k}\rfloor}\)</span></li></ol><blockquote><p>解析：观察发现k叉树中每个节点的子节点的后面两个节点的编号除以k为父节点的编号，倒数第2个叉的编号是父节点的k倍</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASL</title>
      <link href="/2024/06/05/ASL/"/>
      <url>/2024/06/05/ASL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希表">哈希表</h1><h2 id="链地址">链地址</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051358262.png" /></p><p><strong>查找成功时的平均查找长度</strong></p><blockquote><p>ASL成功 = 表中每个元素查找成功时的比较的次数 /待查找的所有元素的个数</p></blockquote><p>ASL成功 = (1 * 5 + 2 * 2 + 3 * 1) / 8</p><p><strong>查找失败时的平均查找长度</strong></p><blockquote><p>ASL失败 = 每个链表上一直查找到空所需要的次数 / 表的长度</p></blockquote><p>ASL失败 = (4 + 1 + 1+ 3 + 1 + 1 + 2 + 2 + 1 + 2) / 10</p><h2 id="散列表">散列表</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051451626.png" /></p><p><strong>查找成功时的平均查找长度</strong></p><blockquote><p>ASL成功 = 从计算得到的位置往后查查到现在位置需要的次数 /待查找所有元素的个数</p></blockquote><p>ASL成功 = (1 + 2 + 1 + 1 + 1 + 3 + 3) / 7</p><p><strong>查找失败时的平均查找长度</strong></p><blockquote><p>ASL失败 = 表中从0~MOD-1中每个格子到下一个空格子需要的查找次数 /MOD的数（因为结果只有可能在0~MOD里面）</p></blockquote><p>ASL失败 = (3 + 2 + 1 + 2 + 1 + 5 + 4 ) / 7</p><h1 id="顺序查找">顺序查找</h1><p>查找方式为从头查到尾，找到待查找元素则为成功，找到尾部仍未找到则为失败，所以Ci（第i个元素的比较次数）取决于它在表中的位置</p><p>ASL成功 = <span class="math inline">\(\frac{1}{n}\cdot\frac{n(n+1)}{2}=\frac{n+1}{2}\)</span></p><p>ASL失败 = <span class="math inline">\(n\)</span></p><h1 id="折半查找">折半查找</h1><p>化为二叉排序树（判定树）</p><h1 id="二叉排序树">二叉排序树</h1><p>ASL成功 = <span class="math inline">\(\sum\limits_{i=1}^{n}P_i *level(k_i)\)</span>(Pi为查找k的概率，level(Ki)为k对应内部结点的层次)</p><p>ASL失败 = <span class="math inline">\(\sum\limits_{i=0}^{n}q_i*level(U_i)\)</span>(有n + 1个外部结点，用Ei(0 &lt;= i &lt;=n)表示，qi表示查找属于Ei中关键字的概率，level(Ui)表示Ei对应外部结点的层次)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051520395.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-树和B+树</title>
      <link href="/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/"/>
      <url>/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="b树">B树</h3><h4 id="b树的定义"><em>B树的定义</em>：</h4><p>一颗m阶B树是一颗平衡的m路搜索树</p><h4 id="b树的特性"><strong><em>B树的特性</em></strong>：</h4><ol type="1"><li><p>每个结点至少两个子女</p></li><li><p>每个非根节点包含的关键字个数n：<span class="math inline">\(\lceilm/2 \rceil - 1 \leq n \leq m-1\)</span>，</p><p>每个非根节点子树个数k：<span class="math inline">\(\lceil m/2 \rceil\leq k \leq m\)</span></p></li><li><p>根节点的关键字个数n：<span class="math inline">\(1 \leq n \leqm-1\)</span></p><p>根节点的子树个数k：<span class="math inline">\(2 \leq n \leqm\)</span></p></li><li><p>所有的非终端结点中包含下列信息数据<spanclass="math inline">\((n，A_0，K_1,A_1,K_2,A_2,…,K_n,A_n)\)</span></p><ul><li><span class="math inline">\(K_i是关键字，K_i &lt;K_{i+1}\)</span></li><li><spanclass="math inline">\(A_i\)</span>为指向子树根节点的指针，且指针<spanclass="math inline">\(A_{i-1}\)</span>所指子树中所有结点的关键字均小于<spanclass="math inline">\(K_i\)</span></li><li><spanclass="math inline">\(A_n\)</span>所指子树中所有结点的关键字均大于<spanclass="math inline">\(K_n\)</span></li></ul></li><li><p>叶子结点都在同一层</p></li><li><p>对于任一结点其子树高度相同</p></li><li><p>B树的m值比树高大很多，m的实用值一般在100-500</p></li></ol><h4 id="b树的查找"><em>B树的查找：</em></h4><p>待查找元素<span class="math inline">\(x_0\)</span>，如果：</p><ol type="1"><li><span class="math inline">\(K_i &lt; x &lt; K_{i+1}(1 \leq i&lt;n)\)</span>，准备查找<span class="math inline">\(A_i\)</span>页</li><li><span class="math inline">\(x &lt; K_1\)</span>，准备查找<spanclass="math inline">\(A_0\)</span>页</li><li><span class="math inline">\(x &gt; K_n\)</span>，准备查找<spanclass="math inline">\(A_n\)</span>页</li></ol><p>页内存储方式：顺序存储或者采用二叉排序树的形式</p><p>页内检索算法：顺序检索或者折半查找</p><h4id="b树的高度不包括叶子结点"><em>B树的高度（不包括叶子结点）：</em></h4><p>含n个关键字的m阶B树：</p><ul><li><p>最小高度：</p><p>让每个结点尽可能的满，每个结点有<spanclass="math inline">\(m-1\)</span>个关键字，<spanclass="math inline">\(m\)</span>个分叉，</p><p>则 <span class="math inline">\(n \leq(m-1)(1+m+m^2+m^3+...+m^{h-1})=m^h-1\)</span>，</p><p>所以 <span class="math inline">\(\color{red}h \geqlog_m(n+1)\)</span></p></li><li><p>最大高度：</p><p>让各层分支尽可能少，即根节点有两个分支，其他节点只有<spanclass="math inline">\(\lceil m/2\rceil\)</span>个分支</p><p>各层节点至少有：</p><p>第一层 1、第二层 2、第三层 <span class="math inline">\(2\lceilm/2\rceil\)</span>、第三层 $2m/2^2 $ <spanclass="math inline">\(......\)</span></p><p>第<span class="math inline">\(h\)</span>层 <spanclass="math inline">\(2\lceil m/2\rceil ^{h-2}\)</span>、第<spanclass="math inline">\(h+1\)</span>层（即叶子节点/失败结点） <spanclass="math inline">\(2\lceil m/2\rceil ^{h-1}\)</span></p><p>n个关键字的B树一定有<spanclass="math inline">\(n+1\)</span>个叶子结点，所以<spanclass="math inline">\(n+1\geq 2\lceil m/2\rceil^{h-1}\)</span>，</p><p>即<span class="math inline">\(\color{red}h \leq log_{\lceilm/2\rceil} \frac{n+1}{2}+1\)</span></p></li></ul><h4 id="b树的插入"><em>B树的插入：</em></h4><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405090936688.mp4" width="100%" height="100%" controls="controls"></video>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B-树和B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学上</title>
      <link href="/2024/05/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%8A/"/>
      <url>/2024/05/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合"><strong>集合</strong></h1><ul><li><p>常见集合：</p><p>N：正整数或自然数集合</p><p><span class="math inline">\(N_m\)</span>：<spanclass="math inline">\(1,2,...,m\)</span></p><p>Z：非负整数集合</p><p><span class="math inline">\(Z_m\)</span>：<spanclass="math inline">\(0,1,2,...,m-1\)</span></p><p>I：整数集合</p><p>P：素数集合</p><p>C：复数集合</p></li><li><p>寻常集：不包含自身作为元素</p><p>不寻常集：包含自身作为元素</p></li><li><p>基数：集合A中不同元素的个数，记作<spanclass="math inline">\(\#A\)</span></p></li><li><p>幂集：设有集合A，由A的所有子集组成的集合，称为集合A的幂集，记作<spanclass="math inline">\(2^A\)</span>，即<spanclass="math inline">\(2^A=\left\{S|S \subset A\right\}\)</span></p></li><li><p>设A是具有基数<span class="math inline">\(\#A\)</span>的有限集，则<spanclass="math inline">\(\#(2^A)=2^{\#A}\)</span></p></li><li><p>补集：集合A关于全集合U的相对补集称为A的绝对补集，记作<spanclass="math inline">\(A&#39;\)</span></p></li><li><p><span class="math inline">\(a\inA\)</span>表示a是集合A的一个元素，<span class="math inline">\(B \subsetA\)</span>​表示B是A的一个子集，它意味着B中的每一个元素也是集合A中的元素</p><ul><li>若<span class="math inline">\(A\in B,B\subset C\)</span>，则<spanclass="math inline">\(A\in C\)</span> <spanclass="math inline">\(\color{red}{（只有这一种组合是对的）}\)</span></li><li><span class="math inline">\(\color{red}{错错错:}\)</span><ul><li>若<span class="math inline">\(A\in B,B\subset C\)</span>，则<spanclass="math inline">\(A\subset C\)</span></li><li>若<span class="math inline">\(A\subset B,B\in C\)</span>，则<spanclass="math inline">\(A\in C\)</span></li><li>若<span class="math inline">\(A\subset B,B\in C\)</span>，则<spanclass="math inline">\(A\subset C\)</span></li></ul></li></ul></li><li><p>A与B的对称差：集合A、B，由属于A但不属于B以及属于B但不属于A的所有元素构成的集合，记作<spanclass="math inline">\(A \oplus B\)</span>，即<spanclass="math inline">\(A \oplus B = (A-B)\cup (B-A)\)</span></p></li><li><p>集合的运算定律</p><ul><li>同一律： <span class="math inline">\(A\cup \varnothing =A\)</span>，<span class="math inline">\(A \cap U=A\)</span></li><li>互补律：<span class="math inline">\(A \cup A&#39; =U\)</span>，<span class="math inline">\(A \cap A&#39; =\varnothing\)</span></li><li>对合律：<span class="math inline">\((A&#39;)&#39; = A\)</span></li><li>等幂律：<span class="math inline">\(A \cup A = A,A \cap A =A\)</span></li><li>零一律：<span class="math inline">\(A \cup U = U, A \cap \varnothing= \varnothing\)</span></li><li>吸收率：<span class="math inline">\(A \cup (A \cap B) = A, A \cap (A\cup B) = A\)</span></li><li>德摩根律：<span class="math inline">\((A \cup B)&#39; = A&#39; \capB&#39;, (A \cap B)&#39; = A&#39; \cup B&#39;\)</span></li></ul></li><li><p>对称差运算</p><ul><li><span class="math inline">\(A \oplus B = B \oplus A\)</span></li><li><span class="math inline">\((A \oplus B)\oplus C = A \oplus (B\oplus C)\)</span></li><li><span class="math inline">\(A \cap (B \oplus C) = (A \cap B)\oplus(A \cap C)\)</span></li><li><span class="math inline">\(A \oplus \varnothing =A, A\oplus U =A&#39;\)</span></li><li><span class="math inline">\(A \oplus A=\varnothing, A\oplusA&#39;=U\)</span></li><li><span class="math inline">\(A\oplus(A\oplus B)=B\)</span></li></ul></li><li><p>分划：设<span class="math inline">\(\pi= \left\{A_i\right\}_{i\inK}\)</span>是集合A的某些非空子集的集合，如果集合A的每个元素在且只在其中之一<spanclass="math inline">\(A_i\)</span>中，即如果</p><ol type="1"><li><p>当<span class="math inline">\(i \neq j\)</span>时，<spanclass="math inline">\(A_i \cap A_j = \varnothing\)</span></p></li><li><p><span class="math inline">\(\bigcup\limits_{i \in K}A_i =A\)</span></p><p>则称集合<spanclass="math inline">\(\pi\)</span>时集合A的一个分划</p></li></ol></li></ul><h1 id="关系"><strong>关系</strong></h1><h2 id="集合的笛卡尔积">集合的笛卡尔积</h2><ul><li><p>序偶：有序二元组</p></li><li><p>笛卡尔积：设<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>时、是任意集合，所有有序n元组<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>的集合，称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>的笛卡尔积，记作<spanclass="math inline">\(A_1 \times A_2 \times...\times A_n\)</span></p><p>即<span class="math inline">\(A_1 \times A_2 \times...\times A_n =\left\{(a_1,a_2,...,a_n)|a_i \in A_i\right\}\)</span></p></li><li><p><span class="math inline">\(A \times B \neq B \timesA\)</span></p><p><span class="math inline">\(A \times B = B \times A =\varnothing\)</span></p></li><li><p><span class="math inline">\(A \times (B \cup C) = (A \times B)\cup (A \times C)\)</span></p><p><strong>证明与笛卡尔积有关的定理利用序偶</strong></p></li></ul><h2 id="关系-1">关系</h2><ul><li><p>笛卡尔积<span class="math inline">\(A_1 \times A_2\times...\times A_n\)</span>的任何一个子集称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>上的n元关系</p></li><li><p>设<spanclass="math inline">\(\rho\)</span>是A到B的一个关系，定义域<spanclass="math inline">\(D_{\rho}\)</span>，值域<spanclass="math inline">\(R_{\rho}\)</span></p></li><li><p>逆关系<span class="math inline">\(\widetilde{\rho} =\left\{(b,a)|(a,b)\in \rho \right\}\)</span></p></li><li><p>若<spanclass="math inline">\(\rho\)</span>是由A到B的一个关系，且<spanclass="math inline">\((a,b)\in \rho\)</span>，则称a对b有关系<spanclass="math inline">\(\rho\)</span>，记作<spanclass="math inline">\(a\rho b\)</span>，</p><p>如果<span class="math inline">\((a,b)\notin\rho\)</span>，则记作<spanclass="math inline">\(a\rho&#39;b\)</span></p></li><li><p>集合A上的关系：由集合A到A自身的关系</p></li><li><p>普遍关系<span class="math inline">\(U_A\)</span>：若<spanclass="math inline">\(\rho = A^2\)</span>，则称<spanclass="math inline">\(\rho\)</span>为A上的普遍关系，即<spanclass="math inline">\(U_A = \left\{(a_i,a_j)|a_i,a_j \inA\right\}\)</span></p><p>恒等关系<span class="math inline">\(I_A\)</span>：<spanclass="math inline">\(I_A=\left\{(a_i,a_i)|a_i \inA\right\}\)</span></p></li><li><p>复合关系：<span class="math inline">\(\rho_1 \cdot \rho_2 =\left\{(a,c)|a\in A，c\in C,且\exists b\in B,s.t.(a\rho_1b,b\rho_2c)\right\}\)</span></p></li><li><p><span class="math inline">\((\rho_1 \cdot \rho_2)\cdot \rho_3 =\rho_1 \cdot (\rho_2 \cdot \rho_3)\)</span></p><p><strong>证明与关系有关的定理利用序偶</strong></p></li></ul><h2 id="关系的表示方法">关系的表示方法</h2><ul><li>关系矩阵<ul><li>设<span class="math inline">\(\rho_1\)</span>是A到B的关系，<spanclass="math inline">\(\rho_2\)</span>是B到C的关系，它们的关系矩阵分别为<spanclass="math inline">\(M_{\rho_1}、M_{\rho_2}\)</span>，则复合关系<spanclass="math inline">\(\rho_1 \cdot \rho_2\)</span>的关系矩阵<spanclass="math inline">\(M_{\rho_1 \rho_2}=M_{\rho_1} \cdotM_{\rho_2}\)</span></li><li><span class="math inline">\(M_{\rho ^n}=M_{\rho}^n\)</span></li></ul></li><li>关系图</li></ul><h2 id="集合a上关系的性质和闭包运算">集合A上关系的性质和闭包运算</h2><ul><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是自反的，否则是非自反的</p><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho&#39;a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反自反的</p></li><li><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rhob\)</span>就有<span class="math inline">\(b\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是对称的，否则是非对称的</p><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>，就必有<spanclass="math inline">\(a=b\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反对称的，也可描述为对于所有的<spanclass="math inline">\(a,b \in A\)</span>，若<spanclass="math inline">\(a \neq b\)</span>，则<spanclass="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>不能同时出现</p></li><li><p>对于所有的<span class="math inline">\(a,b,c \inA\)</span>，若每当有<span class="math inline">\(a\rho b和b\rhoc\)</span>就有<span class="math inline">\(a\rho c\)</span>，则称<spanclass="math inline">\(\rho\)</span>是可传递的，否则，<spanclass="math inline">\(\rho\)</span>是不可传递的</p></li></ul></li><li><p>A上关系的性质在关系矩阵上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>是自反的：主对角线上的元素全为1</li><li><spanclass="math inline">\(\rho\)</span>是对称的：关于主对角线对称</li><li><span class="math inline">\(\rho\)</span>是反对称的：对于<spanclass="math inline">\(i\neq j\)</span>，若<spanclass="math inline">\(r_{ij}=1\)</span>，则<spanclass="math inline">\(r_{ji}=0\)</span></li></ul></li><li><p>A上的关系的性质在关系图上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>​是自反的：每个结点引出一个单边环</li><li><spanclass="math inline">\(\rho\)</span>是反自反的：每个结点无单边环</li><li><span class="math inline">\(\rho\)</span>是对称的：对每一由结点<spanclass="math inline">\(a_i\)</span>指向结点<spanclass="math inline">\(a_j\)</span>的边，必有一相反的边</li><li><spanclass="math inline">\(\rho\)</span>是反对称的：任何两个不同的借点之间最多有一条边</li></ul></li><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><span class="math inline">\(\rho\)</span>的自反闭包<spanclass="math inline">\(r(\rho)\)</span>：<spanclass="math inline">\(r(\rho)=\rho \cup I_A\)</span></li><li><span class="math inline">\(\rho\)</span>的对称闭包<spanclass="math inline">\(s(\rho)\)</span>：<spanclass="math inline">\(s(\rho)=\rho \cup \widetilde{\rho}\)</span></li><li><span class="math inline">\(\rho\)</span>的传递闭包<spanclass="math inline">\(t(\rho)\)</span>：<spanclass="math inline">\(t(\rho)=\bigcup_\limits{i=1}^\infty\rho^i\)</span>​（若<span class="math inline">\(\# A=n\)</span>，则<spanclass="math inline">\(t(\rho)=\bigcup _\limits{i=1}^n\rho^i\)</span>）</li></ul><p><strong><spanclass="math inline">\({\color{red}r(\rho)、s(\rho)、t(\rho)分别是集合A上包含\rho最小的自反关系、对称关系、可传递关系}\)</span></strong></p><p>(可以利用关系图得到传递闭包，只要能到达就有一条线连接)</p></li><li><p>设<span class="math inline">\(\rho_1\)</span>、<spanclass="math inline">\(\rho_2\)</span>是集合A上的关系，且<spanclass="math inline">\(\rho_1 \subset \rho_2\)</span>，则<spanclass="math inline">\(r(\rho_1) \subset r(\rho_2)\)</span>，<spanclass="math inline">\(s(\rho_1) \subset s(\rho_2)\)</span>，<spanclass="math inline">\(t(\rho_1) \subset t(\rho_2)\)</span></p></li></ul><h2 id="集合a上两类重要的关系">集合A上两类重要的关系</h2><h3 id="等价关系">等价关系</h3><p>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它使自反、对称且可传递的，则称<spanclass="math inline">\(\rho\)</span>为A上的等价关系</p><h4 id="等价类">等价类：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则A中等价于a的全体元素的集合，成为a所生成的等价类，用<spanclass="math inline">\([a]_{\rho}\)</span>表示，即<spanclass="math inline">\([a]_{\rho}=\left\{b|b\in A,a\rho b\right\}\)</span></p><p>性质：</p><ol type="1"><li>A中每一个元素生成的等价类非空</li><li>彼此等价的元素属于同一个等价类</li><li>彼此不等价的元素属于不同的等价类，且这些等价类之间没有公共元素</li></ol><h4 id="分划">分划：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则等价类的集合<spanclass="math inline">\(\left\{[a]_{\rho} |a\inA\right\}\)</span>构成A的一个分划</p><p>说明：每一个等价类就是一个分化块，因为A的每一元素的等价类（在<spanclass="math inline">\(\rho\)</span>下）是唯一的，所以分划也是唯一的，这种由等价关系<spanclass="math inline">\(\rho\)</span>的等价类所组成的A的分划，称为A上由<spanclass="math inline">\(\rho\)</span>所导出的等价分化，用<spanclass="math inline">\(\pi_{\rho}^A\)</span>​​表示</p><h4 id="商集">商集：</h4><p>等价类的集合<span class="math inline">\(\left\{[a]_{\rho}|a\inA\right\}\)</span>称为A关于<spanclass="math inline">\(\rho\)</span>的商集，记作<spanclass="math inline">\(A/\rho\)</span>，<spanclass="math inline">\(A/\rho\)</span>的基数称为<spanclass="math inline">\(\rho\)</span>的秩</p><p><spanclass="math inline">\(res_m(i)\)</span>表示用m除以i所得的余数</p><h4 id="细分">细分：</h4><p>如果<span class="math inline">\(I_2\)</span>的每一个分化块都是<spanclass="math inline">\(I_1\)</span>的某一个分化块的子集，则<spanclass="math inline">\(I_2\)</span>是<spanclass="math inline">\(I_1\)</span>的细分</p><h3 id="偏序">偏序</h3><p><strong>偏序</strong>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它是自反、反对称、可传递的，则称<spanclass="math inline">\(\rho\)</span>是A上的一个偏序关系，用<spanclass="math inline">\(\leq\)</span>表示；显然一个偏序的逆也是偏序，用<spanclass="math inline">\(\geq\)</span>表示。</p><p><strong>全序</strong>定义：一个集合A上的偏序，若对于所有的<spanclass="math inline">\(a,b\in A\)</span>，有<spanclass="math inline">\(a\leq b\)</span>或<span class="math inline">\(b\leq a\)</span>，则称它为A上的一个全序。<spanclass="math inline">\(\color{red}{集合A中任意两个元素都是可比的}\)</span></p><p><strong>良序</strong>定义：一个集合A上的偏序，若对于A的每一个非空子集<spanclass="math inline">\(S \subset A\)</span>，在S中存在一个元素<spanclass="math inline">\(a_s\)</span>（S中的最小的元素），使得对于所有<spanclass="math inline">\(s \in S\)</span>，有<spanclass="math inline">\(a_s \leq s\)</span>​，则称它为A上的一个良序。<spanclass="math inline">\(\color{red}{集合A中有最小元素}\)</span></p><p><strong>特点：</strong></p><ul><li>全序或者良序一定是偏序</li><li>偏序不一定是全序或者良序</li><li>一个偏序如果是良序则一定是全序</li></ul><h1 id="函数"><strong>函数</strong></h1><h2 id="函数-1">函数</h2><p><span class="math inline">\(A \timesB\)</span>的每一个子集都是由A到B的关系，其中一部分子集可以用来定义由A到B的函数，用<spanclass="math inline">\(B^A\)</span>表示这些函数的集合，即<spanclass="math inline">\(B^A=\left\{f|f:A\rightarrowB\right\}\)</span>，<spanclass="math inline">\(\color{red}{当A、B都是有限集}\)</span> <spanclass="math inline">\(\color{red}{的时候}\)</span>，<spanclass="math inline">\(\#A=m,\#B=n\)</span>，从A到B不同函数共有<spanclass="math inline">\(n^m\)</span>，即<spanclass="math inline">\(\#(B^A)=(\# B)^{\#A}\)</span></p><h2 id="三种特殊函数">三种特殊函数</h2><p>定义：</p><ul><li>内射：当<span class="math inline">\(a_i \neq a_j\)</span>时，有<spanclass="math inline">\(f(a_i) \neq f(a_j)\)</span>，也就是当<spanclass="math inline">\(f(a_i) = f(a_j)\)</span>时，有<spanclass="math inline">\(a_i=a_j\)</span>（集合A中的不同元素在B中有不同的像）</li><li>满射：B中每一个元素都是A中至少一个元素的像</li><li>双射：集合A和集合B的元素间一一对应</li></ul><p>特点：</p><p>​ 如果A、B都是有限集</p><ul><li><span class="math inline">\(\#A \leq\#B\)</span>时，f有可能时内射</li><li><span class="math inline">\(\#A\geq\#B\)</span>​时，f有可能是满射</li><li><span class="math inline">\(\#A=\#B\)</span>​时，f有可能是双射</li></ul><h2 id="函数的复合">函数的复合</h2><p>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow C\)</span>，那么：</p><ol type="1"><li>如果f和g都是内射，则<spanclass="math inline">\(gf\)</span>也是内射</li><li>如果f和g都是满射，则<spanclass="math inline">\(gf\)</span>也是满射</li><li>如果f和g都是双射，则<spanclass="math inline">\(gf\)</span>​​也是双射</li></ol><p>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow C\)</span>，那么：</p><ol type="1"><li>如果<span class="math inline">\(gf\)</span>是内射，则f是内射</li><li>如果<span class="math inline">\(gf\)</span>是满射，则g是满射</li><li>如果<spanclass="math inline">\(gf\)</span>是双射，则f是内射，g是满射</li></ol><h2 id="逆函数">逆函数</h2><ol type="1"><li>设函数<span class="math inline">\(f:A\rightarrowB\)</span>是一个双射，则逆函数<spanclass="math inline">\(f^{-1}\)</span>也是一个双射</li><li>设函数<span class="math inline">\(f:A\rightarrowB\)</span>是一个双射，则<spanclass="math inline">\((f^{-1})^{-1}=f\)</span></li><li>如果函数<span class="math inline">\(f:A\rightarrowB\)</span>是可逆的，则有<spanclass="math inline">\(f^{-1}f=I_A,ff^{-1}=I_B\)</span></li><li>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow A\)</span>，当且仅当<spanclass="math inline">\(gf=I_A,fd=I_B\)</span>时，有<spanclass="math inline">\(g=f^{-1}\)</span></li><li>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrowA\)</span>，且f和g都是可逆的，则<spanclass="math inline">\((gf)^{-1}=f^{-1}g^{-1}\)</span></li></ol><h2 id="集合的基数">集合的基数</h2><h3 id="概念">概念</h3><p>概念：集合的基数即集合中不同元素的个数</p><p><strong>等势</strong>：设有集合A、B，如果存在双射函数<spanclass="math inline">\(f:A\rightarrowB\)</span>，则说A和B有相同的基数，或者说A和B等势，记作<spanclass="math inline">\(A\sim B\)</span></p><p>注：对于有限集来说，A和B有相同的基数指的是它们元素个数相同</p><p><strong>有限集</strong>：如果集合A与集合<spanclass="math inline">\(N_m=\left\{1,2,...,m\right\}\)</span>属于同一基数类，则称集合A是有限集。有限集的基数就是该集合中的元素个数。</p><p><strong>可数集</strong>：如果集合<span class="math inline">\(A\simN\)</span>，则称A为可数集。可数集的基数记作<spanclass="math inline">\(\aleph_0\)</span>。一个集合是可数集的<strong>充分必要条件</strong>是它全部元素可以排成一个无穷序列的形式。</p><p><strong>可计数集：</strong>有限集和可数集称为可计数集。</p><h3 id="性质">性质</h3><ol type="1"><li><p>可数集的无限子集仍是可数集</p></li><li><p>任一无限集A必包含一可数子集</p></li><li><p>设集A可数，集B有限，且<span class="math inline">\(A\capB=\varnothing\)</span>，则<span class="math inline">\(A\cupB\)</span>可数</p></li><li><p>若A、B都是可数集，<span class="math inline">\(A\capB=\varnothing\)</span>，则<span class="math inline">\(A\cupB\)</span>​可数</p></li><li><p>有限个可数集的并是可数集</p></li><li><p>可数个(互不相交的)可数集的并依旧是可数集</p></li><li><p>设有集合A，B，若A的子集<spanclass="math inline">\(A_1\)</span>和B的子集<spanclass="math inline">\(B_1\)</span>，使得<spanclass="math inline">\(A\sim B_1,B\sim A_1\)</span>，则<spanclass="math inline">\(A\sim B\)</span></p></li></ol><h1 id="图论"><strong>图论</strong></h1><h2 id="基本概念">基本概念</h2><h3 id="概念-1">概念</h3><ul><li><p>n阶图：有n个结点的图</p></li><li><p>(n, m)图：n个结点m条边</p><p>(n, 0)图：零图</p><p>(1, 0)图：平凡图</p></li><li><p>完全图：任意两个不同结点都相邻接的图叫完全图</p><p>补图：由G所有节点和为了使G变成完全图添加的边构成的图</p></li><li><p>d次正则图：所有节点都具有同一度d</p></li><li><p>子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p><p>真子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span> , 且 <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\neq\)</span> <spanclass="math inline">\(E\)</span></p><p>生成子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(=\)</span> <span class="math inline">\(V\)</span>, <span class="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p></li><li><p>图的同构：两个图存在边与边之间的双射关系</p></li><li><p>伪图：设 <span class="math inline">\(G = (V, E)\)</span> ,V是一个有限非空集合，E是V中任意元素的非有序对偶的多重集</p><ul><li>在E中允许出现相同元素的对偶</li><li>在E中无序对偶{<span class="math inline">\({Vi,Vj}\)</span>}可能出现r次</li></ul></li><li><p>多重图： 没有长度为1的环的伪图</p><p>简单图：没有自环且没有重数大于1的边</p></li><li><p>邻接（结点与结点，边与边）、关联（结点与边）、孤立点、孤立边</p></li></ul><h3 id="性质定理">性质定理</h3><ul><li>握手定理----在(n, m)图中，<spanclass="math inline">\(\sum\limits_{i=1}^{n}\)</span>deg(<spanclass="math inline">\(vi\)</span>)<spanclass="math inline">\(=2m\)</span>​;</li><li>n阶完全图<span class="math inline">\(Kn\)</span>中，<spanclass="math inline">\(m=\)</span><spanclass="math inline">\(\frac{1}{2}\)</span>n(n-1);</li><li>两个图同构的必要条件：<ol type="1"><li>它们有相同的结点数和相同的边数</li><li>对应结点的度数相同</li></ol></li></ul><h2 id="路">路</h2><h3 id="概念-2">概念</h3><ul><li>开路、真路、回路、环<ul><li>没有重复结点的开路是真路</li><li>没有重复结点的回路是环</li></ul></li><li>短程、距离</li></ul><h3 id="性质定理-1">性质定理</h3><ul><li>设G是具有结点集<spanclass="math inline">\(V={v_1,v_2,...,v_n}\)</span>的图，则对于任意两个相连接的结点<spanclass="math inline">\(v_i,v_j \in V (v_i \neqv_j)\)</span>，其短程是一条长度不大于n-1的真路</li></ul><h2 id="图的矩阵表示">图的矩阵表示</h2><p>设<span class="math inline">\(G = (V, E)\)</span>，其中 <spanclass="math inline">\(V = \left\{ v_1, v_2, ...,v_n\right\}\)</span></p><ul><li><p>邻接矩阵<span class="math inline">\(A = (a_{ij})\)</span></p><p><span class="math display">\[ a_{ij} =\left\{ \begin{aligned} 1&amp;&amp;{若\left\{ v_i, v_j \right\}} \in E \\ 0&amp; &amp;否则\end{aligned} \right. \]</span>​</p><ul><li>一个图的邻接矩阵是对角线元素均为0的0-1矩阵，反之，一个对角线全为0的0-1矩阵一定可以唯一地做一个图</li><li>如果两个图的邻接矩阵可以通过行列变换得到，那么这两个图同构</li><li>图G的邻接矩阵A的第i行（或第i列）出现1的个数就是节点<spanclass="math inline">\(v_i\)</span>​的度</li><li><span class="math inline">\(A^l (l = 1, 2, 3, ...)\)</span>的<spanclass="math inline">\((i, j)\)</span>项元素<spanclass="math inline">\(a_{ij}^{(l)}\)</span>是连接<spanclass="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>长度为l的路的总数</li></ul></li><li><p>关联矩阵<span class="math inline">\(I =(b_{ij})\)</span>是一个n<spanclass="math inline">\(\times\)</span>m矩阵</p><p><span class="math display">\[b_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若v_i和e_j是关联的 \\ 0&amp; &amp;否则  \end{aligned}\right.\]</span></p><ul><li>I中每一列都正好包含两个 1，并且任何两个列都是不相同的</li><li>第i行中的1的个数即为节点<spanclass="math inline">\(v_i\)</span>的度</li></ul></li><li><p>连接矩阵<span class="math inline">\(C = (c_{ij})\)</span></p><p><span class="math display">\[c_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若从v_i到v_j存在一条路 \\ 0&amp; &amp;否则 \end{aligned}\right.\]</span>​</p><ul><li>当C中所有元素都为1时图是连通 的</li></ul></li></ul><h2 id="图的连通性">图的连通性</h2><h3 id="概念-3">概念</h3><ul><li><p>连通图：如果存在一条路连接<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>，则称结点<spanclass="math inline">\(v_i\)</span>与<spanclass="math inline">\(v_j\)</span>是连接的，若G中任意两个节点均是连接的，则称图G是连通的</p></li><li><p>割边：如果在图G中删去边<span class="math inline">\(\left\{v_i,v_j\right\}\)</span>后，图G的分图数增加，则称边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>是G的割边</p></li><li><p>割点：如果在图G中删去结点<spanclass="math inline">\(v_i\)</span>及与其相关联的边之后，图G的分图数增加，则称结点<spanclass="math inline">\(v_i\)</span>是G的割点</p></li><li><p>边割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有E的子集S，使得在图G中删去S中的所有边后，得到的子图G-S变成具有两个分图的不连通图，而删去了S的任一真子集后，得到的子图仍然是连通图，则称S是G的一个边割集</p></li><li><p>点割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有V的子集<spanclass="math inline">\(V_1\)</span>使得在图G中删除了<spanclass="math inline">\(V_1\)</span>中的所有结点之后，所得到的子图<spanclass="math inline">\(G - V_1\)</span>不连通或为平凡图，则称<spanclass="math inline">\(V_1\)</span>是G的一个点割集</p><p><strong>（割点是点割集的特例）</strong></p></li><li><p>断集：设<span class="math inline">\(G = (V,E)\)</span>是一连通图，<span class="math inline">\(V_1 \subsetV\)</span>, G中端点分别属于<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>的所有边的集合，则成为G的断集</p><p><strong>边割集是断集的特例</strong></p></li><li><p>关联集：设v是图<span class="math inline">\(G =(V,E)\)</span>的一个结点，与v相关联的所有边的集合，称为结点v的关联集，记作<spanclass="math inline">\(S(v)\)</span></p></li><li><p>点连通度：<span class="math inline">\(K(G) = min\left\{\\#V_i|V_i是G的点割集\right\}\)</span>，点连通度是为了使G成为一个非连通图需要删除的点的最少数目</p></li><li><p>边连通度：λ<span class="math inline">\((G) = min\left\{ \#S|S是G的断集\right\}\)</span>，边连通度是为了使G成为一个非连通图需要删去的边的最少数目</p></li></ul><h3 id="性质定理-2">性质定理</h3><ul><li>图G中，边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>为割边的充要条件是边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>不在G的任何环中出现</li><li>在图G中，结点v为割点的充要条件是存在两个结点u和w，使得连接u和w的所有路中都出现结点v</li><li>对于一个给定的图<span class="math inline">\(G = (V, E)\)</span>，如果能把结点集V分成两个互补的子集<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(V&#39;\)</span>，使得同一结点集中的任意两个结点之间，至少存在一条不包含另一个结点子集中的任何结点的路，那么G中的端点分别在<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>​中的边组成G的一个边割集</li><li>对于任意的图<span class="math inline">\(G = (V, E)\)</span>，有<spanclass="math inline">\(K(G) \leq \lambda(G)\leq  \delta(G)\)</span>（其中<spanclass="math inline">\(\delta(G)\)</span>是图G的最小度</li></ul><h2 id="欧拉图">欧拉图</h2><h3 id="概念-4">概念</h3><ul><li>欧拉回路：在图G中找到一个回路，它通过G的每条边一次且仅一次</li><li>欧拉路：具有欧拉回路的图</li><li>欧拉图：通过图G每条边一次且仅一次的开路</li></ul><h3 id="性质定理-3">性质定理</h3><ul><li>一个连通图G为欧拉图的充要条件是G的每一结点的度均为偶数</li><li>连通图G具有一条连接结点<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>的欧拉路的充要条件是，<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>​是G中仅有的具有奇数度的结点</li><li>欧拉回路的边不可以重复但是结点可以重复，所以欧拉回路不一定是环路</li></ul><h2 id="哈密顿图">哈密顿图</h2><h3 id="概念-5">概念</h3><ul><li><p>哈密顿环：找到一个环它通过图G的每个结点一次且仅一次</p><p>哈密顿路：通过图G每个结点一次且仅一次的开路</p><p>哈密顿图：具有哈密顿环的图</p></li><li><p>闭图：设G是具有n个结点的图，若对于<spanclass="math inline">\(deg(u)+deg(v) \geqn\)</span>​的每一对结点u和v，均有u和v相邻接，则称图G是闭图</p></li><li><p>闭包：图G的闭包是一个与G有相同结点集的闭图，记作<spanclass="math inline">\(G_c\)</span>，使<span class="math inline">\(G\subset G_c\)</span>，且异于<spanclass="math inline">\(G_c\)</span>的任何图H，若<spanclass="math inline">\(G \subset H \subset G_c\)</span>，则G不是闭图</p><p><strong>图G的闭包是包含图G的最小闭图</strong></p></li></ul><h3 id="性质定理-4">性质定理</h3><ul><li>图G的闭包是唯一的</li><li>每个哈密顿图都一定是连通的</li><li>若图<span class="math inline">\(G =(V,E)\)</span>是哈密顿图，则对于V的任何一个非空子集S，有<spanclass="math inline">\(W(G-S)\leq\#S\)</span>，这里<spanclass="math inline">\(W(G-S)\)</span>表示G - S中分图的个数</li><li>设G是具有n个结点的图，若有结点u和v不相邻接，且<spanclass="math inline">\(deg(u) + deg(v) \geq n\)</span>，则当且仅当图<spanclass="math inline">\(G+\left\{u,v\right\}\)</span>是哈密顿图时，图G时哈密顿图</li><li>设有图G当且仅当<spanclass="math inline">\(G_c\)</span>​是哈密顿图时，图G是哈密顿图</li><li>若图G的闭包<span class="math inline">\(G_c = K_n\)</span>，且<spanclass="math inline">\(n \geq 3\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#G \geq3\)</span>，若V中任意两个不相邻的结点u和v，均有<spanclass="math inline">\(deg(u) + deg(v) \geqn\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#V \geq 3\)</span>，若对于任意的<spanclass="math inline">\(v \in V\)</span>，均有<spanclass="math inline">\(deg(v) \geq\frac{n}{2}\)</span>，则G是哈密顿图</li></ul><h2 id="树">树</h2><h3 id="概念-6">概念</h3><ul><li><p>树：不包含环的连通图</p><p>树林：不包含环的图</p><p>树叶：度为1的结点</p></li><li><p>生成树：若连通图G的生成子图T是一棵树，T是G的生成树</p><p>最小生成树：在所有生成树中有最小权值</p></li><li><p>若G是一<spanclass="math inline">\((n,m)\)</span>连通图，G的生成树<spanclass="math inline">\(T_G\)</span>是一<spanclass="math inline">\((n,n-1)\)</span>图</p><p>环秩：在得到<spanclass="math inline">\(T_G\)</span>之前需要删除的边的总数为<spanclass="math inline">\(m-(n-1)\)</span>，该数为环秩，环秩是为了“弄破”G的所有环而必须由G中删去的边的最小数目</p><p>弦：被删去的每一条边</p><p>枝：在生成树<span class="math inline">\(T_G\)</span>中的边</p></li></ul><h1 id="性质定理-5">性质定理</h1><ul><li><p>在<span class="math inline">\((n,m)\)</span>树中，<spanclass="math inline">\(m = n - 1\)</span></p></li><li><p>具有两个或更多个结点的树至少有两片树叶</p></li><li><p>两个节点之间由唯一的真路连接的图就是树</p><p><span class="math inline">\(m=n-1\)</span>的连通图是树</p><p><span class="math inline">\(m=n-1\)</span>​且无环的图是树</p></li></ul><h2 id="有向树">有向树</h2><h3 id="概念-7">概念</h3><ul><li><p>有向树：一个不包含环的有向图G，若它只有一个结点<spanclass="math inline">\(v_0\)</span>入度为0，而所有其它结点入度为1</p></li><li><p>根：节点<span class="math inline">\(v_0\)</span></p><p>树叶或终点：出度为0的结点</p><p>级：从<span class="math inline">\(v_0\)</span>到结点<spanclass="math inline">\(v_i\)</span>的距离</p></li><li><p>m元树：在一有向树中，若每一个结点的出度都小于或等于m</p><p>完全m元树：若每个结点的出度等于m或0</p></li><li><p>外部结点：树叶结点</p><p>内部结点：分支结点</p></li><li><p>外部路径长度：根到所有外部结点的距离和</p><p>内部路径长度：根到所有内部结点的距离和</p><p>树的路径长度：根到所有结点的距离和</p></li><li><p>有序树：规定了每一级上结点的次序，一般规定同一级结点的次序为从左到右</p></li><li><p>前缀码：在一个序列的集合中，如果没有一个序列是另一个序列的前缀，则称该序列的集合为前缀码</p></li><li><p>最优树：一颗带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树，如果在所有带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树中具有最小的权，则称为最优树</p></li></ul><h3 id="性质定理-6">性质定理</h3><ul><li>一颗二元树第i级的最大结点数是<spanclass="math inline">\(2^i\)</span>，高度为h的二元树的最大结点数为<spanclass="math inline">\(2^{h+1}-1\)</span>​</li><li>设T为一颗完全二元树（T不为孤立结点）有r个内部结点，内部路径长度为I，外部路径长度为E，则<spanclass="math inline">\(E=I+2r\)</span></li><li>设T为一颗二元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，<spanclass="math inline">\(n_2\)</span>个出度为2的结点，则<spanclass="math inline">\(n_2=n_0-1\)</span></li><li>设T是一颗完全二元树，有n个结点，<spanclass="math inline">\(n_0\)</span>个叶节点，则<spanclass="math inline">\(n=2n_0-1\)</span></li><li>设T是一颗完全m元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，t个分支结点，则<spanclass="math inline">\((m-1)t=n_0-1\)</span></li></ul><h2 id="二部图">二部图</h2><h3 id="概念-8">概念</h3><ul><li><p>二部图：若一个图G的结点集V能分成两个子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>使得<span class="math inline">\(V_1\cup V_2=V\)</span>,<span class="math inline">\(V_1 \cap V_2 =\varnothing\)</span>，使得G的每一条边<spanclass="math inline">\(\left\{V_i,V_j\right\}\)</span>的端点<spanclass="math inline">\(v_i \in V1, v_j \inV_2\)</span>，则称图G是一个二部图</p><p>完全二部图：如果<spanclass="math inline">\(V_1\)</span>的每一个结点和<spanclass="math inline">\(V_2\)</span>的每一个结点想邻接，则G为完全二部图</p></li><li><p>匹配：设G是具有互补结点子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>的二部图，其中<spanclass="math inline">\(V_1=\left\{v_1,v_2,...,v_q\right\}\)</span>，<spanclass="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配是G的一个子图，它由q条边<spanclass="math inline">\(\left\{v_1,v_1&#39;\right\},\left\{v_2,v_2&#39;\right\},...,\left\{v_q,v_q&#39;\right\}\)</span>组成，其中<spanclass="math inline">\(v_1&#39;,v_2&#39;,...v_q&#39;\)</span>是<spanclass="math inline">\(V_2\)</span>中q个不同的元素</p></li></ul><h3 id="性质定理-7">性质定理</h3><ul><li>图G为二部图的充要条件是至少有两个节点，它的所有回路均为偶数长</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>必要条件</strong>是<spanclass="math inline">\(\# V_2 \geq \#V_1\)</span></li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充要条件</strong>是<spanclass="math inline">\(V_1\)</span>中每k个结点至少和<spanclass="math inline">\(V_2\)</span>​中k个结点相邻接</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充分条件</strong>是，存在某一整数<spanclass="math inline">\(t&gt;0\)</span>使<ol type="1"><li>对<spanclass="math inline">\(V_1\)</span>中每个结点，至少有t条边与其相关联</li><li>对<spanclass="math inline">\(V_2\)</span>中每个结点，至多有t条边与其相关联</li></ol></li></ul><h2 id="平面图">平面图</h2><h3 id="概念-9">概念</h3><ul><li>平面图：能画于平面上而无任何交叉</li></ul><h3 id="性质定理-8">性质定理</h3><ul><li>平面图的欧拉公式：设G是一连通的平面图，则有<spanclass="math inline">\(n-m+k=2\)</span>这里的n、m、k分别是图G的结点数、边数、面数（包括无限面）</li><li>有两条或者更多条边的任何连通的平面图G中,有<spanclass="math inline">\(m \leq 3n-6\)</span></li><li><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051141374.png"alt="image-20240505114109639" /><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051243937.png"alt="image-20240505124328184" /></li></ul><h2 id="有向图">有向图</h2><h3 id="概念-10">概念</h3><ul><li><p>弱连通：看作无向图时是连通的</p><p>单向连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>中至少有一个由另一个出发是可达的</p><p>强连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>都是相互可达的</p><p><strong>强连通的有向图是单向连通的，单向连通的有向图是弱连通的</strong></p></li><li><p>强分图、单向分图、弱分图分别是G的极大连通子图、极大单向连通子图、极大弱连通子图</p></li></ul><h3 id="性质定理-9">性质定理</h3><ul><li><p>一个连通的有向图具有欧拉回路的充要条件是，G的每一个结点的入度和出度相等</p><p>一个连通的有向图具有欧拉路的充要条件是，除了两个结点外，G的每一个结点的入度和出度相等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>级数</title>
      <link href="/2024/05/27/%E7%BA%A7%E6%95%B0/"/>
      <url>/2024/05/27/%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数项级数">数项级数</h1><h2 id="概念">概念</h2><p><strong>数项级数：</strong> 给定一列实数<spanclass="math inline">\(a_1,a_2,...,a_n\)</span>，称<spanclass="math inline">\(a_1+a_2+...+a_n+...\)</span>为一个数项级数，简称级数</p><p><strong>部分和：</strong>称<spanclass="math inline">\(S_n=\sum\limits_{k=1}^{k=n}a_k\)</span>为级数的部分和</p><p><strong>级数的和：</strong> <spanclass="math inline">\(S=\lim\limits_{n \to\infty}S_n\)</span>，s是级数的和，<spanclass="math inline">\(S=\sum\limits_{n=1}^{\infty}a_n\)</span></p><p><strong>余项：</strong> <spanclass="math inline">\(R_n=S-S_n=\sum\limits_{k=n+1}^{\infty}a_k\)</span></p><h3 id="敛散性的定义">敛散性的定义</h3><p><spanclass="math inline">\(\color{red}{改变级数的有限项，不影响其敛散性}\)</span></p><ol type="1"><li>当S有限的时候，级数收敛</li><li>若级数收敛，则<span class="math inline">\(\lim\limits_{n \to\infty}a_n=0\)</span><ul><li>只要级数收敛，则通项趋于零；通项不趋于零时，级数必发散 <spanclass="math inline">\((eg:\sum a_n收敛\Rightarrow\sum\limits_{n=1}^{\infty}\frac{1}{1+|a_n|}发散)\)</span></li><li>通项趋于零的级数不一定都收敛 <span class="math inline">\((eg:\,\sum\limits_{n=1}^\infty  \frac{1}{n_p})\)</span></li><li>发散的级数通项不一定不趋于零<spanclass="math inline">\((eg:\sum\limits_{n=1}^{\infty}\frac{1}{n})\)</span>​</li></ul></li><li><span class="math inline">\(\sum a_n,\sum b_n\)</span>收敛<spanclass="math inline">\(\Rightarrow\)</span><spanclass="math inline">\(\sum (a_n +b_n)\)</span>收敛</li><li><span class="math inline">\(\sum a_n\)</span>收敛，<spanclass="math inline">\(\sum b_n\)</span>发散<spanclass="math inline">\(\Rightarrow\)</span><spanclass="math inline">\(\sum(a_n+b_n)\)</span>发散</li></ol><h3 id="常见级数">常见级数</h3><ul><li>几何级数：<span class="math inline">\(\sum\limits_{n=0}^{\infty}r^n= 1+r+r^2+...\)</span><ol type="1"><li><span class="math inline">\(\left|r \right| &lt;1\)</span>，收敛，且和为<spanclass="math inline">\(\frac{1}{1-r}\)</span></li><li><span class="math inline">\(|r|\geq1\)</span>，发散</li></ol></li><li>p-级数：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}\frac{1}{n^p}=1+\frac{1}{2^p}+\frac{1}{3^p}+...\)</span>​<ol type="1"><li><span class="math inline">\(p&gt;1\)</span>，收敛</li><li><span class="math inline">\(p\leq1\)</span>，发散</li></ol></li><li>调和级数：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}\frac{1}{n}=1+\frac{1}{2}+\frac{1}{3}+...\)</span>​<ol type="1"><li>发散</li></ol></li></ul><h2 id="正项级数">正项级数</h2><p>形式：<span class="math inline">\(a_n \geq 0\)</span>​</p><h3 id="判别法">判别法</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405272227749.jpg" /></p><ol type="1"><li><p><spanclass="math inline">\(A_n=\sum\limits_{k=1}^{n}a_k\)</span>随n单调增加，因此<spanclass="math inline">\(\sum a_n收敛\Leftrightarrow\left\{A_n\right\}极限存在\Leftrightarrow\left\{A_n\right\}有界\)</span>​</p></li><li><p>一般形式的<strong>比较判别法</strong></p><p>若从某项起有<span class="math inline">\(a_n\leq b_n\)</span></p><ul><li><p>当<span class="math inline">\(\sum b_n\)</span>收敛时，<spanclass="math inline">\(\sum a_n\)</span>收敛</p></li><li><p>当<span class="math inline">\(\sum a_n\)</span>发散时，<spanclass="math inline">\(\sum b_n\)</span>发散</p></li></ul></li><li><p>极限形式的<strong>比较判别法</strong></p><p>若<span class="math inline">\(b_n\neq 0,\lim\limits_{n\to\infty}a_n/b_n=l\)</span></p><ul><li><p><span class="math inline">\(0&lt;l&lt;+\infty\)</span>时，<spanclass="math inline">\(\sum a_n与\sum b_n\)</span>敛散性相同</p></li><li><p><span class="math inline">\(l=0\)</span>时，<spanclass="math inline">\(\sum b_n收敛，\sum a_n收敛\)</span></p></li><li><p><span class="math inline">\(l=+\infty\)</span>时，<spanclass="math inline">\(\sum b_n发散，\sum a_n发散\)</span>​</p></li></ul></li><li><p><strong>比值判别法</strong> --适用于连乘</p><p>若<spanclass="math inline">\(\lim\limits_{n\to\infty}\frac{a_{n+1}}{a_n}=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(l&lt;1\)</span>时，收敛</li><li><span class="math inline">\(l&gt;1\)</span>时，发散</li></ul></li><li><p><strong>根值判别法</strong> --适用于n次幂</p><p>若<spanclass="math inline">\(\lim\limits_{n\to\infty}\sqrt[n]{a_n}=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(l&lt;1\)</span>时，收敛</li><li><span class="math inline">\(l&gt;1\)</span>​时，发散</li></ul></li><li><p><strong>积分判别法</strong></p><p>设<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\([1,+\infty)\)</span>上非负且单调减，<spanclass="math inline">\(a_n=f(n)\)</span> <spanclass="math inline">\((n=1,2,3,...)\)</span>，则<spanclass="math inline">\(\sum a_n\)</span>与<spanclass="math inline">\(\int_1^{+\infty}f(x)dx\)</span>敛散性相同</p></li><li><p><strong>比阶判别法</strong></p><p>设<span class="math inline">\(\sum a_n\)</span>是一正项级数，<spanclass="math inline">\(\lim n^pa_n=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(p&gt;1且0\leql&lt;+\infty\)</span>时，收敛</li><li><span class="math inline">\(p\leq 1且0&lt;l\leq+\infty\)</span>时，发散</li></ul></li></ol><h2 id="变号级数">变号级数</h2><p>形式：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}(-1)^{n-1}a_n，其中a_n&gt;0\)</span></p><h3 id="判别法-1">判别法</h3><p>Leibniz判别法：若<spanclass="math inline">\(\left\{a_n\right\}\)</span><strong>单调减</strong>且收敛于零，则级数收敛，在完全单调减的条件下，其和<spanclass="math inline">\(S\leq a_1\)</span>，余项<spanclass="math inline">\(R_n\)</span>满足<spanclass="math inline">\(|R_n|\leq a_{n+1}\)</span></p><h3 id="绝对收敛与相对收敛">绝对收敛与相对收敛</h3><p>绝对收敛：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}|a_n|收敛\)</span></p><p>条件收敛：<spanclass="math inline">\(\sum_\limits{n=1}^{\infty}a_n\)</span>收敛，但<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}|a_n|\)</span>发散</p><h1 id="函数项级数">函数项级数</h1><h2 id="概念-1">概念</h2><p><strong>函数项级数</strong>：定义域<em>I</em>上的一列函数<spanclass="math inline">\(u_n(x)\)</span>，称<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}u_n(x)=u_1(x)+u_2(x)+...+u_n(x)+...\)</span>为<em>I</em>上的一个函数项级数</p><p><strong>收敛点</strong>：<span class="math inline">\(x_0\inI\)</span>，数项级数<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}u_n(x_0)\)</span>收敛，则称<spanclass="math inline">\(x_0\)</span>为级数的收敛点</p><p><strong>收敛域</strong>：全体收敛点构成的集合B为级数的收敛域</p><p><strong>和函数</strong>：对每一个<span class="math inline">\(x\inB\)</span>，以<spanclass="math inline">\(S(x)\)</span>记级数的和，是定义于收敛域B上的函数</p><p><strong>部分和</strong>：<spanclass="math inline">\(S_n(x)=\sum\limits_{k=1}^{n}u_k(x)\)</span>是级数的部分和，定义于<em>I</em>上的函数</p><p><strong>余项</strong>：<spanclass="math inline">\(R_n(x)=S(x)-S_n(x)=\sum\limits_{k=n+1}^{\infty}u_k(x)\)</span>，仅在集合B上有定义</p><h2 id="一致收敛">一致收敛</h2><p>设级数在点集A上收敛，若<span class="math inline">\(\forall\varepsilon&gt;0,\exist N&gt;0,\forall n\geq N,\forall x\inA:|R_n(x)|&lt;\varepsilon\)</span>，则说级数在A上一致连续</p><h2 id="weierstrass判别法">Weierstrass判别法</h2><p>若存在一个收敛的正项级数<span class="math inline">\(\sumb_n\)</span>，使得<span class="math inline">\(|u_n(x)|\leqb_n\)</span>，则级数在A上绝对收敛且一致收敛</p><h2 id="和函数的分析性质">和函数的分析性质</h2><p>在一致收敛条件下，有：</p><ol type="1"><li>“逐项求导”：<spanclass="math inline">\((\sum\limits_{n=1}^{\infty}u_n(x))&#39;=\sum\limits_{n=1}^{\infty}u_n&#39;(x)\)</span></li><li>“逐项积分”：<spanclass="math inline">\(\int_{\alpha}^{\beta}\sum\limits_{n=1}^{\infty}u_n(x)dx=\sum\limits_{n=1}^{\infty}\int_{\alpha}^{\beta}u_n(x)dx\)</span></li></ol><h1 id="幂函数">幂函数</h1><h2 id="概念-2">概念</h2><p><strong>幂级数</strong>：</p><ol type="1"><li><p><spanclass="math inline">\(\sum\limits_{n=0}^{\infty}a_nx^n=a_0+a_1x+...+a_nx^n+...\)</span></p></li><li><p><spanclass="math inline">\(\sum\limits_{n=0}^{\infty}a_n(x-x_0)^n=a_0+a_1(x-x_0)+...+a_n(x-x_0)^n+...\)</span></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无穷级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静电场</title>
      <link href="/2024/05/24/%E9%9D%99%E7%94%B5%E5%9C%BA/"/>
      <url>/2024/05/24/%E9%9D%99%E7%94%B5%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电荷和库仑定律">电荷和库仑定律</h1><p>电子e：<span class="math inline">\(1.602 \times10^{-19}C\)</span></p><p>库仑定律：</p><blockquote><p>库仑定律对运动的电荷不成立，因为会产生磁场；但是高斯定理对运动的电荷成立</p></blockquote><p><span class="math inline">\(F=k\frac{q_1q_2}{r^2}\vec{e_r}\)</span>，其中<spanclass="math inline">\(k=\frac{1}{4\pi \varepsilon_0}=9\times 10^9,\varepsilon_0=8.8542=10^{-12}C^2/(N\cdot m^{-2})\)</span>​</p><h1 id="静电场与电场强度">静电场与电场强度</h1><h2 id="概念">概念</h2><p>电场强度：<spanclass="math inline">\(E=\frac{F}{q_0}\)</span>，单位：<spanclass="math inline">\(N/C或V/m\)</span>​</p><p>点电荷：<span class="math inline">\(E=\frac{q}{4\pi\varepsilon_0r^2}\vec{e_r}\)</span></p><p>线电荷密度：<span class="math inline">\(\lambda\)</span>面电荷密度：<span class="math inline">\(\sigma\)</span>体电荷密度：<span class="math inline">\(\rho\)</span></p><p><span class="math inline">\(\color{red}{(\lambda = \sigmady)}\)</span></p><h2 id="各特殊模型产生的场强">各特殊模型产生的场强</h2><ol type="1"><li><p>电偶极子</p><p>电偶极子：两相隔一定距离的等量异号点电荷</p><p><spanclass="math inline">\(\vec{l}\)</span>：负电荷到正电荷的矢量线段</p><p>电偶极矩：<span class="math inline">\(\vec{p}=q\vec{l}\)</span></p><p><span class="math inline">\(E=-\frac{ql}{4\pi \varepsilon_0 (r^2 +l^2/4)^{\frac{3}{2}}}\)</span>，若<span class="math inline">\(r\ggl\)</span>，<strong><spanclass="math inline">\(\color{forestgreen}{E=-\frac{ql}{4\pi\varepsilon_0r^3}}\)</span></strong></p></li><li><p>均匀带电直线</p><blockquote><p>利用<span class="math inline">\(dq=\lambda dy\)</span>进行积分</p></blockquote><p>无限长：<spanclass="math inline">\(\color{forestgreen}E=\frac{\lambda}{2\pi\varepsilon_0x}\)</span></p></li><li><p>均匀带电平面</p><p>无限大：<spanclass="math inline">\(\color{forestgreen}E=\frac{\sigma}{2\varepsilon_0}\)</span></p></li><li><p>均匀带电圆环</p><blockquote><p>利用<span class="math inline">\(dq=\lambda dy\)</span>进行积分</p></blockquote><p>沿轴线：<spanclass="math inline">\(E=\frac{xQ}{4\pi\varepsilon_0(x^2+R^2)^{\frac{3}{2}}}\)</span>，若<span class="math inline">\(x\gg R\)</span>：<spanclass="math inline">\(\color{forestgreen}E=\frac{Q}{4\pi\varepsilon_0x^2}\)</span></p></li><li><p>均匀带电圆盘</p><blockquote><p>圆盘是由圆环组成，对dr进行积分</p></blockquote><p>沿轴线：<spanclass="math inline">\(\color{forestgreen}E=\frac{\sigma}{2\varepsilon_0}(1-\frac{x}{\sqrt{R^2+x^2}})\)</span></p><ul><li>当<span class="math inline">\(x\llR\)</span>，圆盘可视为无限大的平面，<spanclass="math inline">\(E=\frac{\sigma}{2\varepsilon_0}\)</span></li><li>当<span class="math inline">\(x\ggR\)</span>，圆盘可视为点电荷，<spanclass="math inline">\(E=\frac{q}{4\pi \varepsilon_0x^2}\)</span>（q为圆盘的总带电量<span class="math inline">\(q=\sigma \piR^2\)</span></li></ul></li><li><p>均匀带电球面</p><blockquote><p><span class="math inline">\(dq=\sigma 2\pi r&#39;dl,r&#39;=R\sin\theta\)</span>，对圆盘上的圆环进行积分</p></blockquote><p>当<span class="math inline">\(x&gt;R\)</span>时，<spanclass="math inline">\(\color{forestgreen}E=\frac{Q}{4\pi\varepsilon_0x^2}\)</span></p><p>当<span class="math inline">\(x&lt;R\)</span>时，<spanclass="math inline">\(E=0\)</span></p></li></ol><h1 id="高斯定理">高斯定理</h1><p><span class="math inline">\(\Phi_e=\oint_S\vec{E}\cdotd\vec{S}=\frac{1}{\varepsilon_0}\sum\limits_{S_{\text{内}}}q_i\)</span>​</p><p>----揭示了静电场是有源场</p><p>注意：</p><ol type="1"><li><spanclass="math inline">\(\Phi_E只取决于S面包围的电荷，S面外的电荷对\Phi_E无贡献\)</span></li><li><spanclass="math inline">\(\vec{E}\)</span>是所取封闭面S（高斯面）上的场强，它是由全部电荷<spanclass="math inline">\(\color{red}{S内外}\)</span>​共同产生的合场强</li></ol><h2 id="高斯面的选取">高斯面的选取</h2><p>高斯面（封闭面）应该选在场强相等的封闭曲面上，如果场强相等的曲面不封闭，则应该添加与场强方向垂直的面共同形成封闭曲面</p><ol type="1"><li>球对称：选与带电体同心的球面</li><li>轴对称：选与带电体同轴的圆柱面</li><li>面对称：选轴与带电面垂直，两底与带电面等距平行的圆柱面</li></ol><blockquote><p>对于一个球体中挖去一个小球体，求空腔内一点的电场强度：先将球体补齐，算大球体和补进去的小球体产生的场强，一减即可</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406122012174.png" /></p><p><spanclass="math inline">\(\color{red}{不能直接取高斯面，因为E和r不是平i平行的的}\)</span></p><h1 id="环路定理">环路定理</h1><p>----- 揭示了静电场的无旋性</p><p><span class="math inline">\(\oint_L\vec{E}\cdotd\vec{l}=0\)</span></p><p>静电场做功：<spanclass="math inline">\(\frac{A}{q_0}=\frac{q}{4\pi\varepsilon(\frac{1}{r_a}-\frac{1}{r_b})}(r_a,r_b表示场源电荷到被移动电荷的起点和终点距离)\)</span></p><h1 id="电势差和电势">电势差和电势</h1><h2 id="概念-1">概念</h2><p>点电荷<spanclass="math inline">\(q_0\)</span>从P到Q，电场力做功为：<spanclass="math inline">\(A_{PQ}=q_0\int_{P}^Q\vec{E}\cdotd\vec{l}\)</span></p><p><span class="math inline">\(W_P,W_Q\)</span>分别是<spanclass="math inline">\(q_0\)</span>在P点和Q点的静电势能，<spanclass="math inline">\(W_P-W_Q=q_0\int_P^Q\vec{E}\cdotd\vec{l}\)</span></p><p>P、Q两点的电势差为<span class="math inline">\(V_P-V_Q=\int_{P}^Q\vec{E}\cdot d \vec{l}\)</span></p><h2 id="电势零点的选取">电势零点的选取</h2><ol type="1"><li>场源电荷分布在有限空间，选取无穷远处为电势零点</li><li>电荷分布在无限空间，选有限远点为电势零点</li></ol><h2 id="电势的计算">电势的计算</h2><ol type="1"><li><p>定义法求电势</p><p><span class="math inline">\(V_P=\int_{P}^{V=0处}\vec{E}\cdotd\vec{l}\)</span></p></li><li><p>电势叠加法求电势</p><p>点电荷系场中的电势：<spanclass="math inline">\(V_P=\sum\limits_{i}\frac{q_i}{4\pi\varepsilon_0r_i}\)</span></p><p>任意带电体场中的电势：<spanclass="math inline">\(V_P=\int_q\frac{dq}{4\pi\varepsilon_0r}\)</span></p></li></ol><h2 id="电势梯度">电势梯度</h2><p>电视梯度是电势的最大空间变化率</p><p><spanclass="math inline">\(\vec{E}=-grad\,V=-(\frac{\partial}{\partialx}\vec{i}+\frac{\partial}{\partial y}\vec{j} +\frac{\partial}{\partialz}\vec{k})V\)</span></p><h1 id="静电场中的导体">静电场中的导体</h1><blockquote><p>静电感应<span class="math inline">\(\rightarrow\)</span>静电平衡<spanclass="math inline">\(\rightarrow\)</span>等势体</p></blockquote><h2 id="静电平衡的条件">静电平衡的条件</h2><p>静电平衡：导体表面和内部都没有电荷的定向移动</p><ol type="1"><li>导体内部 <span class="math inline">\(\vec{E}=0\)</span></li><li>外表面 <span class="math inline">\(\vec{E}\bot表面\)</span></li></ol><p>推论：导体是等势体，导体表面是等势面</p><p><strong>静电平衡时导体上的电荷分布：</strong></p><ol type="1"><li><p>导体内部没有静电荷，电荷分布在外表面上</p></li><li><p>导体内有空腔，腔内无其他带电体，电荷全分布在导体外表面</p></li><li><p>导体表面附近<spanclass="math inline">\(\vec{E}\)</span>的大小与该处的面电荷密度<spanclass="math inline">\(\sigma\)</span>成正比：<spanclass="math inline">\(\vec{E} =\frac{\sigma}{\varepsilon_0}\)</span></p></li></ol><p><spanclass="math inline">\(\color{red}{\vec{E}}是导体表面电荷和外部电荷的合场强\)</span>​</p><ol start="4" type="1"><li>孤立导体表面各处的面电荷密度<spanclass="math inline">\(\sigma\)</span>与各处曲率半径R成反比，即<spanclass="math inline">\(\sigma \propto \frac{1}{R}\)</span></li></ol><p><strong>求解静电平衡时的电荷分布：</strong></p><ol type="1"><li>取两板之间的高斯柱面，得两板电荷之和为0</li><li>导体内任一点电场为0</li></ol><h2 id="静电屏蔽">静电屏蔽</h2><ol type="1"><li><p>腔内无带电体</p><ul><li>内表面无电荷</li><li>腔内<span class="math inline">\(\vec{E} = 0\)</span></li></ul></li><li><p>腔内有带电体</p><ul><li>内表面电荷和腔内电荷等值异号</li><li>外表面电荷与腔内电荷等值同号</li></ul><p><spanclass="math inline">\(\color{red}{外表面电荷分布和曲率有关和腔内电荷位置无关}\)</span></p></li></ol><h1 id="静电场中的电介质">静电场中的电介质</h1><blockquote><p>电介质是绝缘体，不导电，在外电场<spanclass="math inline">\(\vec{E}\neq 0\)</span></p></blockquote><h2 id="电介质分子的分类">电介质分子的分类</h2><ol type="1"><li>无极分子：在无外场作用下，整个分子无电矩</li><li>有极分子：在无外场作用下，整个分子存在固有电矩</li></ol><h2 id="电极化现象">电极化现象</h2><p>宏观：电介质表面出现电荷</p><p>端面上束缚电荷越多，电极化程度越强</p><ol type="1"><li><p>有极分子</p><p>取向极化：<spanclass="math inline">\(\vec{E}=0,\sum\vec{p}=0;\vec{E}\neq0,\vec{M}=\vec{p}\times\vec{E}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011444076.png" /></p><p><span class="math inline">\(\vec{E}\uparrow\)</span>，<spanclass="math inline">\(\vec{p}\)</span>排列越整齐</p></li><li><p>无极分子</p><p>位移极化：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011444423.png" /></p></li></ol><h2 id="电极化强度矢量vecp">电极化强度矢量<spanclass="math inline">\(\vec{P}\)</span></h2><ol type="1"><li><p><span class="math inline">\(\vec{P} = \frac{\sum p_i}{\DeltaV}\)</span>，单位体积内所有分子的电偶极矩之矢量和，单位<spanclass="math inline">\(C/m^2\)</span></p></li><li><p>无极分子介质极化的过程中，穿过ds的束缚电荷为<spanclass="math inline">\(dq=\vec{p}\cdot \vec{e_n}ds\)</span>，<spanclass="math inline">\(\frac{dq}{ds}=\vec{p}\cdot \vec{e_n}\)</span><spanclass="math inline">\(\Rightarrow\)</span>由于电介质极化，在其表面上单位面积所出现的一层束缚电荷，即束缚电荷的面密度<spanclass="math inline">\(\sigma\)</span>和该处电极化强度P在表面法线上的分量值相同<spanclass="math inline">\(\sigma =\vec{p}\cdot \vec{e_n}\)</span></p></li><li><p><span class="math inline">\(\vec{P}\)</span>与<spanclass="math inline">\(\vec{E}\)</span>成正比，对于各向同性的电介质：<spanclass="math inline">\(\vec{P} =\varepsilon_0(\varepsilon_r-1)\vec{E}\)</span></p><p><span class="math inline">\(\chi_e=\varepsilon_r-1\)</span>，<spanclass="math inline">\(\chi_e\)</span>--电极化率，<spanclass="math inline">\(\varepsilon_r\)</span>--相对介电常数</p><p>即：<span class="math inline">\(\vec{P}=\chi_e\varepsilon_r\vec{E}\)</span>，<spanclass="math inline">\(\overrightarrow{E} =\overrightarrow{E_{\text{外}}}+\overrightarrow{E&#39;}\)</span></p></li><li><p>电击穿--电介质的击穿</p><p>当<spanclass="math inline">\(\vec{E}\)</span>足够强的时候，分子中正负电荷被拉开<spanclass="math inline">\(\rightarrow\)</span>自由电荷</p><p>绝缘体<span class="math inline">\(\rightarrow\)</span>导体 <spanclass="math inline">\(\Longrightarrow\)</span> 电介质的击穿</p><p>电介质所能承受的不被击穿的最大的电场强度<spanclass="math inline">\(\rightarrow\)</span>击穿场强</p></li></ol><h2 id="有电介质存在时的静电场的计算">有电介质存在时的静电场的计算​</h2><p>在有介质存在空间的电场由自由电荷和介质上的束缚电荷共同产生</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011507578.png" /></p><p>放入介质两极板间的电位差为<spanclass="math inline">\(\rightarrow\)</span>V</p><p>未放入介质两极板间的电位差为<span class="math inline">\(\rightarrowV_0\)</span></p><p><span class="math inline">\(\Longrightarrow\)</span> <spanclass="math inline">\(\color{red}{V=\frac{V_0}{\varepsilon_r}}\)</span>​</p><h3 id="介质中的高斯定理">介质中的高斯定理</h3><p>通过高斯面的电位移通量等于高斯面所包围的<spanclass="math inline">\(\color{red}{自由电荷}\)</span>的代数和，与极化电荷和高斯面外的电荷无关</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011528093.png" /></p><p>电介质内的合场强为<spanclass="math inline">\(\vec{E}=\vec{E&#39;}+\vec{E_0}\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849786.png" /></p><p>电位移矢量：<span class="math inline">\(\vec{D}\)</span></p><p><spanclass="math inline">\(\vec{D}\)</span>线：电场线始于正电荷，止于负电荷；<spanclass="math inline">\(\vec{D}\)</span>线始于正自由电荷，止于正自由电荷</p><p><span class="math inline">\(\vec{D}\)</span>的通量：（均匀）<spanclass="math inline">\(\Phi_D=\vec{D}\cdot \Delta\vec{S}\)</span>，（非均匀）<span class="math inline">\(\Phi_D =\iint_S\vec{D}\cdot d\vec{S}\)</span></p><p><span class="math inline">\(\color{red}{注：}\)</span> 1. <spanclass="math inline">\(\vec{D}\)</span>由空间所有电荷（自由、束缚、S面内、S面外）共同决定</p><p>​ 2. <span class="math inline">\(\iint_S\vec{D}\cdotd\vec{S}\)</span>由面内自由电荷决定</p><p>​ 3.<span class="math inline">\(\vec{D} =\varepsilon\vec{E}\)</span>，<spanclass="math inline">\(\vec{D}\)</span>与<spanclass="math inline">\(\vec{E}\)</span>处处对应方向一致</p><p>​ 4.<span class="math inline">\(\oint\vec{D}d\vec{S}=\sumq_{\text{自}}\)</span>与 <span class="math inline">\(\oint\vec{E}d\vec{S}=\frac{\sum q_{\text{自}}+\sumq_{\text{束}}}{\varepsilon_0}\)</span></p><h3 id="环路定理-1">环路定理</h3><p><span class="math inline">\(\oint\vec{E}d\vec{l} =0\)</span>，束缚电荷产生的场强与自由电荷产生的场强相同</p><h3 id="归纳">归纳</h3><ol type="1"><li><p><spanclass="math inline">\(\vec{P}=\chi_E\varepsilon_0\vec{E}\)</span></p></li><li><p><span class="math inline">\(\vec{D}=\varepsilon_0\varepsilon_r\vec{E}\)</span></p></li><li><p><span class="math inline">\(\vec{D} = \varepsilon_0\vec{E}+\vec{P}\)</span></p></li><li><p>空间某点处的<spanclass="math inline">\(\vec{E}\)</span>仅与该点的电介质有关，而该处的<spanclass="math inline">\(\vec{V}\)</span>与积分路径上所有电介质有关</p></li></ol><h1 id="电容">电容</h1><h2 id="孤立导体的电容">孤立导体的电容</h2><p>若一孤立导体带电<span class="math inline">\(+q\)</span>，该导体具有一定的电势<span class="math inline">\(V\)</span>，电容<spanclass="math inline">\(C=\frac{q}{V}\)</span></p><p>电容的物理意义：孤立导体每升高一个单位的电势所需要的电量</p><h2 id="电容器及其电容">电容器及其电容</h2><p><span class="math inline">\(C_{AB} = \frac{q}{V_a-V_B}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849544.png" /></p><p>增大电容：多个电容并联<span class="math inline">\(C = C_1+C_2+...+C_k\)</span></p><p>增强耐压：多个电容串联<spanclass="math inline">\(\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}+...+\frac{1}{C_k}\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849265.png" /></p><p><strong>平行板</strong>电容器C：<spanclass="math inline">\(C=\frac{\varepsilon S}{d}\)</span></p><p><strong>平行板电容器</strong>中有介质时的C：<spanclass="math inline">\(C = \frac{\varepsilon_0S}{b-\frac{\varepsilon_r-1}{\varepsilon_r}t}\)</span></p><p><strong>圆柱形电容器</strong>：<spanclass="math inline">\(C=\frac{2\pi \varepsilonL}{ln(R_B/R_A)}\)</span>​</p><blockquote><p>设内外极板所带电荷线密度为<spanclass="math inline">\(+\lambda\)</span>和<spanclass="math inline">\(-\lambda\)</span>，取同轴的高斯柱面<spanclass="math inline">\(\vec{E} = \frac{\lambda}{2\pi\varepsilonr}\vec{e_r}\)</span></p></blockquote><p><strong>球形电容器</strong>：<span class="math inline">\(C=\frac{4\pi\varepsilon R_AR_B}{R_B-R_A}\)</span>​</p><blockquote><p>设内外球壳分别带<span class="math inline">\(+q,-q\)</span></p></blockquote><h3 id="求解电容的方法">求解电容的方法</h3><ol type="1"><li>假设极板的上下面电荷密度，利用电势差的关系<spanclass="math inline">\(\rightarrow\)</span>场强<spanclass="math inline">\(\rightarrow\)</span>面电荷密度</li><li>假设极板的上下面电荷密度，利用<spanclass="math inline">\(D=\sigma\)</span> <spanclass="math inline">\(\rightarrow\)</span> E <spanclass="math inline">\(\rightarrow\)</span> <spanclass="math inline">\(\Delta V\)</span> <spanclass="math inline">\(\rightarrow\)</span>​ C</li><li>根据串并联的规则</li></ol><h1 id="静电场的能量">静电场的能量</h1><h2 id="电容器的能量">电容器的能量</h2><p><span class="math inline">\(W=\frac{1}{2}\frac{Q^2}{C}=\frac{1}{2}CV^2=\frac{1}{2}QV\)</span></p><h2 id="电场的能量">电场的能量</h2><p>电场能量密度：<span class="math inline">\(w_e=\frac{1}{2}\varepsilonE^2=\frac{1}{2}\vec{D}\cdot\vec{E}\)</span></p><p>电场能量：<span class="math inline">\(W=\frac{1}{2}\int\varepsilonE^2dV=\frac{1}{2}\int \vec{D}\cdot\vec{E}dV\)</span></p><h2 id="电荷在外电场中的电势能">电荷在外电场中的电势能</h2><p><span class="math inline">\(1eV=1.6\times 10^{-19}J\)</span></p><p><strong>电势能</strong>：<spanclass="math inline">\(W=qV\)</span></p><p><strong>静电互能</strong>：一个点电荷在外电场中的电势能，属于该电荷和场源电荷所共有</p><h2 id="带电体系的静电能">带电体系的静电能</h2><p><strong>静电能</strong>：系统中所有电荷之间相互作用能的总和成为该电荷系统的静电能</p><ul><li>将系统中各电荷从现有位置到彼此分散到无限远的过程中，他们之间的静电力所做的功</li><li>将各电荷从彼此分散在无限远处移动到现有位置过程，外力做的功</li></ul><p><spanclass="math inline">\(W_{\text{总静电能}}=W_{\text{互}}+W_{\text{自}}\)</span></p><p><strong>自能</strong>：单一带电体自身电荷元相互作用的静电能</p><p><strong>互能</strong>：不同带电体上电荷的相互作用的静电能</p><h3 id="点电荷的互能">点电荷的互能</h3><p>两个点电荷组成的系统：因为<spanclass="math inline">\(A_{12}=A_{21}\)</span> ,所以<spanclass="math inline">\(W=\frac{1}{2}(q_1V_1+q_2V_2)\)</span></p><p>n个点电荷组成的系统：第i个电荷的电荷量为<spanclass="math inline">\(q_i\)</span>，其他电荷在<spanclass="math inline">\(q_i\)</span>处产生的电势为<spanclass="math inline">\(V_i\)</span>，则点电荷系的静电能为<spanclass="math inline">\(W=\frac{1}{2}\sum\limits_{i-1}^{n}q_iV_i\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 静电场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静电场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲线积分与曲面积分</title>
      <link href="/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/"/>
      <url>/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一型曲线积分">第一型曲线积分</h1><h2 id="形式">形式</h2><p><span class="math inline">\(\int_{L}f ds\)</span>​ --表示曲线L的质量，f是密度函数</p><h2 id="方法">方法</h2><ol type="1"><li><strong>化为定积分</strong></li></ol><p><span class="math inline">\(\int_{L}f ds =\int_{\alpha}^{\beta}f(x(t),y(t),z(t))\sqrt{x(t)&#39;^{2} +y(t)&#39;^{2} +z(t)&#39;^{2}}dt\)</span>​</p><ul><li>极坐标：<span class="math inline">\(ds=\sqrt{r(\theta)^2 +r(\theta)&#39;^2}d\theta\)</span></li><li>xy平面曲线：<span class="math inline">\(ds =\sqrt{1+y(t)&#39;^2}dx\)</span>​</li></ul><ol start="2" type="1"><li><strong>对称性</strong></li></ol><ul><li>平面曲线L关于<spanclass="math inline">\(y=x\)</span>对称，且被积函数在L上连续：可以交换x，y</li><li>空间曲线L关于<spanclass="math inline">\(y=x=z\)</span>对称，且被积函数在L上连续：x,y,z具有轮换对称性</li></ul><ol start="3" type="1"><li><p><strong>质心</strong></p><p>当被积函数是只有一次参变量时，可以利用已知质心进行计算</p></li></ol><h1 id="第二型曲线积分">第二型曲线积分</h1><h2 id="形式-1">形式</h2><p><span class="math inline">\(\int_{L}\vec{F} \cdot d\vec{r} = \int_L\vec{F} \cdot \vec{\tau}ds = \int_LPdx+Qdy+Rdz = \int_L Pcos\alpha +Qcos\beta + Rcos\gamma ds\)</span></p><p><spanclass="math inline">\(\vec{\tau}\)</span>为L的切矢量，其方向余弦为<spanclass="math inline">\({cos\alpha,cos\beta,cos\gamma}\)</span>，<spanclass="math inline">\(\vec{F} = \left\{P,Q,R\right\}\)</span>，<spanclass="math inline">\(d\vec{r} = \left\{dx,dy,dz\right\}\)</span> --变力沿​曲线做功</p><h2 id="方法-1">方法</h2><ol type="1"><li><p><strong>化为定积分</strong></p></li><li><p>Green公式</p><p><span class="math inline">\(\oint_L Pdx + Qdy = \iint_\limits{D}(Q_x- P_y)dxdy\)</span></p><ul><li>简单闭曲线</li><li>函数P，Q在D上包括边界有连续一阶偏导数</li></ul></li><li><p>积分与路径无关</p></li></ol><ul><li>可化成全微分</li><li><span class="math inline">\(Q_x = P_y\)</span></li><li>D内任何分段光滑闭曲线C，<span class="math inline">\(\oint_C Pdx+Qdy= 0\)</span></li></ul><ol start="4" type="1"><li>除<spanclass="math inline">\(M_0\)</span>点外，P，Q处处有一节连续偏导数，<spanclass="math inline">\(Q_x = P_y\)</span>，<spanclass="math inline">\(\color{red}{任何}\)</span>包围<spanclass="math inline">\(M_0\)</span>的<spanclass="math inline">\(\color{red}{正向}\)</span>简单闭曲线L，积分<spanclass="math inline">\(\oint_L Pdx+Qdy\)</span>取同一值</li></ol><h1 id="第一型曲面积分">第一型曲面积分</h1><h2 id="形式-2">形式</h2><p><span class="math inline">\(\iint_\limits{S}f(x,y,z)dS\)</span> --曲面质量</p><h2 id="方法-2">方法</h2><ol type="1"><li><p>化为二重积分</p><p>将曲面投影到某个坐标面，将<spanclass="math inline">\(\iint_\limits{S}\)</span>改成<spanclass="math inline">\(\iint_\limits{D}\)</span></p><p><span class="math inline">\(dS = \sqrt{1+z_x^2 +z_y^2}d\sigma\)</span></p></li></ol><h1 id="第二型曲面积分">第二型曲面积分</h1><h2 id="形式-3">形式</h2><p><span class="math inline">\(\iint_\limits{S} \vec{F}\cdot \vec{n}ds =\iint_\limits{S}Pcos\alpha + Qcos\beta + Rcos\gamma dS =\iint_\limits{S}Pdydz + Qdzdx + Rdxdy\)</span></p><p>-- 流量问题</p><h2 id="方法-3">方法</h2><ol type="1"><li>化为二重积分</li><li>分散投影</li><li>统一投影法</li></ol><p>​ <span class="math inline">\(\vec{n} = \left\{cos\alpha,cos\beta,cos\gamma\right\}=\pm \frac{1}{\sqrt{1+z_x^2 + z_y^2}}\left\{-z_x, -z_y, 1\right\}\)</span></p><p>​ <span class="math inline">\(dydz=\cos\alphadS=-z_x(x,y)dxdy\)</span></p><p>​ <span class="math inline">\(dzdx = \cos\beta dS =-z_y(x,y)dxdy\)</span></p><p>​ <span class="math inline">\(dxdy = \cos\gamma dS\)</span></p><ol start="4" type="1"><li>散度与旋度</li></ol><p>​ <span class="math inline">\(\nabla = \left\{\frac{\partial}{\partialx} ,\,\frac{\partial}{\partial y} ,\,\frac{\partial}{\partial z}\right\}\)</span></p><p>​ <span class="math inline">\(\nabla f(r) = \left\{\frac{\partialf(r)}{\partial x} ,\,\frac{\partial f(r)}{\partial y} ,\,\frac{\partialf(r)}{\partial z} \right\}\)</span> = <spanclass="math inline">\(f&#39;(r)\cdot \frac{1}{\sqrt{x^2 + y^2 + z^2}}\left\{x,y,z\right\}\)</span>=<spanclass="math inline">\(\frac{f&#39;(r)}{r} \vec{r}\)</span> （其中<spanclass="math inline">\(\vec{r} = \left\{x,y,z\right\}\)</span>）</p><p>​ 散度：<span class="math inline">\(div\, \vec{F} = P_x+Q_y+R_z=\nabla\cdot \vec {F}\)</span></p><p>​ 旋度：<span class="math inline">\(\overrightarrow{rot\,F}=\)</span><span class="math inline">\(\  \left|\begin{array}{cccc}     i&amp;    j    &amp; k \\     \frac{\partial}{\partial x}&amp;    \frac{\partial}{\partial y}   &amp; \frac{\partial}{\partialz}\\     P &amp; Q &amp; R  \end{array}\right|\)</span><spanclass="math inline">\(=\nabla \times \vec{F}\)</span></p><ol start="5" type="1"><li><p>Gauss公式</p><p>S应该是正向闭曲面</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405232047414.png" /></p></li><li><p>Stokes公式</p></li></ol><p>​ <span class="math inline">\(\oint_L \,\vec{F}\cdot d\vec{r} =\iint\limits_{s}(\nabla\times \vec{F})\cdot \vec{n}dS\)</span></p><p>​ <span class="math inline">\(\oint_L Pdx+Qdy+Rdz =\iint_\limits{S}\)</span> <spanclass="math inline">\(\  \left|\begin{array}{cccc}     dydz&amp;    dzdx    &amp; dxdy \\     \frac{\partial}{\partial x}&amp;    \frac{\partial}{\partial y}   &amp; \frac{\partial}{\partialz}\\     P &amp; Q &amp; R  \end{array}\right|\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分与曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绪论">绪论</h1><h2 id="概念">概念</h2><p><strong>数据</strong>：所有能输入到计算机中并被计算机程序加工、处理的符号的总称。如：整数、实数、字符、声音、图象、图形等。</p><p><strong>数据项</strong>：数据的不可分割的最小单位</p><p><strong>数据元素</strong>：数据的基本单位，一个数据元素可以由若干个数据项组成</p><p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集</p><p><strong>数据结构</strong>：相互之间存在一种或多种特定关系的数据元素的集合。</p><p><strong>结构</strong>：数据元素之间的关系称为结构。</p><p><strong>数据类型</strong>：是一个值的集合和定义在这个值上的一组操作的总称。</p><ol type="1"><li>原子类型(如：int,char,float等)</li><li>结构类型(如：数组,结构,联合体等）</li></ol><h2 id="抽象数据类型">抽象数据类型</h2><p><strong>抽象数据类型（ADT）</strong>：与计算机的实现无关的数据类型</p><p>形式定义：</p><p>ADT 抽象数据类型名 {</p><ol type="1"><li><p>数据对象</p></li><li><p>数据关系:一个或多个关系</p></li><li><p>基本操作：一组基本操作/运算</p></li></ol><p>} ADT 抽象数据类型名</p><p>其中数据对象和数据关系的定义用<strong>伪码</strong>描述，基本操作的定义格式为：</p><p>基本操作名（参数表）</p><p>​ 初始条件：<初始条件描述></p><p>​ 操作结果：<操作结果描述></p><p>参数表中有两种操作：</p><ol type="1"><li>赋值参数：只为操作提供输入值</li><li>引用参数：以&amp;打头，除可提供输入值外，还将返回操作结果</li></ol><h2 id="算法与算法分析">算法与算法分析</h2><p>算法的特征：</p><ol type="1"><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入：有0或多个输入量</li><li>输出：至少有一个输出量</li></ol><p>算法设计要求：</p><ol type="1"><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效与低存储量</li></ol><p>时间复杂度比较</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281632685.png" style="zoom: 50%;" /></p><h1 id="线性表">线性表</h1><h2 id="adt">ADT</h2><p>ADT List</p><p>{</p><p>数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n&gt;=0\right\}\)</span></p><p>数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span></p><p>基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitList</span>(&amp;L) <span class="comment">//构造空表L。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyList</span>(&amp;L) <span class="comment">//销毁线性表L</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearList</span>(&amp;L) <span class="comment">//置L为空表</span></span><br><span class="line"><span class="number">4.L</span>istEmpty(L) <span class="comment">//判断L是否为空表</span></span><br><span class="line"><span class="number">5.L</span>istLength(L) <span class="comment">//求表L的长度</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetElem</span>(L,i,&amp;e) <span class="comment">//取元素ai,由e返回ai</span></span><br><span class="line"><span class="number">7.L</span>ocateElem(L,e,<span class="built_in">compare</span>()) <span class="comment">//查找符合条件的元素</span></span><br><span class="line"><span class="number">8.L</span>istInsert(&amp;L,i,e) <span class="comment">//元素ai之前插入新元素e</span></span><br><span class="line"><span class="number">9.L</span>istDelete(&amp;L,i,&amp;e) <span class="comment">//删除第i个元素</span></span><br></pre></td></tr></table></figure><p>}ADT List</p><h2 id="顺序存储结构">顺序存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">    <span class="type">int</span> listsize;<span class="comment">//当前分配的存储容量</span></span><br><span class="line">&#125;Sqlist</span><br></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中的第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;<span class="comment">//i不合法</span></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt; L.listsize)<span class="comment">//当前存储空间已满，增加存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(L.elem,(L.listsize + ADD)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += ADD;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(l.elem[i - <span class="number">1</span>]);<span class="comment">//q是待插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; p--)</span><br><span class="line">    *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​ 设共有n个元素，在各个位置插入元素的概率相同，为<spanclass="math inline">\(p=\frac{1}{n +1}\)</span>，则插入一个元素时移动的平均值为<spanclass="math inline">\(\sum\limits_{i=1}^{n+1}p(n-i+1)=\frac{n}{2}\)</span></p><h3 id="删除操作">删除操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中删除第i个元素，并用e返回其值</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelte_Sq</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;<span class="comment">//如果i不合法</span></span><br><span class="line">    p = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = *p;</span><br><span class="line">    q = L.elem + L.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(++p; p &lt;= q; ++p)</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​ 设共有n个元素，在各个地方删除元素的概率为<spanclass="math inline">\(p=\frac{1}{n}\)</span>，则删除一个元素时移动元素的平均值为<spanclass="math inline">\(\sum\limits_{i=1}^{n}p(n-i) =\frac{n-1}{2}\)</span>​</p><h3 id="合并操作">合并操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线性表Lb中的且不再La中的元素合并到La中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(Sqlist&amp; La, Sqlist&amp; Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, i, e);<span class="comment">//从Lb中取第i个元素赋值给e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La, e, equal))</span><br><span class="line">        <span class="built_in">ListInsert</span>(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并并排序操作">合并并排序操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并非递减排序线性表La和Lb，得到Lc并且Lc按非递减排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(Sqlist La, Sqlist Lb, Sqlist&amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i = j = k = <span class="number">0</span>;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len &amp;&amp; j &lt;= Lb_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Getelem</span>(La, i, ai); <span class="built_in">Getelem</span>(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= La_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(La, i++, ai);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= Lb_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(Lb, j++, bj);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序结构存储的评价">顺序结构存储的评价</h3><ol type="1"><li>优点<ol type="1"><li>是一种随机存取结构，存取任何元素的时间是一个常数，速度快</li><li>结构简单，逻辑上相邻的元素，物理上也是相邻的</li><li>不使用指针，节省存储空间</li></ol></li><li>缺点<ol type="1"><li>插入和删除需要移动大量数据，消耗大量时间</li><li>需要一块连续的空间</li><li>插入元素时可能会“溢出”</li><li>自由区中的存储空间不能被其他数据占用（共享）</li></ol></li></ol><h2 id="链式存储结构">链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125;node, *Linklist;</span><br></pre></td></tr></table></figure><h3 id="建立单链表">建立单链表</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“先进先出”（尾插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, tail, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    tail = head;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“后进先出&quot;（头插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* create2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立递增有序链表">建立递增有序链表</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create3</span>(<span class="keyword">struct</span> node* head, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    q = <span class="literal">NULL</span>, p = head;<span class="comment">//扫描，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//空表</span></span><br><span class="line">            head = s;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//尾插</span></span><br><span class="line">            q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//头插</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        head = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//其他正常情况的插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create4</span><span class="params">(<span class="keyword">struct</span> node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">//可以直接插入，不讨论</span></span><br><span class="line">    q-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作-1">插入操作</h3><p>​ 伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在i之前插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在i之后插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-1">删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在带表头节点的链表中删除值为e的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete1</span><span class="params">(stuct node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* p, *q;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在单链表中删除指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete2</span><span class="params">(<span class="keyword">struct</span> node* head, <span class="type">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = head;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;<span class="comment">//q是待删除结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并操作-1">合并操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个带头节点的链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">Merge</span>(<span class="keyword">struct</span> node* La, <span class="keyword">struct</span> node* Lb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* pa, pb, pc;</span><br><span class="line">    pa = La-&gt;next, pb = Lb-&gt;next;</span><br><span class="line">    pc = La;</span><br><span class="line">    <span class="built_in">free</span>(Lb);<span class="comment">//释放Lb的头指针</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa) pc-&gt;next = pa;</span><br><span class="line">    <span class="keyword">else</span>  pc-&gt;next = pb; </span><br><span class="line">    <span class="keyword">return</span> La;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储结构评价">链式存储结构评价</h3><ol type="1"><li>优点：灵活地增加/插入，删除操作</li><li>缺点：使用显式顺序指针代替隐式的相邻存储的位置关系，增加了存储空间</li></ol><h2 id="循环链表">循环链表</h2><ol type="1"><li><p>一般形式</p><ol type="1"><li><p>带头结点的非空循环单链表，有：</p><p><code>head-&gt;next != head, head != NULL</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405291607660.png" /></p><ol type="1"><li><p>带表头结点的空循环单链表，有：</p><p><code>head-&gt;next == head, head != NULL</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048524.png" /></p></li><li><p>只有尾节点（带头）</p><ol type="1"><li><p>非空表，有：</p><p><code>tail-&gt;data ==an</code></p><p><code>tail-&gt;next指向表头结点</code></p><p><code>tail-&gt;next-&gt;next指向首节点</code></p><p><code>tail-&gt;next-&gt;next-&gt;data == a1</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048085.png" /></p><ol type="1"><li><p>空表，有：</p><p><code>tail-&gt;next == tail</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048479.png" /></p></li></ol><p>两循环链表首尾相连(时间复杂度<code>O(1)</code>)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048842.png" /></p><p>​ <code>p2 = tail2-&gt;next</code></p><p>​ <code>tail2-&gt;next = tail1-&gt;next</code></p><p>​ <code>tail1-&gt;next = p2-&gt;next</code></p><p>​ <code>free(p2)</code></p><h2 id="双向链表">双向链表</h2><ol type="1"><li><p>非空表</p><figure><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047040.png"alt="image-20240529163639637" /><figcaption aria-hidden="true">image-20240529163639637</figcaption></figure><p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p><p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p><p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == NULL</code></p></li><li><p>空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047672.png" /></p><p>​ <code>L-&gt;next == L-&gt;prior == NULL</code></p></li></ol><h2 id="双向循环链表">双向循环链表</h2><ol type="1"><li><p>非空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047950.png" /></p><p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p><p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p><p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == L</code></p></li><li><p>空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047389.png" /></p><p>​ <code>L-&gt;next == L-&gt;prior == L</code></p></li></ol><h2 id="各链表比较">各链表比较</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292049549.png" /></p><h1 id="栈">栈</h1><p>栈：限定在表尾做插入、删除的线性表 ---“后进先出”</p><h2 id="adt-1">ADT</h2><p>ADT Stack</p><p>{</p><p>​ 数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq0\right\}\)</span></p><p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<spanclass="math inline">\(a_n\)</span>端为栈顶端，<spanclass="math inline">\(a_1\)</span>端为栈底</p><p>​ 基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitStack</span>(&amp;S) <span class="comment">//构造一个空栈。 </span></span><br><span class="line"><span class="number">2.</span><span class="built_in">ClearStack</span>(&amp;S) <span class="comment">//置s为空栈。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">DestroyStack</span>(&amp;S) <span class="comment">//栈s被销毁</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">Push</span>(&amp;S,e) <span class="comment">//元素e进栈S。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">Pop</span>(&amp;S,&amp;e) <span class="comment">//删除栈S的顶元素，并送入e 。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetTop</span>(S,&amp;e) <span class="comment">//将非空栈S的栈顶元素拷贝到e（与（4）的Pop操作是不同的）。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">StackEmpty</span>(&amp;S) <span class="comment">//判断s是否为空栈。若s为空栈,则返回值为true；否则为false。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">StackLength</span>(S) <span class="comment">//栈S的长度</span></span><br></pre></td></tr></table></figure><p>}ADT Stack</p><h2 id="栈的输出特点">栈的输出特点</h2><p>一般地，输入序列<spanclass="math inline">\((...,a_i,...,a_j,...,a_k)\)</span>到栈中，不能得到<spanclass="math inline">\((...,a_k,...,a_i,...,a_j)\)</span>​</p><h2 id="栈的存储结构">栈的存储结构</h2><p>栈的范围为<code>s[0...maxlen- 1]</code></p><ol type="1"><li><p>顶指针指向栈顶元素所在的位置</p><p>栈顶元素：s[top]</p><p>进栈：先对top + 1，再将新数据指向top</p><p>出栈：先取栈顶元素，再对top - 1</p><p>空栈：<code>top == -1</code></p><p>非空栈：<code>top &gt;= 0</code></p><p>满栈：<code>top == maxlen - 1</code></p></li><li><p>顶指针指向顶元素上的一空位置</p><p>栈顶元素：s[top - 1]</p><p>进栈：先将新数据指向top，再对top + 1</p><p>出栈：先对top - 1，再取栈顶元素</p><p>空栈：<code>top == 0</code></p><p>非空栈：<code>top &gt;= 0</code></p><p>满栈：<code>top == maxlen</code></p></li></ol><p><strong><spanclass="math inline">\(\color{red}{顺序栈规定top指向栈元素上一空位置}\)</span>​</strong></p><h2 id="顺序栈">顺序栈</h2><p>存储表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>初始化栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base =(SElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SElemType)*STACK_INIT_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//内存分配失败</span></span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果内存不够</span></span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize) </span><br><span class="line">    &#123;</span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(S.base,(S.stacksize + STACK_INIT_SIZE)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINITSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    *(S.top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;<span class="comment">//如果栈为空</span></span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式栈">链式栈</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292207525.png" /></p><p>让top指向an，进栈将新节点作为首节点，出栈删除首节点，保证进出栈时间为常数</p><h2 id="栈的应用">栈的应用</h2><h3 id="数制转换">数制转换</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292226270.png" /></p><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,N);</span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, N % <span class="number">8</span>);</span><br><span class="line">        N /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号匹配">括号匹配</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292231643.png" /></p><h3 id="表达式求值">表达式求值</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292253188.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292254637.png" /></p><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OperandType <span class="title">EvaluateExpression</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR); <span class="built_in">Push</span>(OPTR, <span class="string">&#x27;#&#x27;</span>);<span class="comment">//初始化操作符的栈</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPND); c = <span class="built_in">getchar</span>();<span class="comment">//初始化操作数的栈</span></span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(c, OP))<span class="comment">//如果不是运算符就进栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(OPND, c);</span><br><span class="line">            c = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), c))<span class="comment">/*判断优先级*/</span></span><br><span class="line">             <span class="comment">/*栈顶优先级低*/</span></span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>&lt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Push(OPRT, c);</span></span><br><span class="line"><span class="string">            c = getchar();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">            /*脱括号并接收下一个字符*/</span></span><br><span class="line"><span class="string">            case&#x27;</span>=<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Pop(OPRT, x);</span></span><br><span class="line"><span class="string">            c = getchar();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">               /*退栈并将运算符结果入栈*/</span></span><br><span class="line"><span class="string">            case&#x27;</span>&gt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Pop(OPRT, theta);</span></span><br><span class="line"><span class="string">            Pop(OPND, b);</span></span><br><span class="line"><span class="string">            Pop(OPND, a);</span></span><br><span class="line"><span class="string">            Push(OPND, Operate(a, theta, b));</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return GetTop(OPND);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="队列">队列</h1><p>队列：只允许在表的一端插入一端删除的数据结构 ---“先进先出”</p><h2 id="adt-2">ADT</h2><p>ADT Queue</p><p>{</p><p>​ 数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq0\right\}\)</span></p><p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<spanclass="math inline">\(a_n\)</span>端为队列尾，<spanclass="math inline">\(a_1\)</span>端为队列头</p><p>​ 基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitQueue</span>(&amp;Q) <span class="comment">//初始化,构造空队列。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyQueue</span>(&amp;Q) <span class="comment">//销毁Q队列。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearQueue</span>(&amp;Q) <span class="comment">//置Q为空队列。</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">QueueEmpty</span>(Q) <span class="comment">//判断Q是否为空队列。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">EnQueue</span>(&amp;Q,e) <span class="comment">//将e插入队列Q的尾端。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">DeQueue</span>(&amp;Q,&amp;e) <span class="comment">//取走队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">GetHead</span>(Q,&amp;e) <span class="comment">//读取队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">QueueLengrh</span>(Q) <span class="comment">//返回队列长度</span></span><br></pre></td></tr></table></figure><p>}ADT Queue</p><h2 id="链式队列">链式队列</h2><p>用带头节点的单链表表示队列</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292334133.png" /></p><p>存储表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span>* next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>初始化队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349895.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349851.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;<span class="comment">//头插</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="comment">//如果是只有一个节点的情况</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><p><ahref="https://blog.csdn.net/qq_61959780/article/details/127332940?app_version=6.2.9&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127332940%22%2C%22source%22%3A%22luckyYY520%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">参考此篇blog</a></p><p>分辨队满&amp;队空</p><ol type="1"><li>rear指向的为空，留一个空位置<ol type="1"><li>队空：<code>q.rear == q.front</code></li><li>队满：<code>q.rear + 1 == q.front</code></li></ol></li><li>设置flag标志<ol type="1"><li>入队时如果<code>q.rear == q.front</code>，则队满，设置flag为true</li><li>出队时如果<code>q.rear == q.front</code>，则队空，设置flag为false</li></ol></li><li>记录length</li></ol><p>找到front, rear, length的关系</p><p><code>front = (rear + MAXSIZE - length) % MAXSIZE</code></p><h1 id="数组">数组</h1><h2 id="数组的递归定义">数组的递归定义</h2><ul><li><p>一维数组：<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>，其中<spanclass="math inline">\(a_i\)</span>为数据元素<spanclass="math inline">\(1\leq i\leq n\)</span></p></li><li><p>二维数组：<spanclass="math inline">\((\alpha_1,\alpha_2,...,\alpha_m)\)</span>，其中<spanclass="math inline">\(\alpha_i = (a_{i1},a_{i2},...,a_{in})\)</span>为行向量，<span class="math inline">\(1\leqi\leq m\)</span></p></li><li><p>三维数组：<spanclass="math inline">\((\beta_1,\beta_2,...,\beta_p)\)</span>，其中<spanclass="math inline">\(\beta_k=(\alpha_1,\alpha_2,...,\alpha_m)\)</span>，<spanclass="math inline">\(1\leq k\leq p\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301404268.png" /></p></li></ul><h2 id="数组的顺序表示">数组的顺序表示</h2><ol type="1"><li><p>以行序为主序的顺序存储方式</p><p><spanclass="math inline">\(\color{red}{左边的下标后变化，右边的下标先变化}\)</span></p></li><li><p>以列序为主序的顺序存储方式</p><p><spanclass="math inline">\(\color{red}{左边的下标先变化，右边的下标后变化}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301413278.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301415139.png" /></p></li></ol><h2 id="数组的映像函数">数组的映像函数</h2><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301418472.png" style="zoom: 67%;" /></p><ol type="1"><li><p>以行序为主序，<spanclass="math inline">\(a[i][j]\)</span>的地址为：</p><p><span class="math inline">\(Loc(i, j) = Loc(1, 1)+((i - 1)*n +(j -1))*s\)</span></p></li><li><p>以列序为主序，<spanclass="math inline">\(a[i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(i,j)=Loc(1,1)+((j-1)*m+(i-1))*s\)</span></p></li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301422772.png" style="zoom:67%;" /></p><ol type="1"><li><p>以行序为主序，<spanclass="math inline">\(a[k][i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((k-1)*m*n+(i-1)*m+(j-1))*s\)</span></p></li><li><p>以列序为主序，<spanclass="math inline">\(a[k][i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((j-1)*p*m+(i-1)*p+k-1)*s\)</span></p></li></ol><h2 id="矩阵的压缩存储">矩阵的压缩存储</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301905856.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301909749.png" /></p><p><span class="math inline">\(a_{ij}\)</span>在SA中的序号：</p><p><span class="math inline">\(k(i,j) =\)</span> <spanclass="math inline">\(\left\{\begin{aligned}i(i-1)/2 + j&amp; &amp;i\geq j\\ j(j-1)/2+i&amp; &amp;i&lt;j\end{aligned}\right.\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301916257.png" /></p><p>任意<span class="math inline">\(a_{ij}\neq0\)</span>，在SA中的序号：<spanclass="math inline">\(k=((i-1)*3-1)+(j-i+2)=2i+j-2\)</span></p><p><span class="math inline">\(A[i,j]=\)</span> <spanclass="math inline">\(\left\{\begin{aligned}k&amp; &amp;|i-j|\leq 1\\0&amp; &amp;其他\end{aligned}\right.\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301941684.jpg" /></p><h2 id="稀疏矩阵的存储">稀疏矩阵的存储</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405302304289.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;<span class="comment">//非零元的下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];<span class="comment">//非零元三元组表</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数和非零元的个数</span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"><span class="comment">//求稀疏矩阵的转置</span></span><br><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.mu = M.nu, T.nu = M.mu, T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span>(T.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt;= M.nu; col++) num[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t &lt;= M.tu; t++) ++num[M.data[t].j];</span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">2</span>;col &lt;= M.nu; ++col) cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= M.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j;</span><br><span class="line">            T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[p].e;</span><br><span class="line">            ++cpot[col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十字链接表">十字链接表</h2><p>[见此篇blog](<ahref="https://blog.csdn.net/qq_42185999/article/details/105083274">稀疏矩阵的十字链表存储表示和实现（第五章P104算法5.4）_用十字链表实现稀疏矩阵的存储,写出其创建和输出算法-CSDN博客</a></p><h1 id="广义表">广义表</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062335576.jpg" /></p><h1 id="二叉树">二叉树</h1><h2 id="二叉树的性质">二叉树的性质</h2><ol type="1"><li>二叉树第i层，最多有<spanclass="math inline">\(2^{i-1}\)</span>个结点</li><li>深度为k的二叉树，最多有<span class="math inline">\(2^k -1\)</span>个结点</li><li><span class="math inline">\(n_0=n_2+1\)</span></li><li>n个结点的满二叉树深度为<spanclass="math inline">\(log_2(n+1)\)</span></li><li>顺序编号的满二叉树<span class="math inline">\(1,2,...,n\)</span><ul><li>结点i的左孩子为2i，右孩子为2i+1</li><li>结点i的双亲为<span class="math inline">\(\lfloori/2\rfloor\)</span></li><li>结点i的层号<span class="math inline">\(\lfloorlog_2i\rfloor+1=\lceil log_2(n+1)\rceil\)</span>​</li></ul></li><li>n个结点可以组成<spanclass="math inline">\(\frac{(2n)!}{(n+1)!n!}\)</span>棵形态不同的二叉树</li></ol><h2 id="二叉树的存储">二叉树的存储</h2><h3 id="顺序存储">顺序存储</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323914.png" /></p><h3 id="链式存储">链式存储</h3><ol type="1"><li>二叉链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>三叉链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* parent;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>静态链表</li></ol><h2 id="二叉树的遍历">二叉树的遍历</h2><p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<spanclass="math inline">\(O(n)\)</span>​</p><blockquote><p>前序+中序 / 中序+后序可以唯一确定一个二叉树</p><p>前序+后序不能唯一确定一个二叉树(eg: 先序ABC 后序CBA)</p></blockquote><h3 id="先序遍历">先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历">中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历">后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历">非递归遍历</h3><p>中序遍历：</p><ol type="1"><li>第一次访问到根节点不访问，直接入栈</li><li>中序遍历左子树，左子树遍历结束之后，第二次遇到根节点，退栈进行访问，然后中序遍历右子树</li><li>退栈时栈为空结束</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><ol type="1"><li>沿着根的左孩子依次入栈，直到左孩子为空</li><li>如果没有右孩子，或者右孩子已经访问过，就访问该根节点</li><li>栈顶元素出栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree last;<span class="comment">//上一个访问的节点</span></span><br><span class="line">    BitTree st[maxlength];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        st[top++] = t;</span><br><span class="line">        t = t-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">BitTree tmp = st[--top];</span><br><span class="line">        <span class="keyword">if</span>((tmp-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; tmp-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">/*如果左右孩子均为空*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == last)<span class="comment">/*右孩子已经访问完*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == <span class="literal">NULL</span> &amp;&amp; tmp-&gt;lchild == last))<span class="comment">/*右孩子为空，左孩子访问了*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, tmp-&gt;data);<span class="comment">//访问</span></span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BitTree r = tmp-&gt;rchild;</span><br><span class="line">            <span class="keyword">while</span>(r)</span><br><span class="line">            &#123;</span><br><span class="line">                st[top++] = r;</span><br><span class="line">                r = r-&gt;l·child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><p>原理：使用队列进行存储，将根节点放入队列中，并且访问之后将该节点的左右孩子加入队列中</p><h2 id="创建二叉树">创建二叉树</h2><h3 id="递归法">递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == #) root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (BiTree)<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        root-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归法">非递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        q = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        q-&gt;data = e;</span><br><span class="line">        q-&gt;lchild = <span class="literal">NULL</span>, q-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        s[i] = q;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) root = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">2</span>) s[j]-&gt;rchild = q;</span><br><span class="line">            <span class="keyword">else</span> s[j]-&gt;lchild = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树">线索二叉树</h2><h3 id="概念-1">概念</h3><p>规则：</p><ol type="1"><li>若结点的左子树为空，则该结点的左孩子指向其前驱结点</li><li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li></ol><p>为了区别lchild/rchild是指向左右孩子还是前/后驱结点，添加标志位ltag,rtag：</p><ol type="1"><li><code>ltag == 0</code>，指向左孩子；<code>ltag == 1</code>，指向前驱结点</li><li><code>rtag == 0</code>，指向右孩子；<code>rtag == 1</code>，指向后继结点</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311434403.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311443551.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311444734.png" /></p><h3 id="线索化二叉树">线索化二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Thread</span>* lchild, rchild;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThreadTree</span><span class="params">(<span class="keyword">struct</span> Thread* node, <span class="keyword">struct</span> Thread* pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;lchild, pre);</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) node-&gt;ltag = <span class="number">0</span>;<span class="comment">//左孩子不是线索</span></span><br><span class="line">    <span class="keyword">else</span> node-&gt;ltag = <span class="number">1</span>, node-&gt;lchild = pre;</span><br><span class="line">    <span class="comment">//处理前驱结点</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) </span><br><span class="line">        pre-&gt;rchild = node, pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;rchild, pre);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历线索二叉树">遍历线索二叉树</h3><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span> *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//有左孩子</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有左孩子，指向右孩子或者后继结点</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span>* p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;<span class="comment">//找到最左边的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rchild)<span class="comment">//存在后继结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>) p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//找到最左边的结点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = p-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树和森林">树和森林</h1><h2 id="树的表示形式">树的表示形式</h2><ol type="1"><li>广义表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231516.png" />2. 嵌套集合</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231188.png" /></p><ol start="3" type="1"><li>凹入表/目录表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231758.png" /></p><h2 id="树的存储结构">树的存储结构</h2><ol type="1"><li>双亲表示法/数组表示法/顺序表示法</li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407567.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">snode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;t[maxlength + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>孩子表示法/链接表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407745.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408154.png" /></p><ol start="3" type="1"><li>孩子兄弟表示法/二叉树表示法/二叉链表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408655.png" /></p><ol start="4" type="1"><li>孩子链表表示法/单链表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408590.png" /></p><ol start="5" type="1"><li>带双亲的孩子链表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408034.png" /></p><h2 id="森林树和二叉树的转换">森林、树和二叉树的转换</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021424154.png" /></p><h2 id="树和森林的遍历">树和森林的遍历</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323277.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041324802.png" /></p><h2 id="哈夫曼树">哈夫曼树</h2><p>树T的路径长度：PL(T)从树T的跟到其余每个结点的路径长度之和</p><p>树的带权路径长度：WPL(T)每个叶子的权与根到该叶子的路径长度的乘积之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HTNode, *HuffmanCode;<span class="comment">//动态分配数组存储哈夫曼树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;<span class="comment">//存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode &amp;HC, <span class="type">int</span> *w, <span class="type">int</span> n)</span><span class="comment">/*w存放n个字符的权值*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HTNode) * (m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(p = HT + <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= n; i++, p++, w++)<span class="comment">//0号单元未用</span></span><br><span class="line">    *p = &#123;*w, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= m; i++, p++) *p = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);<span class="comment">//在HT[1,..,i-1]中选择parent为0且weight最小的两个结点，其序号分别是s1,s2</span></span><br><span class="line">        HT[s1].parent = i, HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1, HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight +HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从叶子到根逆向求每个字符的哈夫曼编码*/</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[i].parent)</span><br><span class="line">        <span class="keyword">if</span>(HT[f].lchild == c) cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        HC[i] = (<span class="type">char</span>*)<span class="built_in">mallov</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (n - start));<span class="comment">//为编码开辟空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="概念-2">概念</h2><p>强连通图：图G中每对结点都存在路径</p><p>强连通分量：图G'是图G的极大连通子图，G'是G的一个强连通分量</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002704.png" /></p><h2 id="图的存储结构">图的存储结构</h2><ol type="1"><li>邻接矩阵<ul><li>无向图中<span class="math inline">\(v_i\)</span> 的度<spanclass="math inline">\(TD=\sum\limits_{j=1}^{n}M[i][j]=\sum\limits_{i=1}^{n}M[i][j]\)</span></li><li>有向图中<span class="math inline">\(v_i\)</span> 的入度<spanclass="math inline">\(ID =\sum\limits_{i=1}^{n}M[i][j]\)</span>(每一列的和)，出度<spanclass="math inline">\(OD =\sum\limits_{j=1}^{n}M[i][j]\)</span>(每一行的和)</li></ul></li><li>邻接表/逆邻接表</li><li>十字链表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002846.png" /></p><ol start="4" type="1"><li><p>邻接多重表​</p><p><ahref="https://www.bilibili.com/video/BV1TL411b7V3/?spm_id_from=333.337.search-card.all.click">具体步骤见这个视频</a></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032019350.png" /></p></li></ol><p><strong>存储结构的优缺点</strong></p><p><strong>邻接矩阵</strong></p><p>优点：</p><ol type="1"><li>简单直观，好理解</li><li>便于计算一对顶点间是否有边，并且找到所有的邻接点</li><li>方便计算一个顶点的度</li></ol><p>缺点：</p><ol type="1"><li>不利于增加或者删除节点</li><li>存储稀疏图<spanclass="math inline">\((e&lt;nlogn)\)</span>较浪费空间</li><li>在统计边数等操作方面时间复杂度大</li></ol><p><strong>邻接表</strong></p><p>缺点：</p><ol type="1"><li>求节点度困难</li><li>每条边都要存两遍（无向图）</li></ol><h2 id="图的遍历">图的遍历</h2><p>DFS/BFS时间复杂度</p><ol type="1"><li>邻接矩阵存储<span class="math inline">\(O(n^2)\)</span></li><li>邻接表存储<span class="math inline">\(O(n+e)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038343.png" style="zoom: 67%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038662.png" style="zoom: 60%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032040296.png" style="zoom: 70%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032041338.png" style="zoom: 67%;" /></p><h2 id="最小生成树">最小生成树</h2><h3 id="prim">Prim</h3><p>时间复杂度：<spanclass="math inline">\(O(n^2)\)</span>，适合稠密图</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312202.jpg" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph G, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vertexNum; i++)<span class="comment">//遍历所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        shortEdge[i].lowcost = G.arc[start][i];<span class="comment">//初始化最短路的数组</span></span><br><span class="line">        shortEdge[i].adjvex = start;<span class="comment">//存储这个路径距离中这个节点的上一个节点  </span></span><br><span class="line">    &#125;</span><br><span class="line">    shortEdge[start].lowcost = <span class="number">0</span>;<span class="comment">//将start放入集合U</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vertexNum - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">minEdge</span>(shortEdge, G.vertexNum);<span class="comment">//寻找最短边的邻接点k</span></span><br><span class="line">        <span class="built_in">outputMST</span>(k, shortEdge[k]);<span class="comment">//输出最小生成树的路径</span></span><br><span class="line">        shortEdge[k].lowcast = <span class="number">0</span>;<span class="comment">//将k加入集合U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vertexNum; j++)<span class="comment">//调整shortEdge数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.arc[k][j] &lt; shortEdge[j].lowcast)</span><br><span class="line">            &#123;</span><br><span class="line">                shortEdge[j].lowcast = G.arc[k][j];</span><br><span class="line">                shortEdge[j].adjvex = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kruskal算法">Kruskal算法</h3><p>时间复杂度：<span class="math inline">\(O(eloge)\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312333.jpg" /></p><h2 id="拓扑排序">拓扑排序</h2><blockquote><p>有回路的有向图不存在拓扑排序</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312495.png" /></p><h2 id="aoe网">AOE网</h2><blockquote><p>先求点，再求边</p></blockquote><p>工程完成的最短时间是从开始点到完成点的最长路径长度，路径长度最长的路径叫做关键路径，关键路径上的点为关键点--开始时间等于结束时间</p><p><ahref="https://www.bilibili.com/video/BV1dy421a7S1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef5e5127819460e26182982933cfa21e">请参考这个视频</a></p><ol type="1"><li>ve(事件/节点的最早开始时间)，拓扑排序，每次选取<strong>入度</strong>为0的点，更新与之相邻的结点，ve是最长的那条路径长度</li><li>vl(事件/节点的最晚开始时间)，初始化所有结点的vl为终点的ve，<strong>逆</strong>拓扑排序，每次选取<strong>出度</strong>为0的点，更新与之相邻的结点，vl是选择使vl最小的那条路</li><li>e(活动/边的最早开始时间)，与发出这条边的结点的ve一致</li><li>l(活动/边的最晚开始时间)，用这条边指向的结点的vl减去这条边的边权</li></ol><h2 id="最短路径">最短路径</h2><h3 id="dijkstra算法">Dijkstra算法</h3><blockquote><p>解决单源最短路问题</p></blockquote><p><ahref="https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.999.0.0&amp;vd_source=ef5e5127819460e26182982933cfa21e">请参考这个视频</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//把起始点距离初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//用于找到当前距离起点最短的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新节点距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd算法">Floyd算法</h3><p><ahref="https://www.bilibili.com/video/BV19k4y1Q7Gj/?spm_id_from=333.788&amp;vd_source=ef5e5127819460e26182982933cfa21e">请参考这个视频</a></p><blockquote><p>求任意两个节点间的最短路径</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph G, PathMatrix&amp; p[], DistanceMatrix&amp; D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">        &#123;</span><br><span class="line">            D[v][w] = G.arcs[v][w];</span><br><span class="line">            <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                P[v][w][u] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(D[v][w] &lt; INFINITY)</span><br><span class="line">                &#123;</span><br><span class="line">                    P[v][w][v] = <span class="literal">true</span>;</span><br><span class="line">                    P[v][w][w] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(D[v][u] + D[u][w] &lt; D[v][w])</span><br><span class="line">                &#123;</span><br><span class="line">                    D[v][w] = D[v][u] + D[u][w];</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        P[v][w][i] = P[v][u][i] || P[u][w][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找">查找</h1><h2 id="静态查找表">静态查找表</h2><h3 id="顺序查找法">顺序查找法</h3><ol type="1"><li><p>不设置监视哨</p><p>判断条件：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">1</span> &amp;&amp; k != ST.elem[i].key)i--;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>设置监视哨</li></ol><p>​ <code>elem[0].key = k;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(k != ST.elem[i].key)i--;</span><br></pre></td></tr></table></figure><p>ASL成功 = (n + 1) / 2</p><p>ASL失败：使用监视哨 = n + 1, 不使用监视哨 = n</p><h3 id="折半查找法">折半查找法</h3><p>相当于二分查找</p><h3 id="判定树">判定树</h3><p>描述折半查找过程的二叉树(从1开始，放的是序号不是值)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051340541.png" /></p><p>若判定树为满二叉树：<span class="math inline">\(ASL =\frac{n+1}{n}log2(n + 1) - 1\)</span></p><p>证明：<imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051338386.jpg" /></p><h2 id="动态查找表">动态查找表</h2><h3id="二叉排序树二叉查找树"><strong>二叉排序树（二叉查找树）</strong></h3><p>特点：如果二叉树的任一结点大于其非空左子树的所有结点，而小于其非空右子树的所有结点，则这棵二叉树称为二叉排序树。<strong><spanclass="math inline">\({\color{red}(左小右大)}\)</span>​​</strong></p><p>平均ASL= O(logn)</p><h4id="删除二叉排序树中的结点"><strong><em>删除二叉排序树中的结点</em></strong></h4><p>设被删除的结点为*p，其双亲结点为*f，*s为*p的前驱结点，*p是*f的左孩子，有三种情况：</p><ol type="1"><li><p>*p为叶子结点：直接删除</p></li><li><p>*p只有左孩子PL或者右孩子PR：让PL/PR为*f的左孩子</p></li><li><p>*p的左孩子PL和右孩子PR均不为空：</p><ol type="1"><li><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071134367.png" /></p></li><li><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071135262.png" /></p></li></ol></li></ol><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是待删除的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果左子树为空，或者为叶子结点</span></span><br><span class="line">    &#123; q = p; p = p-&gt;rchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//如果右子树为空</span></span><br><span class="line">    &#123; q = p; p = p-&gt;lchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果左右子树均不为空 以方法二为例</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;<span class="comment">//设置s的双亲结点是q</span></span><br><span class="line">            s = s-&gt;rchild;<span class="comment">//遍历直到找到p的前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;<span class="comment">//将p替换成s</span></span><br><span class="line">        <span class="comment">//要判断是因为如果删除结点的左子树有右子树那么中序遍历的前驱结点是右孩子，否则前驱结点是左孩子，就会导致移动的不同</span></span><br><span class="line">        <span class="keyword">if</span>(p != q)<span class="comment">//表明删除节点的左子树有右子树</span></span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;<span class="comment">//不需要free因为原来的s占的是q-&gt;left，现在已经被替换了</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树avl树"><strong>平衡二叉树</strong>(<spanclass="math inline">\(AVL\)</span>树)</h3><ol type="1"><li>结点的平衡因子：结点的左右子树深度之差（左子树高度-右子树高度）</li><li>平衡二叉树：任意结点平衡因子的绝对值小于等于1的二叉树</li></ol><h4id="高度一定的avl树所含最小节点个数">高度一定的AVL树所含最小节点个数</h4><p>S(h)表示深度为h的平衡二叉树所含有的最少节点个数</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051555220.png" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051556641.png" style="zoom: 67%;" /></p><h4id="构造平衡二叉搜索树的方法"><strong><em>构造平衡二叉搜索树的方法</em></strong></h4><ul><li><p>左旋：向作左旋转，冲突的左孩变右孩</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081654715.png" /></p></li><li><p>右旋：向右旋转，冲突的右孩变左孩</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081656759.png" /></p></li><li><p><span class="math inline">\(LL\)</span>型，<spanclass="math inline">\(RR\)</span>型，<spanclass="math inline">\(LR\)</span>型，<spanclass="math inline">\(RL\)</span>​型</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081714341.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081716342.png" /></p><ul><li><span class="math inline">\(LL\)</span>型：右旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715912.png" /></p><ul><li><span class="math inline">\(RR\)</span>​型：左旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081849686.png" /></p><ul><li><span class="math inline">\(LR\)</span>​型：先左旋左孩子，再右旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715436.png" /></p><ul><li><span class="math inline">\(RL\)</span>​型：先右旋右孩子，再左旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715357.png" /></p></li><li><p>插入结点时平衡失调，调整离删除结点最近的失衡结点即可</p><p>删除结点时平衡失调，依次对每个祖先进行检查和调整</p></li></ul><h3 id="哈希表">哈希表</h3><h4 id="构造哈希函数的方法"><em>构造哈希函数的方法</em></h4><ol type="1"><li><p>直接定址法：取关键字或者关键字的某个线性函数值作为哈希地址</p></li><li><p>除留余数法：设哈希表HT[0,1,..,m-1]的表长为m，哈希地址为key除以p所得余数（p为接近m的素数或为不包含20以内质因数的合数）</p></li><li><p>平方取中法：取关键字平方后的中间某几位为哈希地址</p></li><li><p>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址</p><ol type="1"><li><p>边界折叠法：<span class="math inline">\(eg: k1 =056439527\)</span>对应的地址为<spanclass="math inline">\(650+439+725\)</span></p></li><li><p>移位折叠法：<span class="math inline">\(eg: k1 =056439527\)</span>对应的地址为</p><p><span class="math inline">\(056+439+527\)</span></p></li></ol></li><li><p>数字分析法：如果哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干分布均匀的位组成哈希地址</p></li><li><p>随机数法：利用<spanclass="math inline">\(random(key)\)</span>​</p></li></ol><h4 id="解决哈希冲突的方法"><em>解决哈希冲突的方法</em></h4><ol type="1"><li>开放地址法<ol type="1"><li>线性嗅探再散列</li><li>二次嗅探再散列</li></ol></li><li>链地址法</li><li>建立公共溢出区</li><li>再哈希法</li></ol><h4 id="哈希化的效率"><strong><em>哈希化的效率</em></strong></h4><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405132118931.png" /></p><h4id="哈希表的平均查找长度"><strong><em>哈希表的平均查找长度</em></strong></h4><p><ahref="%5B哈希表：线性探测法和链地址法求查找成功与不成功的平均查找长度_链地址法查找失败的平均查找长度怎么算-CSDN博客%5D(https://blog.csdn.net/KD35KD/article/details/107054474)">见此篇BLOG</a></p><p>散列表</p><p>查找成功的概率：</p><ul><li>分母：所有待插入的元素的个数</li><li>分子：每个位置元素出现的个数</li></ul><p>查找失败的概率：</p><ul><li>分母：mod的大小</li><li>分子：从0-m-1的每一个位置到下一个空位置需要查找的个数</li></ul><h1 id="排序">排序</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406052033580.png" /></p><h2id="插入排序朴素版--稳定排序-折半版--不稳定">插入排序（朴素版--稳定排序折半版--不稳定）</h2><blockquote><p>第n趟排序，保证前n + 1个元素有序</p></blockquote><p>操作：将新的元素插入到已排序的数组中</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span>​</p><ul><li><p>最好的情况：原n个记录递增有序</p><p>比较关键字次数：<span class="math inline">\(n-1\)</span>次</p><p>移动记录次数：<spanclass="math inline">\(2(n-1)\)</span>次（将数据复制到a[0]又复制回来）</p></li><li><p>最坏的情况：原n个记录递减有序</p><p>比较关键字次数：<span class="math inline">\(\sum_\limits{i = 2}^n i =2+3+...+n = \frac{(n-1)(n+2)}{2}\)</span></p><p>移动记录次数：<span class="math inline">\(\sum_\limits{i=2}^{n}(i-1+2)=3+4+...+n=\frac{(n-1)(n+4)}{2}\)</span></p><p>（+2是因为监视哨，先复制一遍，再加到合适的位置）</p></li></ul><p>朴素版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序 </span></span><br><span class="line"><span class="comment">//对1-n进行排序(n表示的是数组的最后一个元素的下标，不是元素个数) </span></span><br><span class="line"><span class="comment">//在a[0]设置监视哨</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">cur = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[cur];</span><br><span class="line">cur--;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半插入排序（不稳定）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="comment">//优化了比较次数，但是只有当n很大时使用折半插入效率更高</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>, m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)<span class="comment">//利用二分法折半查找</span></span><br><span class="line">&#123;</span><br><span class="line">m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[m])high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在high左边</span></span><br><span class="line"><span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在low的右边</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//high + 1即是待插入的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[high + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二路插入排序：</p><p>优点：可以减少移动的次数</p><p>操作：（排序长度为n的序列）相当于先开辟长度为n的数组，将该数组当做一个循环的空间，进行插入。</p><p>表插入排序：</p><h2 id="希尔排序colorred-不稳定排序">希尔排序<spanclass="math inline">\(\color{red} {（不稳定排序）}\)</span>​</h2><blockquote><p>第n趟排序后，能找到n个gap使元素每隔gap个元素就有序</p></blockquote><p>操作：每次排序相隔gap的元素，不断缩小gap，直至gap ==1，排序后退出循环</p><p>时间复杂度：<span class="math inline">\(O(n ^{1.3})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--希尔排序  O(n^1.3)</span></span><br><span class="line"><span class="comment">//1. gap &gt; 1 预排序</span></span><br><span class="line"><span class="comment">//2. gap == 1 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> gap, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> cur = i - gap;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + gap] = a[cur];</span><br><span class="line">cur -= gap;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + gap] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后记录位置的增量为dk</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellInsert</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = dk + <span class="number">1</span>; i &lt;= L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">LT</span>(L.r[i].key, L.r[i - dk].key))<span class="comment">//将L.r[i]插入有序增量子表</span></span><br><span class="line">         &#123;</span><br><span class="line">             L.r[<span class="number">0</span>] = L.r[i];<span class="comment">//暂存在L.r[0]中，不是哨兵位</span></span><br><span class="line">             <span class="keyword">for</span>(j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">LT</span>(L.r[j].key, L.r[<span class="number">0</span>].key)); j -= dk)</span><br><span class="line">             &#123;</span><br><span class="line">                 L.r[j + dk] = L.r[j];</span><br><span class="line">             &#125;</span><br><span class="line">             L.r[j + dk] = L.r[<span class="number">0</span>];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> delta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, delta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序colorred不稳定排序">快速排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>第n趟排序之后，有n个元素在它应该在的位置上</p></blockquote><p>操作：随机在数组中找一个数，利用递归，让左边的数都小于该数，右边的数都大于该数</p><ul><li>时间复杂度：<spanclass="math inline">\(O(nlogn)\)</span>，最坏的情况下（序列基本有序）时间复杂度为<spanclass="math inline">\(O(n^2)\)</span></li><li>空间复杂度：快排需要一个栈做辅助空间，平均情况下需要<spanclass="math inline">\(O(nlogn)\)</span>的空间，最坏的情况下，要递归n次，需要<spanclass="math inline">\(O(n)\)</span>的空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, left, right);<span class="comment">//找到在left，mid，right三个下标下大小是中间的那个的下标</span></span><br><span class="line"><span class="built_in">Swap</span>(a + keyi, a + left);</span><br><span class="line"><span class="comment">//左边当key 右边先走 ；右边当key 左边先走</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Swap</span>(a + left, a + right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(a + left, a + keyi);</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> part = <span class="built_in">PartSort</span>(a, begin, end);</span><br><span class="line"><span class="built_in">QuickSort</span> (part + <span class="number">1</span>, end);</span><br><span class="line"><span class="built_in">QuickSort</span>(begin, part - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.r[<span class="number">0</span>] = L.r[low];<span class="comment">//选最左边为pivotkey</span></span><br><span class="line">    pivotkey = L.r[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)</span><br><span class="line">           high--;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">pivotloc = <span class="built_in">partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">Qsort</span>(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三路划分的优化快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortThree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, begin, end);</span><br><span class="line"><span class="built_in">Swap</span>(a + keyi, a + begin);</span><br><span class="line"><span class="type">int</span> left = begin, right = end, cur = begin + <span class="number">1</span>, key = a[begin];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[cur] &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + cur, a + left);</span><br><span class="line">++cur, ++left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[cur] == key)</span><br><span class="line">&#123;</span><br><span class="line">++cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + cur, a + right);</span><br><span class="line">--right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">QuickSortThree</span>(a, begin,left - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSortThree</span>(a, right + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序colorred不稳定排序">选择排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>排序n趟之后，前n个元素应该是整个序列中最小的n个元素，并且顺序排列</p></blockquote><p>操作：每次选择未选择序列中最小的（最大的），放在已经排序的序列之后时间复杂度：</p><ul><li>比较次数：<spanclass="math inline">\(\frac{n(n-1)}{2}\)</span>即<spanclass="math inline">\(O(n^2)\)</span>​</li><li>移动次数：<ul><li>最好的情况，一开始就是升序，不需要移动</li><li>最坏的情况：每次都需要移动（不是降序的时候），交换记录数为n-1对，移动记录数为3(n-1)（因为swap里面有三条语句）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mini = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[mini]) mini = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[mini], &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序colorred不稳定排序">堆排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>排序n趟之后，数组的最后n个元素应该是最大且有序的</p></blockquote><p>对n较大的文件有效</p><p>操作：升序建大堆，降序建小堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">++child;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> child)</span><span class="comment">//造大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">AdjustUp</span>(a, i);</span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a, a + end);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, end , <span class="number">0</span>);</span><br><span class="line"><span class="comment">//因为end是交换过去的最后一个 所以循环应该到这个就结束 不应该传end+1</span></span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Sqlist HeapType;</span><br><span class="line"><span class="comment">//H[s...m]中除了H.r[s].key其他都满足堆的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType&amp; H, <span class="type">int</span> s, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rc = H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; <span class="built_in">LT</span>(H.r[j].key, H.r[j + <span class="number">1</span>].key)) j++;</span><br><span class="line">        <span class="keyword">if</span>(!(rc.key, H.r[j].key)) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s] = H.r[j]; s = j;<span class="comment">//向下遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType&amp; H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = H.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    <span class="keyword">for</span>(i = H.length; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        H.r[i]&lt;--&gt;H.r[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序稳定排序">归并排序（稳定排序）</h2><blockquote><p>第1趟排序之后，从开始起相邻两个元素为升序排列；第二趟排序之后，相邻4个元素为升序排列……第n趟排序之后，相邻<spanclass="math inline">\(2^n\)</span>个元素为升序排列</p></blockquote><p>操作：将它们划分为长度均为1的子序列，然后逐步二路归并</p><p>时间复杂度：</p><ul><li>对n个记录的文件进行归并排序，共需要<spanclass="math inline">\(log_2n\)</span>趟，每趟所需要比较的关键字次数不超过n，所以总比较次数为<spanclass="math inline">\(O(nlogn)\)</span></li><li>每趟移动n个记录，移动次数为<spanclass="math inline">\(O(nlogn)\)</span></li><li>归并排序需要一个大小为n的辅助空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin == end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">MergeSort</span>(a, begin, mid, tmp);</span><br><span class="line"><span class="built_in">MergeSort</span>(a, mid + <span class="number">1</span>, end, tmp);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = begin, end1 = mid;</span><br><span class="line"><span class="type">int</span> begin2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"><span class="type">int</span> i = begin;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line"><span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType&amp; TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将有序的SR[i...m]和SR[m + 1...n]归并为有序的TR[i...n]</span></span><br><span class="line">    <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">LQ</span>(SR[i].key, SR[j].key)) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= m) TR[k...n] = SR[i...m];</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= n) TR[k...n] = SR[j...n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MSort</span><span class="params">(RcdType SR[], ScdType&amp; TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将SR[s...t]归并为TR1[s...t]</span></span><br><span class="line">    <span class="keyword">if</span>(s == t) TR1[s] = SR[s];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (s + t)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Msort</span>(SR, TR2, s, m);</span><br><span class="line">        <span class="built_in">Msort</span>(SR, TR2, m + <span class="number">1</span>, t);</span><br><span class="line">        <span class="built_in">Merge</span>(TR2, TR1, s, m, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(Sqlist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Msort</span>(L.r, L.r, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序稳定排序">基数排序（稳定排序）</h2><p>操作：</p><ul><li>MSD：高位有效优先</li><li>LSD：低位有效优先</li></ul><p>MSD对应数字排序：下面以个位为例</p><p>数组形式：</p><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281546971.mp4" width="100%" height="100%" controls="controls"></video><p>队列形式：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936416.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936776.png" /></p><p>时间复杂度：设数字的有效位数为d</p><ul><li>需要d趟回收分配，每趟分配运算时间为<spanclass="math inline">\(O(n)\)</span></li><li>收集：基数为rd,即rd个队列。从rd个队列中收集，运算时间O(rd)</li><li>一趟分配、回收运算时间O(n+rd), 时间复杂度O(d*(n+rd))</li><li>辅助空间：每个队列首尾2个指针，共2rd个指针；n个记录需要n个指针域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/05/07/%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/07/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法基础">算法基础</h1><h2 id="读入优化">读入优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="读入方式">读入方式</h2><p>当未知要读入几组数据时可以用<code>while(scanf("%d%d", &amp;n, &amp;m) != -1)</code></p><h2 id="离散化">离散化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//unique会将不重复的元素放在前面，重复的元素放在后面，并且返回第一个不重复元素的位置</span></span><br></pre></td></tr></table></figure><h2 id="stl">STL</h2><h3 id="vector">vector</h3><p>操作：</p><ul><li>push_back()</li><li>pop_back()</li><li>size()</li><li>clear()</li><li>insert()</li><li>erase()<ul><li>erase(_position) --删除某个元素</li><li>erase(position_start, position_end)--删除区间<spanclass="math inline">\([position\_start,position\_end)\)</span>内的元素</li></ul></li></ul><h3 id="set">set</h3><p>特点：</p><ol type="1"><li>set的含义是集合，所有操作都在<spanclass="math inline">\(O(logn)\)</span>的时间复杂度内完成</li><li>set插入的元素不能相同</li><li>所有元素会根据值排序（默认是从小到大）</li><li>set中元素的值不能被直接修改</li><li>set不支持下标访问操作，只支持迭代器</li><li>模版：set<type> s;</li></ol><p>操作：</p><ul><li>begin()--返回指向第一个元素的迭代器</li><li>end()--返回指向最后一个元素的迭代器</li><li>clear()<br /></li><li>empty() --如果集合为空，返回true，否则返回false</li><li>erase()</li><li>count()<br /></li><li>find(k)</li><li>insert()</li><li>lower_bound(k) -- 返回一个迭代器，指向键值大于等于k的第一个元素</li><li>upper_bound(k) --返回一个迭代器，指向键值大于k的第一个元素</li><li>size()</li></ul><h3 id="queue">queue</h3><p>操作：</p><ul><li>模板：queue&lt;数据类型，容器类型&gt; q</li><li>push()</li><li>pop()</li><li>size()</li><li>front()--返回队首</li><li>back()--返回队尾</li><li>empty()</li></ul><h3 id="priority_queue">priority_queue</h3><p>特点：</p><ol type="1"><li>包含头文件<span class="math inline">\(\verb|#include&lt;queue&gt;|\)</span>​</li><li>默认从大到小排序（less 从大到小，greater 从小到大）</li></ol><p>操作：</p><ul><li>push()</li><li>pop()</li><li>empty()</li><li>top()</li><li>size()</li></ul><h3 id="map">map</h3><p>特点：</p><ol type="1"><li><p>使用头文件<span class="math inline">\(\verb|#include&lt;map&gt;|\)</span></p></li><li><p>具有唯一键值对</p></li><li><p>模版：map&lt;key_type, value_type&gt;变量名</p></li><li><p>可以保证元素的有序性，默认按照键（key）从小到大排序</p><p>如果想从大到小排序：<span class="math inline">\(\verb|map&lt;string,int, greater&lt;string&gt; &gt; m;|\)</span></p></li></ol><p>操作：</p><ul><li>size()</li><li>count()</li><li>empty()</li><li>erase()</li><li>clear()</li><li>find()</li><li>insert()</li><li>begin()</li><li>end()</li><li>lower_bound()</li><li>upper_bound()</li></ul><h3 id="unordered_map">unordered_map</h3><p>特点：</p><ol type="1"><li>快速查找特定元素</li><li>存储时元素是无序的</li><li>头文件<span class="math inline">\(\verb|#include&lt;unordered_map&gt;|\)</span></li></ol><p>操作：</p><ul><li>插入：insert({key, value})/map[key] = value</li><li>删除：clear()/erase()</li><li>迭代器：begin()/end()</li><li>元素个数：size()/count()</li></ul><h3 id="pair">pair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; a;</span><br><span class="line"><span class="type">int</span> l = a[<span class="number">0</span>].first, <span class="type">int</span> r = a[<span class="number">0</span>].second;<span class="comment">//注意！！！是first和second </span></span><br></pre></td></tr></table></figure><h3 id="multiset">multiset</h3><p>multiset是<spanclass="math inline">\(&lt;set&gt;\)</span>库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在<spanclass="math inline">\(O(logn)\)</span>的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。</p><h2 id="二分查找">二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到不小于k的最小的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dic_left</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到不大于k的最大的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dic_right</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; k) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和">前缀和</h2><p><strong>一维前缀和：</strong></p><p><code>s[i] = s[i - 1] + a[i]</code></p><p>数列a中任意<span class="math inline">\(\text\ [l,r]\)</span>的和为<code>s[r] - s[l - 1]</code></p><p><strong>二维前缀和：</strong></p><p><code>s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]</code></p><p>求以<span class="math inline">\(\text\ (x1,y1)\)</span>为左上角，<span class="math inline">\(\text\ (x2,y2)\)</span>为右下角的子矩阵元素和<code>s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p><h2 id="差分">差分</h2><blockquote><p>差分序列的前缀和序列就是原序列，利用差分数组将“区间操作”变成“单点操作”</p></blockquote><p><strong>一维差分数组：</strong></p><p><code>dp[i] = a[i] - a[i - 1]</code></p><p>把a数组的[l,r]上的每个数加上c，则<code>dp[l] += c, dp[r + 1] -= c;</code></p><p>对差分数组求前缀和<code>a[i] = dp[i] + a[i - 1]</code></p><p><strong>二维差分数组：</strong></p><p><code>dp[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]</code></p><p>把矩阵中左上角为<span class="math inline">\(\text\a[x1][y1]\)</span>右下角为<span class="math inline">\(\text\a[x2][y2]\)</span>的小矩形中每个元素加上c，则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[x1][y1] += c;</span><br><span class="line">dp[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">dp[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">dp[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure><p>对差分矩阵求前缀和得原矩阵</p><p>即<code>a[i][j] = dp[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]</code></p><h2 id="位运算">位运算</h2><h3 id="二进制状态压缩">二进制状态压缩</h3><figure class="highlight plaintext"><figcaption><span>&</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406301623301.png)</span><br><span class="line"></span><br><span class="line">### 位运算交换两数</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void swap(int&amp; a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lowbit运算">lowbit运算</h3><p>lowbit(n)运算表示非负整数n在二进制表示下“最低位的1和其后所有的0”所构成的数值<code>lowbit(n) = n &amp; (~n + 1) = n &amp; (-n)</code></p><h1 id="数据结构">数据结构</h1><h2 id="单调栈">单调栈</h2><p>寻找某个数左边第一个小于它的数</p><blockquote><p>维护一个栈，栈顶元素即是当前准备入栈元素的左边第一个小于它的数</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202407031233091.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> st[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; st[tt] &gt;= x) tt--;<span class="comment">//如果栈不为空，并且栈顶元素比当前元素大，就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(!tt) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st[++tt] = x;<span class="comment">//当前元素入栈，先++，保证tt==0的时候栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><blockquote><p>滑动窗口：找区间最大值和最小值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N], a[N];<span class="comment">//q是队列，a是存储数据的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断需不需要让窗口往后移</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为是找最小值，所以如果新出现的元素比左边的元素小，那么在窗口右移的过程中，左边的那个更大的元素必定用不到，所以删去</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//将新元素加进队列</span></span><br><span class="line">        <span class="comment">//整个队列单调增，所以hh位置元素最小</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前队列中的元素个数大于k，需要队首出队</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="comment">//因为找最大值，所以如果新出现元素更大，同上，删去左边的元素</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;</span><br><span class="line">        q[++tt] = i;<span class="comment">//在队列里面存下标</span></span><br><span class="line">        <span class="comment">//整个队列单调减，hh位置元素最大</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论">图论</h1><h2 id="dfs和bfs">DFS和BFS</h2><h3 id="dfs">DFS</h3><blockquote><p>dfs重点在递归，每次递归需要考虑递归传递的参数、结束条件，并且要及时“还原”改变的参数</p></blockquote><h4 id="全排列">全排列</h4><ol type="1"><li>递归传递的参数：表示当前答案中有多少个数字</li><li>递归结束的条件：当前答案中的数字达到n</li><li>递归的过程：设置st数组，判断该数字是否被使用过；每次递归后需还原st的状态</li></ol><p><strong>全排列的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//递归的参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; n)<span class="comment">//结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            res[x] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="n皇后">n皇后</h4><ol type="1"><li>递归传递的参数：表示当前放到了第几行</li><li>递归结束的条件：遍历到了最后一行</li><li>递归的过程：每一行利用for循环遍历每一列，每次递归后“还原”place以及行列斜的状态数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> place[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//遍历x行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)<span class="comment">//结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; place[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y++)<span class="comment">//遍历列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[y - x + n])</span><br><span class="line">        &#123;</span><br><span class="line">            row[x] = col[y] = dg[x + y] = udg[y - x + n] = <span class="literal">true</span>;</span><br><span class="line">            place[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            row[x] = col[y] = dg[x + y] = udg[y - x + n] = <span class="literal">false</span>;</span><br><span class="line">            place[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            place[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs">BFS</h3><blockquote><p>BFS即每次往”外“走一圈，利用队列模拟，每次出队时让与之相连的结点加入队列；单独设置一个“数组”，用来更新距离，并充当标记数组</p></blockquote><h4 id="走迷宫">走迷宫</h4><ol type="1"><li>设置方向数组dx，dy，方便“行走”</li><li>注意d数组，不仅充当表示距离的作用，也用来标记该点是否加入过队列中</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> road[N][N], d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a = t.first, b = t.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i], y = b + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; road[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[a][b] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cin &gt;&gt; road[i][j];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路问题">最短路问题</h2><h3 id="图的宽度优先搜索">图的宽度优先搜索</h3><blockquote><p>与上题的bfs类似，只是存图的方式变成了链式前向星</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], to[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;c++</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra算法">Dijkstra算法</h3><p><strong><spanclass="math inline">\(\color{blue}（不能存在负权边）\)</span></strong></p><ul><li>朴素版本 ：时间复杂度 <spanclass="math inline">\(O(n^2)\)</span>，适合稠密图（利用邻接矩阵存储）<ol type="1"><li>将起点距离初始化为0，其他点的初始距离设置为无穷</li><li>每次找到距离起点距离最近的节点，将该点做标记，表示已经设置过</li><li>更新与该点有关的结点的距离</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//循环n-1次（除了开始的结点），每次都找到到某一个点的最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//寻找当前还未找的结点距离起点的最短路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">            <span class="comment">//找到一个距离起点更小的未被标记过的结点，就让t等于那个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//设置标记表示已经找到最小距离了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新与该结点有关结点的最小距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;<span class="comment">//n个结点m条边</span></span><br><span class="line">    <span class="built_in">memset</span>(g,  <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//初始化距离为无穷大</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);<span class="comment">//利用邻接矩阵进行存储，因为有重边所以取min</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用堆排序优化：时间复杂度<spanclass="math inline">\(O(mlogn)\)</span>，适合稀疏图（利用邻接表存储）<spanclass="math inline">\({\color{red}(除了找最小距离的时候利用堆优化，其他与朴素算法一致)}\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], w[N],idx;<span class="comment">//利用链式前向星存储</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//一个用来存距离，一个用来存结点</span></span><br><span class="line"><span class="comment">//只能将距离存在前面，因为要根据距离排序</span></span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><span class="comment">//存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = z;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII q = heap.<span class="built_in">top</span>();<span class="comment">//取堆顶元素</span></span><br><span class="line">        <span class="type">int</span> a = q.second, b = q.first;<span class="comment">//a是路径的尾节点，b是这条路径的长度</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();<span class="comment">//删除刚刚用过的堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(st[a]) <span class="keyword">continue</span>;</span><br><span class="line">        st[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[a]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[a] + w[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[a] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijsktra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellmanford算法">BellmanFord算法</h3><p>求出从 1号点到 n号点的最多经过 k 条边的最短距离</p><blockquote><p>可以处理负边权回路</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], cpy[N];<span class="comment">//一个同来记录最短距离，一个同来当做临时拷贝，防止出现连续更新的情况，因为该算法要保证循环k次只能走k条边，所以每次只能更新一条边的距离，如果只有一个dist就会出现，先用a更新b，再用b更新c的情况，导致循环k次只能走k条边条件不满足。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//设置初始距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cpy, dist, <span class="keyword">sizeof</span> dist);<span class="comment">//拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], cpy[e.a] + e.w);<span class="comment">//用上一次循环的距离cpy更新这一次的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        edges[i].a = x, edges[i].b = y, edges[i].w = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BellmanFord</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//因为可能存在负边所以是0x3f3f3f3f / 2</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa算法">Spfa算法</h3><blockquote><p>类似于宽搜</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//建立队列，保证每次更新的前一个结点是更新的</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//出队列 队列中无该结点 设置为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])<span class="comment">//没有才加到队列里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa判断负环">spfa判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> to[M], ne[M], w[M], head[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[idx] = y, ne[idx] = head[x], w[idx] = z, head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = to[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd算法多源最短路">Floyd算法（多源最短路）</h3><blockquote><p>将所有情况一一列出来</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序">拓扑排序</h2><p>每次找到度为0的节点加入到最终的序列中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[tt++] = i;<span class="comment">//先找到一开始度为0的结点</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];<span class="comment">//删除t结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//更改与t结点有关的边的度数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[tt++] = j;<span class="comment">//如果度为0就加入序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        d[y]++;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">    &#125;<span class="comment">//存图</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopSort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论">数论</h1><h2 id="质数">质数</h2><h3 id="试除法判断质数">试除法判断质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a/ i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s++;</span><br><span class="line">                    a /= i;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//如果有一个比较大的因子，就输出</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法求质数">筛法求质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;<span class="comment">//如果未被标记过说明是质数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回质数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数">约数</h2><h3 id="试除法求约数">试除法求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;  cin &gt;&gt; a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//用来存储a的所有约数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(a / i != i) res.<span class="built_in">push_back</span>(a / i);<span class="comment">//保证不重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : res)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数个数为<spanclass="math inline">\((x_1+1)(x_2+1)...(x_k+1)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> +<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[i]++;</span><br><span class="line">                a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;<span class="number">1</span>) mp[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y] : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ret * (y + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ret % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数之和为<spanclass="math inline">\((    p_1^0+p_1^1+..._+p_1^{x_1})\times...\times(p_k^0+p_k^1+...+p_k^{x_k})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//存储质因数对应的个数</span></span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y]: mp)</span><br><span class="line">&#123;</span><br><span class="line">    ll t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y--)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (t * x + <span class="number">1</span>) % mod;<span class="comment">//得到每个质因子对应的加和值</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = res * t % mod;<span class="comment">//将所有质因子的加和值乘起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><h2 id="背包问题">背包问题</h2><p><ahref="https://blog.csdn.net/raelum/article/details/128996521">参考博客</a></p><h3 id="背包问题-1">01背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/28/hello-world/"/>
      <url>/2024/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405241310482.png" /></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
