<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASL</title>
      <link href="/2024/06/05/ASL/"/>
      <url>/2024/06/05/ASL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希表">哈希表</h1><h2 id="链地址">链地址</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051358262.png" /></p><p><strong>查找成功时的平均查找长度</strong></p><blockquote><p>ASL成功 = 表中每个元素查找成功时的比较的次数 /待查找的所有元素的个数</p></blockquote><p>ASL成功 = (1 * 5 + 2 * 2 + 3 * 1) / 8</p><p><strong>查找失败时的平均查找长度</strong></p><blockquote><p>ASL失败 = 每个链表上一直查找到空所需要的次数 / 表的长度</p></blockquote><p>ASL失败 = (4 + 1 + 1+ 3 + 1 + 1 + 2 + 2 + 1 + 2) / 10</p><h2 id="散列表">散列表</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051451626.png" /></p><p><strong>查找成功时的平均查找长度</strong></p><blockquote><p>ASL成功 = 从计算得到的位置往后查查到现在位置需要的次数 /待查找所有元素的个数</p></blockquote><p>ASL成功 = (1 + 2 + 1 + 1 + 1 + 3 + 3) / 7</p><p><strong>查找失败时的平均查找长度</strong></p><blockquote><p>ASL失败 = 表中从0~MOD-1中每个格子到下一个空格子需要的查找次数 /MOD的数（因为结果只有可能在0~MOD里面）</p></blockquote><p>ASL失败 = (3 + 2 + 1 + 2 + 1 + 5 + 4 ) / 7</p><h1 id="顺序查找">顺序查找</h1><p>查找方式为从头查到尾，找到待查找元素则为成功，找到尾部仍未找到则为失败，所以Ci（第i个元素的比较次数）取决于它在表中的位置</p><p>ASL成功 = <span class="math inline">\(\frac{1}{n}\cdot\frac{n(n+1)}{2}=\frac{n+1}{2}\)</span></p><p>ASL失败 = <span class="math inline">\(n\)</span></p><h1 id="折半查找">折半查找</h1><p>化为二叉排序树（判定树）</p><h1 id="二叉排序树">二叉排序树</h1><p>ASL成功 = <span class="math inline">\(\sum\limits_{i=1}^{n}P_i *level(k_i)\)</span>(Pi为查找k的概率，level(Ki)为k对应内部结点的层次)</p><p>ASL失败 = <span class="math inline">\(\sum\limits_{i=0}^{n}q_i*level(U_i)\)</span>(有n + 1个外部结点，用Ei(0 &lt;= i &lt;=n)表示，qi表示查找属于Ei中关键字的概率，level(Ui)表示Ei对应外部结点的层次)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051520395.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美丽的花花</title>
      <link href="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/"/>
      <url>/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>花花 &amp;&amp; 光秃秃树枝</p><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/1.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/2.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/3.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/4.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/5.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/6.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/7.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/8.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/9.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/10.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/11.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/12.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/13.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/14.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/15.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/16.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/17.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/18.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/19.jpg" class=""><img src="/2024/06/04/%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E8%8A%B1/20.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 风景 </category>
          
          <category> 花和光秃秃的树枝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美丽花花 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不一样的天空</title>
      <link href="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/"/>
      <url>/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="华科天空拍拍拍">华科天空拍拍拍</h1><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/1.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/2.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/3.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/4.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/5.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/6.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/7.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/8.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/9.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/10.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/11.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/12.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/13.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/14.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/15.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/16.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/17.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/18.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/19.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/20.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/21.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/22.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/23.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/24.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/25.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/26.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/27.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/28.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/29.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/30.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/31.jpg" class=""><img src="/2024/06/04/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%A4%A9%E7%A9%BA/32.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 风景 </category>
          
          <category> 天空 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天空拍拍拍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础公式</title>
      <link href="/2024/06/02/%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F/"/>
      <url>/2024/06/02/%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="微分">微分</h1><ol type="1"><li><span class="math inline">\((\tan x)&#39;=\sec ^2x\)</span></li><li><span class="math inline">\((\cos x)&#39;=-\csc ^2x\)</span></li><li><span class="math inline">\((\sec x)&#39;=\sec x\cdot\tanx\)</span></li><li><span class="math inline">\((\csc x)&#39;=-\csc x\cdot\cotx\)</span></li></ol><h1 id="积分">积分</h1><h1 id="泰勒展式">泰勒展式</h1>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-树和B+树</title>
      <link href="/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/"/>
      <url>/2024/05/28/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="b树">B树</h3><h4 id="b树的定义"><em>B树的定义</em>：</h4><p>一颗m阶B树是一颗平衡的m路搜索树</p><h4 id="b树的特性"><strong><em>B树的特性</em></strong>：</h4><ol type="1"><li><p>每个结点至少两个子女</p></li><li><p>每个非根节点包含的关键字个数n：<span class="math inline">\(\lceilm/2 \rceil - 1 \leq n \leq m-1\)</span>，</p><p>每个非根节点子树个数k：<span class="math inline">\(\lceil m/2 \rceil\leq k \leq m\)</span></p></li><li><p>根节点的关键字个数n：<span class="math inline">\(1 \leq n \leqm-1\)</span></p><p>根节点的子树个数k：<span class="math inline">\(2 \leq n \leqm\)</span></p></li><li><p>所有的非终端结点中包含下列信息数据<spanclass="math inline">\((n，A_0，K_1,A_1,K_2,A_2,…,K_n,A_n)\)</span></p><ul><li><span class="math inline">\(K_i是关键字，K_i &lt;K_{i+1}\)</span></li><li><spanclass="math inline">\(A_i\)</span>为指向子树根节点的指针，且指针<spanclass="math inline">\(A_{i-1}\)</span>所指子树中所有结点的关键字均小于<spanclass="math inline">\(K_i\)</span></li><li><spanclass="math inline">\(A_n\)</span>所指子树中所有结点的关键字均大于<spanclass="math inline">\(K_n\)</span></li></ul></li><li><p>叶子结点都在同一层</p></li><li><p>对于任一结点其子树高度相同</p></li><li><p>B树的m值比树高大很多，m的实用值一般在100-500</p></li></ol><h4 id="b树的查找"><em>B树的查找：</em></h4><p>待查找元素<span class="math inline">\(x_0\)</span>，如果：</p><ol type="1"><li><span class="math inline">\(K_i &lt; x &lt; K_{i+1}(1 \leq i&lt;n)\)</span>，准备查找<span class="math inline">\(A_i\)</span>页</li><li><span class="math inline">\(x &lt; K_1\)</span>，准备查找<spanclass="math inline">\(A_0\)</span>页</li><li><span class="math inline">\(x &gt; K_n\)</span>，准备查找<spanclass="math inline">\(A_n\)</span>页</li></ol><p>页内存储方式：顺序存储或者采用二叉排序树的形式</p><p>页内检索算法：顺序检索或者折半查找</p><h4id="b树的高度不包括叶子结点"><em>B树的高度（不包括叶子结点）：</em></h4><p>含n个关键字的m阶B树：</p><ul><li><p>最小高度：</p><p>让每个结点尽可能的满，每个结点有<spanclass="math inline">\(m-1\)</span>个关键字，<spanclass="math inline">\(m\)</span>个分叉，</p><p>则 <span class="math inline">\(n \leq(m-1)(1+m+m^2+m^3+...+m^{h-1})=m^h-1\)</span>，</p><p>所以 <span class="math inline">\(\color{red}h \geqlog_m(n+1)\)</span></p></li><li><p>最大高度：</p><p>让各层分支尽可能少，即根节点有两个分支，其他节点只有<spanclass="math inline">\(\lceil m/2\rceil\)</span>个分支</p><p>各层节点至少有：</p><p>第一层 1、第二层 2、第三层 <span class="math inline">\(2\lceilm/2\rceil\)</span>、第三层 $2m/2^2 $ <spanclass="math inline">\(......\)</span></p><p>第<span class="math inline">\(h\)</span>层 <spanclass="math inline">\(2\lceil m/2\rceil ^{h-2}\)</span>、第<spanclass="math inline">\(h+1\)</span>层（即叶子节点/失败结点） <spanclass="math inline">\(2\lceil m/2\rceil ^{h-1}\)</span></p><p>n个关键字的B树一定有<spanclass="math inline">\(n+1\)</span>个叶子结点，所以<spanclass="math inline">\(n+1\geq 2\lceil m/2\rceil^{h-1}\)</span>，</p><p>即<span class="math inline">\(\color{red}h \leq log_{\lceilm/2\rceil} \frac{n+1}{2}+1\)</span></p></li></ul><h4 id="b树的插入"><em>B树的插入：</em></h4><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405090936688.mp4" width="100%" height="100%" controls="controls"></video>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B-树和B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学上</title>
      <link href="/2024/05/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%8A/"/>
      <url>/2024/05/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合"><strong>集合</strong></h1><ul><li><p>常见集合：</p><p>N：正整数或自然数集合</p><p><span class="math inline">\(N_m\)</span>：<spanclass="math inline">\(1,2,...,m\)</span></p><p>Z：非负整数集合</p><p><span class="math inline">\(Z_m\)</span>：<spanclass="math inline">\(0,1,2,...,m-1\)</span></p><p>I：整数集合</p><p>P：素数集合</p><p>C：复数集合</p></li><li><p>寻常集：不包含自身作为元素</p><p>不寻常集：包含自身作为元素</p></li><li><p>基数：集合A中不同元素的个数，记作<spanclass="math inline">\(\#A\)</span></p></li><li><p>幂集：设有集合A，由A的所有子集组成的集合，称为集合A的幂集，记作<spanclass="math inline">\(2^A\)</span>，即<spanclass="math inline">\(2^A=\left\{S|S \subset A\right\}\)</span></p></li><li><p>设A是具有基数<span class="math inline">\(\#A\)</span>的有限集，则<spanclass="math inline">\(\#(2^A)=2^{\#A}\)</span></p></li><li><p>补集：集合A关于全集合U的相对补集称为A的绝对补集，记作<spanclass="math inline">\(A&#39;\)</span></p></li><li><p><span class="math inline">\(a\inA\)</span>表示a是集合A的一个元素，<span class="math inline">\(B \subsetA\)</span>​表示B是A的一个子集，它意味着B中的每一个元素也是集合A中的元素</p><ul><li>若<span class="math inline">\(A\in B,B\subset C\)</span>，则<spanclass="math inline">\(A\in C\)</span> <spanclass="math inline">\(\color{red}{（只有这一种组合是对的）}\)</span></li><li><span class="math inline">\(\color{red}{错错错:}\)</span><ul><li>若<span class="math inline">\(A\in B,B\subset C\)</span>，则<spanclass="math inline">\(A\subset C\)</span></li><li>若<span class="math inline">\(A\subset B,B\in C\)</span>，则<spanclass="math inline">\(A\in C\)</span></li><li>若<span class="math inline">\(A\subset B,B\in C\)</span>，则<spanclass="math inline">\(A\subset C\)</span></li></ul></li></ul></li><li><p>A与B的对称差：集合A、B，由属于A但不属于B以及属于B但不属于A的所有元素构成的集合，记作<spanclass="math inline">\(A \oplus B\)</span>，即<spanclass="math inline">\(A \oplus B = (A-B)\cup (B-A)\)</span></p></li><li><p>集合的运算定律</p><ul><li>同一律： <span class="math inline">\(A\cup \varnothing =A\)</span>，<span class="math inline">\(A \cap U=A\)</span></li><li>互补律：<span class="math inline">\(A \cup A&#39; =U\)</span>，<span class="math inline">\(A \cap A&#39; =\varnothing\)</span></li><li>对合律：<span class="math inline">\((A&#39;)&#39; = A\)</span></li><li>等幂律：<span class="math inline">\(A \cup A = A,A \cap A =A\)</span></li><li>零一律：<span class="math inline">\(A \cup U = U, A \cap \varnothing= \varnothing\)</span></li><li>吸收率：<span class="math inline">\(A \cup (A \cap B) = A, A \cap (A\cup B) = A\)</span></li><li>德摩根律：<span class="math inline">\((A \cup B)&#39; = A&#39; \capB&#39;, (A \cap B)&#39; = A&#39; \cup B&#39;\)</span></li></ul></li><li><p>对称差运算</p><ul><li><span class="math inline">\(A \oplus B = B \oplus A\)</span></li><li><span class="math inline">\((A \oplus B)\oplus C = A \oplus (B\oplus C)\)</span></li><li><span class="math inline">\(A \cap (B \oplus C) = (A \cap B)\oplus(A \cap C)\)</span></li><li><span class="math inline">\(A \oplus \varnothing =A, A\oplus U =A&#39;\)</span></li><li><span class="math inline">\(A \oplus A=\varnothing, A\oplusA&#39;=U\)</span></li><li><span class="math inline">\(A\oplus(A\oplus B)=B\)</span></li></ul></li><li><p>分划：设<span class="math inline">\(\pi= \left\{A_i\right\}_{i\inK}\)</span>是集合A的某些非空子集的集合，如果集合A的每个元素在且只在其中之一<spanclass="math inline">\(A_i\)</span>中，即如果</p><ol type="1"><li><p>当<span class="math inline">\(i \neq j\)</span>时，<spanclass="math inline">\(A_i \cap A_j = \varnothing\)</span></p></li><li><p><span class="math inline">\(\bigcup\limits_{i \in K}A_i =A\)</span></p><p>则称集合<spanclass="math inline">\(\pi\)</span>时集合A的一个分划</p></li></ol></li></ul><h1 id="关系"><strong>关系</strong></h1><h2 id="集合的笛卡尔积">集合的笛卡尔积</h2><ul><li><p>序偶：有序二元组</p></li><li><p>笛卡尔积：设<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>时、是任意集合，所有有序n元组<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>的集合，称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>的笛卡尔积，记作<spanclass="math inline">\(A_1 \times A_2 \times...\times A_n\)</span></p><p>即<span class="math inline">\(A_1 \times A_2 \times...\times A_n =\left\{(a_1,a_2,...,a_n)|a_i \in A_i\right\}\)</span></p></li><li><p><span class="math inline">\(A \times B \neq B \timesA\)</span></p><p><span class="math inline">\(A \times B = B \times A =\varnothing\)</span></p></li><li><p><span class="math inline">\(A \times (B \cup C) = (A \times B)\cup (A \times C)\)</span></p><p><strong>证明与笛卡尔积有关的定理利用序偶</strong></p></li></ul><h2 id="关系-1">关系</h2><ul><li><p>笛卡尔积<span class="math inline">\(A_1 \times A_2\times...\times A_n\)</span>的任何一个子集称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>上的n元关系</p></li><li><p>设<spanclass="math inline">\(\rho\)</span>是A到B的一个关系，定义域<spanclass="math inline">\(D_{\rho}\)</span>，值域<spanclass="math inline">\(R_{\rho}\)</span></p></li><li><p>逆关系<span class="math inline">\(\widetilde{\rho} =\left\{(b,a)|(a,b)\in \rho \right\}\)</span></p></li><li><p>若<spanclass="math inline">\(\rho\)</span>是由A到B的一个关系，且<spanclass="math inline">\((a,b)\in \rho\)</span>，则称a对b有关系<spanclass="math inline">\(\rho\)</span>，记作<spanclass="math inline">\(a\rho b\)</span>，</p><p>如果<span class="math inline">\((a,b)\notin\rho\)</span>，则记作<spanclass="math inline">\(a\rho&#39;b\)</span></p></li><li><p>集合A上的关系：由集合A到A自身的关系</p></li><li><p>普遍关系<span class="math inline">\(U_A\)</span>：若<spanclass="math inline">\(\rho = A^2\)</span>，则称<spanclass="math inline">\(\rho\)</span>为A上的普遍关系，即<spanclass="math inline">\(U_A = \left\{(a_i,a_j)|a_i,a_j \inA\right\}\)</span></p><p>恒等关系<span class="math inline">\(I_A\)</span>：<spanclass="math inline">\(I_A=\left\{(a_i,a_i)|a_i \inA\right\}\)</span></p></li><li><p>复合关系：<span class="math inline">\(\rho_1 \cdot \rho_2 =\left\{(a,c)|a\in A，c\in C,且\exists b\in B,s.t.(a\rho_1b,b\rho_2c)\right\}\)</span></p></li><li><p><span class="math inline">\((\rho_1 \cdot \rho_2)\cdot \rho_3 =\rho_1 \cdot (\rho_2 \cdot \rho_3)\)</span></p><p><strong>证明与关系有关的定理利用序偶</strong></p></li></ul><h2 id="关系的表示方法">关系的表示方法</h2><ul><li>关系矩阵<ul><li>设<span class="math inline">\(\rho_1\)</span>是A到B的关系，<spanclass="math inline">\(\rho_2\)</span>是B到C的关系，它们的关系矩阵分别为<spanclass="math inline">\(M_{\rho_1}、M_{\rho_2}\)</span>，则复合关系<spanclass="math inline">\(\rho_1 \cdot \rho_2\)</span>的关系矩阵<spanclass="math inline">\(M_{\rho_1 \rho_2}=M_{\rho_1} \cdotM_{\rho_2}\)</span></li><li><span class="math inline">\(M_{\rho ^n}=M_{\rho}^n\)</span></li></ul></li><li>关系图</li></ul><h2 id="集合a上关系的性质和闭包运算">集合A上关系的性质和闭包运算</h2><ul><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是自反的，否则是非自反的</p><p>若对于所有的<span class="math inline">\(a\in A\)</span>，有<spanclass="math inline">\(a\rho&#39;a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反自反的</p></li><li><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rhob\)</span>就有<span class="math inline">\(b\rho a\)</span>，则称<spanclass="math inline">\(\rho\)</span>是对称的，否则是非对称的</p><p>对于所有的<span class="math inline">\(a,b \inA\)</span>，若每当有<span class="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>，就必有<spanclass="math inline">\(a=b\)</span>，则称<spanclass="math inline">\(\rho\)</span>是反对称的，也可描述为对于所有的<spanclass="math inline">\(a,b \in A\)</span>，若<spanclass="math inline">\(a \neq b\)</span>，则<spanclass="math inline">\(a\rho b\)</span>和<spanclass="math inline">\(b\rho a\)</span>不能同时出现</p></li><li><p>对于所有的<span class="math inline">\(a,b,c \inA\)</span>，若每当有<span class="math inline">\(a\rho b和b\rhoc\)</span>就有<span class="math inline">\(a\rho c\)</span>，则称<spanclass="math inline">\(\rho\)</span>是可传递的，否则，<spanclass="math inline">\(\rho\)</span>是不可传递的</p></li></ul></li><li><p>A上关系的性质在关系矩阵上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>是自反的：主对角线上的元素全为1</li><li><spanclass="math inline">\(\rho\)</span>是对称的：关于主对角线对称</li><li><span class="math inline">\(\rho\)</span>是反对称的：对于<spanclass="math inline">\(i\neq j\)</span>，若<spanclass="math inline">\(r_{ij}=1\)</span>，则<spanclass="math inline">\(r_{ji}=0\)</span></li></ul></li><li><p>A上的关系的性质在关系图上的体现</p><ul><li><spanclass="math inline">\(\rho\)</span>​是自反的：每个结点引出一个单边环</li><li><spanclass="math inline">\(\rho\)</span>是反自反的：每个结点无单边环</li><li><span class="math inline">\(\rho\)</span>是对称的：对每一由结点<spanclass="math inline">\(a_i\)</span>指向结点<spanclass="math inline">\(a_j\)</span>的边，必有一相反的边</li><li><spanclass="math inline">\(\rho\)</span>是反对称的：任何两个不同的借点之间最多有一条边</li></ul></li><li><p>设<span class="math inline">\(\rho\)</span>是集合A上的关系</p><ul><li><span class="math inline">\(\rho\)</span>的自反闭包<spanclass="math inline">\(r(\rho)\)</span>：<spanclass="math inline">\(r(\rho)=\rho \cup I_A\)</span></li><li><span class="math inline">\(\rho\)</span>的对称闭包<spanclass="math inline">\(s(\rho)\)</span>：<spanclass="math inline">\(s(\rho)=\rho \cup \widetilde{\rho}\)</span></li><li><span class="math inline">\(\rho\)</span>的传递闭包<spanclass="math inline">\(t(\rho)\)</span>：<spanclass="math inline">\(t(\rho)=\bigcup_\limits{i=1}^\infty\rho^i\)</span>​（若<span class="math inline">\(\# A=n\)</span>，则<spanclass="math inline">\(t(\rho)=\bigcup _\limits{i=1}^n\rho^i\)</span>）</li></ul><p><strong><spanclass="math inline">\({\color{red}r(\rho)、s(\rho)、t(\rho)分别是集合A上包含\rho最小的自反关系、对称关系、可传递关系}\)</span></strong></p><p>(可以利用关系图得到传递闭包，只要能到达就有一条线连接)</p></li><li><p>设<span class="math inline">\(\rho_1\)</span>、<spanclass="math inline">\(\rho_2\)</span>是集合A上的关系，且<spanclass="math inline">\(\rho_1 \subset \rho_2\)</span>，则<spanclass="math inline">\(r(\rho_1) \subset r(\rho_2)\)</span>，<spanclass="math inline">\(s(\rho_1) \subset s(\rho_2)\)</span>，<spanclass="math inline">\(t(\rho_1) \subset t(\rho_2)\)</span></p></li></ul><h2 id="集合a上两类重要的关系">集合A上两类重要的关系</h2><h3 id="等价关系">等价关系</h3><p>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它使自反、对称且可传递的，则称<spanclass="math inline">\(\rho\)</span>为A上的等价关系</p><h4 id="等价类">等价类：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则A中等价于a的全体元素的集合，成为a所生成的等价类，用<spanclass="math inline">\([a]_{\rho}\)</span>表示，即<spanclass="math inline">\([a]_{\rho}=\left\{b|b\in A,a\rho b\right\}\)</span></p><p>性质：</p><ol type="1"><li>A中每一个元素生成的等价类非空</li><li>彼此等价的元素属于同一个等价类</li><li>彼此不等价的元素属于不同的等价类，且这些等价类之间没有公共元素</li></ol><h4 id="分划">分划：</h4><p>定义：设<spanclass="math inline">\(\rho\)</span>是集合A上的等价关系，则等价类的集合<spanclass="math inline">\(\left\{[a]_{\rho} |a\inA\right\}\)</span>构成A的一个分划</p><p>说明：每一个等价类就是一个分化块，因为A的每一元素的等价类（在<spanclass="math inline">\(\rho\)</span>下）是唯一的，所以分划也是唯一的，这种由等价关系<spanclass="math inline">\(\rho\)</span>的等价类所组成的A的分划，称为A上由<spanclass="math inline">\(\rho\)</span>所导出的等价分化，用<spanclass="math inline">\(\pi_{\rho}^A\)</span>​​表示</p><h4 id="商集">商集：</h4><p>等价类的集合<span class="math inline">\(\left\{[a]_{\rho}|a\inA\right\}\)</span>称为A关于<spanclass="math inline">\(\rho\)</span>的商集，记作<spanclass="math inline">\(A/\rho\)</span>，<spanclass="math inline">\(A/\rho\)</span>的基数称为<spanclass="math inline">\(\rho\)</span>的秩</p><p><spanclass="math inline">\(res_m(i)\)</span>表示用m除以i所得的余数</p><h4 id="细分">细分：</h4><p>如果<span class="math inline">\(I_2\)</span>的每一个分化块都是<spanclass="math inline">\(I_1\)</span>的某一个分化块的子集，则<spanclass="math inline">\(I_2\)</span>是<spanclass="math inline">\(I_1\)</span>的细分</p><h3 id="偏序">偏序</h3><p><strong>偏序</strong>定义：集合A上的关系<spanclass="math inline">\(\rho\)</span>，如果它是自反、反对称、可传递的，则称<spanclass="math inline">\(\rho\)</span>是A上的一个偏序关系，用<spanclass="math inline">\(\leq\)</span>表示；显然一个偏序的逆也是偏序，用<spanclass="math inline">\(\geq\)</span>表示。</p><p><strong>全序</strong>定义：一个集合A上的偏序，若对于所有的<spanclass="math inline">\(a,b\in A\)</span>，有<spanclass="math inline">\(a\leq b\)</span>或<span class="math inline">\(b\leq a\)</span>，则称它为A上的一个全序。<spanclass="math inline">\(\color{red}{集合A中任意两个元素都是可比的}\)</span></p><p><strong>良序</strong>定义：一个集合A上的偏序，若对于A的每一个非空子集<spanclass="math inline">\(S \subset A\)</span>，在S中存在一个元素<spanclass="math inline">\(a_s\)</span>（S中的最小的元素），使得对于所有<spanclass="math inline">\(s \in S\)</span>，有<spanclass="math inline">\(a_s \leq s\)</span>​，则称它为A上的一个良序。<spanclass="math inline">\(\color{red}{集合A中有最小元素}\)</span></p><p><strong>特点：</strong></p><ul><li>全序或者良序一定是偏序</li><li>偏序不一定是全序或者良序</li><li>一个偏序如果是良序则一定是全序</li></ul><h1 id="函数"><strong>函数</strong></h1><h2 id="函数-1">函数</h2><p><span class="math inline">\(A \timesB\)</span>的每一个子集都是由A到B的关系，其中一部分子集可以用来定义由A到B的函数，用<spanclass="math inline">\(B^A\)</span>表示这些函数的集合，即<spanclass="math inline">\(B^A=\left\{f|f:A\rightarrowB\right\}\)</span>，<spanclass="math inline">\(\color{red}{当A、B都是有限集}\)</span> <spanclass="math inline">\(\color{red}{的时候}\)</span>，<spanclass="math inline">\(\#A=m,\#B=n\)</span>，从A到B不同函数共有<spanclass="math inline">\(n^m\)</span>，即<spanclass="math inline">\(\#(B^A)=(\# B)^{\#A}\)</span></p><h2 id="三种特殊函数">三种特殊函数</h2><p>定义：</p><ul><li>内射：当<span class="math inline">\(a_i \neq a_j\)</span>时，有<spanclass="math inline">\(f(a_i) \neq f(a_j)\)</span>，也就是当<spanclass="math inline">\(f(a_i) = f(a_j)\)</span>时，有<spanclass="math inline">\(a_i=a_j\)</span>（集合A中的不同元素在B中有不同的像）</li><li>满射：B中每一个元素都是A中至少一个元素的像</li><li>双射：集合A和集合B的元素间一一对应</li></ul><p>特点：</p><p>​ 如果A、B都是有限集</p><ul><li><span class="math inline">\(\#A \leq\#B\)</span>时，f有可能时内射</li><li><span class="math inline">\(\#A\geq\#B\)</span>​时，f有可能是满射</li><li><span class="math inline">\(\#A=\#B\)</span>​时，f有可能是双射</li></ul><h2 id="函数的复合">函数的复合</h2><p>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow C\)</span>，那么：</p><ol type="1"><li>如果f和g都是内射，则<spanclass="math inline">\(gf\)</span>也是内射</li><li>如果f和g都是满射，则<spanclass="math inline">\(gf\)</span>也是满射</li><li>如果f和g都是双射，则<spanclass="math inline">\(gf\)</span>​​也是双射</li></ol><p>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow C\)</span>，那么：</p><ol type="1"><li>如果<span class="math inline">\(gf\)</span>是内射，则f是内射</li><li>如果<span class="math inline">\(gf\)</span>是满射，则g是满射</li><li>如果<spanclass="math inline">\(gf\)</span>是双射，则f是内射，g是满射</li></ol><h2 id="逆函数">逆函数</h2><ol type="1"><li>设函数<span class="math inline">\(f:A\rightarrowB\)</span>是一个双射，则逆函数<spanclass="math inline">\(f^{-1}\)</span>也是一个双射</li><li>设函数<span class="math inline">\(f:A\rightarrowB\)</span>是一个双射，则<spanclass="math inline">\((f^{-1})^{-1}=f\)</span></li><li>如果函数<span class="math inline">\(f:A\rightarrowB\)</span>是可逆的，则有<spanclass="math inline">\(f^{-1}f=I_A,ff^{-1}=I_B\)</span></li><li>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrow A\)</span>，当且仅当<spanclass="math inline">\(gf=I_A,fd=I_B\)</span>时，有<spanclass="math inline">\(g=f^{-1}\)</span></li><li>设有函数<span class="math inline">\(f:A\rightarrow B\)</span>和<spanclass="math inline">\(g:B\rightarrowA\)</span>，且f和g都是可逆的，则<spanclass="math inline">\((gf)^{-1}=f^{-1}g^{-1}\)</span></li></ol><h2 id="集合的基数">集合的基数</h2><h3 id="概念">概念</h3><p>概念：集合的基数即集合中不同元素的个数</p><p><strong>等势</strong>：设有集合A、B，如果存在双射函数<spanclass="math inline">\(f:A\rightarrowB\)</span>，则说A和B有相同的基数，或者说A和B等势，记作<spanclass="math inline">\(A\sim B\)</span></p><p>注：对于有限集来说，A和B有相同的基数指的是它们元素个数相同</p><p><strong>有限集</strong>：如果集合A与集合<spanclass="math inline">\(N_m=\left\{1,2,...,m\right\}\)</span>属于同一基数类，则称集合A是有限集。有限集的基数就是该集合中的元素个数。</p><p><strong>可数集</strong>：如果集合<span class="math inline">\(A\simN\)</span>，则称A为可数集。可数集的基数记作<spanclass="math inline">\(\aleph_0\)</span>。一个集合是可数集的<strong>充分必要条件</strong>是它全部元素可以排成一个无穷序列的形式。</p><p><strong>可计数集：</strong>有限集和可数集称为可计数集。</p><h3 id="性质">性质</h3><ol type="1"><li><p>可数集的无限子集仍是可数集</p></li><li><p>任一无限集A必包含一可数子集</p></li><li><p>设集A可数，集B有限，且<span class="math inline">\(A\capB=\varnothing\)</span>，则<span class="math inline">\(A\cupB\)</span>可数</p></li><li><p>若A、B都是可数集，<span class="math inline">\(A\capB=\varnothing\)</span>，则<span class="math inline">\(A\cupB\)</span>​可数</p></li><li><p>有限个可数集的并是可数集</p></li><li><p>可数个(互不相交的)可数集的并依旧是可数集</p></li><li><p>设有集合A，B，若A的子集<spanclass="math inline">\(A_1\)</span>和B的子集<spanclass="math inline">\(B_1\)</span>，使得<spanclass="math inline">\(A\sim B_1,B\sim A_1\)</span>，则<spanclass="math inline">\(A\sim B\)</span></p></li></ol><h1 id="图论"><strong>图论</strong></h1><h2 id="基本概念">基本概念</h2><h3 id="概念-1">概念</h3><ul><li><p>n阶图：有n个结点的图</p></li><li><p>(n, m)图：n个结点m条边</p><p>(n, 0)图：零图</p><p>(1, 0)图：平凡图</p></li><li><p>完全图：任意两个不同结点都相邻接的图叫完全图</p><p>补图：由G所有节点和为了使G变成完全图添加的边构成的图</p></li><li><p>d次正则图：所有节点都具有同一度d</p></li><li><p>子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p><p>真子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(V\)</span>, <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span> , 且 <spanclass="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\neq\)</span> <spanclass="math inline">\(E\)</span></p><p>生成子图：<span class="math inline">\(\widetilde{V}\)</span> <spanclass="math inline">\(=\)</span> <span class="math inline">\(V\)</span>, <span class="math inline">\(\widetilde{E}\)</span> <spanclass="math inline">\(\subset\)</span> <spanclass="math inline">\(E\)</span></p></li><li><p>图的同构：两个图存在边与边之间的双射关系</p></li><li><p>伪图：设 <span class="math inline">\(G = (V, E)\)</span> ,V是一个有限非空集合，E是V中任意元素的非有序对偶的多重集</p><ul><li>在E中允许出现相同元素的对偶</li><li>在E中无序对偶{<span class="math inline">\({Vi,Vj}\)</span>}可能出现r次</li></ul></li><li><p>多重图： 没有长度为1的环的伪图</p><p>简单图：没有自环且没有重数大于1的边</p></li><li><p>邻接（结点与结点，边与边）、关联（结点与边）、孤立点、孤立边</p></li></ul><h3 id="性质定理">性质定理</h3><ul><li>握手定理----在(n, m)图中，<spanclass="math inline">\(\sum\limits_{i=1}^{n}\)</span>deg(<spanclass="math inline">\(vi\)</span>)<spanclass="math inline">\(=2m\)</span>​;</li><li>n阶完全图<span class="math inline">\(Kn\)</span>中，<spanclass="math inline">\(m=\)</span><spanclass="math inline">\(\frac{1}{2}\)</span>n(n-1);</li><li>两个图同构的必要条件：<ol type="1"><li>它们有相同的结点数和相同的边数</li><li>对应结点的度数相同</li></ol></li></ul><h2 id="路">路</h2><h3 id="概念-2">概念</h3><ul><li>开路、真路、回路、环<ul><li>没有重复结点的开路是真路</li><li>没有重复结点的回路是环</li></ul></li><li>短程、距离</li></ul><h3 id="性质定理-1">性质定理</h3><ul><li>设G是具有结点集<spanclass="math inline">\(V={v_1,v_2,...,v_n}\)</span>的图，则对于任意两个相连接的结点<spanclass="math inline">\(v_i,v_j \in V (v_i \neqv_j)\)</span>，其短程是一条长度不大于n-1的真路</li></ul><h2 id="图的矩阵表示">图的矩阵表示</h2><p>设<span class="math inline">\(G = (V, E)\)</span>，其中 <spanclass="math inline">\(V = \left\{ v_1, v_2, ...,v_n\right\}\)</span></p><ul><li><p>邻接矩阵<span class="math inline">\(A = (a_{ij})\)</span></p><p><span class="math display">\[ a_{ij} =\left\{ \begin{aligned} 1&amp;&amp;{若\left\{ v_i, v_j \right\}} \in E \\ 0&amp; &amp;否则\end{aligned} \right. \]</span>​</p><ul><li>一个图的邻接矩阵是对角线元素均为0的0-1矩阵，反之，一个对角线全为0的0-1矩阵一定可以唯一地做一个图</li><li>如果两个图的邻接矩阵可以通过行列变换得到，那么这两个图同构</li><li>图G的邻接矩阵A的第i行（或第i列）出现1的个数就是节点<spanclass="math inline">\(v_i\)</span>​的度</li><li><span class="math inline">\(A^l (l = 1, 2, 3, ...)\)</span>的<spanclass="math inline">\((i, j)\)</span>项元素<spanclass="math inline">\(a_{ij}^{(l)}\)</span>是连接<spanclass="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>长度为l的路的总数</li></ul></li><li><p>关联矩阵<span class="math inline">\(I =(b_{ij})\)</span>是一个n<spanclass="math inline">\(\times\)</span>m矩阵</p><p><span class="math display">\[b_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若v_i和e_j是关联的 \\ 0&amp; &amp;否则  \end{aligned}\right.\]</span></p><ul><li>I中每一列都正好包含两个 1，并且任何两个列都是不相同的</li><li>第i行中的1的个数即为节点<spanclass="math inline">\(v_i\)</span>的度</li></ul></li><li><p>连接矩阵<span class="math inline">\(C = (c_{ij})\)</span></p><p><span class="math display">\[c_{ij} = \left\{ \begin{aligned} 1&amp;&amp;若从v_i到v_j存在一条路 \\ 0&amp; &amp;否则 \end{aligned}\right.\]</span>​</p><ul><li>当C中所有元素都为1时图是连通 的</li></ul></li></ul><h2 id="图的连通性">图的连通性</h2><h3 id="概念-3">概念</h3><ul><li><p>连通图：如果存在一条路连接<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>，则称结点<spanclass="math inline">\(v_i\)</span>与<spanclass="math inline">\(v_j\)</span>是连接的，若G中任意两个节点均是连接的，则称图G是连通的</p></li><li><p>割边：如果在图G中删去边<span class="math inline">\(\left\{v_i,v_j\right\}\)</span>后，图G的分图数增加，则称边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>是G的割边</p></li><li><p>割点：如果在图G中删去结点<spanclass="math inline">\(v_i\)</span>及与其相关联的边之后，图G的分图数增加，则称结点<spanclass="math inline">\(v_i\)</span>是G的割点</p></li><li><p>边割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有E的子集S，使得在图G中删去S中的所有边后，得到的子图G-S变成具有两个分图的不连通图，而删去了S的任一真子集后，得到的子图仍然是连通图，则称S是G的一个边割集</p></li><li><p>点割集：设图<span class="math inline">\(G = (V,E)\)</span>是一连通图，若有V的子集<spanclass="math inline">\(V_1\)</span>使得在图G中删除了<spanclass="math inline">\(V_1\)</span>中的所有结点之后，所得到的子图<spanclass="math inline">\(G - V_1\)</span>不连通或为平凡图，则称<spanclass="math inline">\(V_1\)</span>是G的一个点割集</p><p><strong>（割点是点割集的特例）</strong></p></li><li><p>断集：设<span class="math inline">\(G = (V,E)\)</span>是一连通图，<span class="math inline">\(V_1 \subsetV\)</span>, G中端点分别属于<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>的所有边的集合，则成为G的断集</p><p><strong>边割集是断集的特例</strong></p></li><li><p>关联集：设v是图<span class="math inline">\(G =(V,E)\)</span>的一个结点，与v相关联的所有边的集合，称为结点v的关联集，记作<spanclass="math inline">\(S(v)\)</span></p></li><li><p>点连通度：<span class="math inline">\(K(G) = min\left\{\\#V_i|V_i是G的点割集\right\}\)</span>，点连通度是为了使G成为一个非连通图需要删除的点的最少数目</p></li><li><p>边连通度：λ<span class="math inline">\((G) = min\left\{ \#S|S是G的断集\right\}\)</span>，边连通度是为了使G成为一个非连通图需要删去的边的最少数目</p></li></ul><h3 id="性质定理-2">性质定理</h3><ul><li>图G中，边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>为割边的充要条件是边<spanclass="math inline">\(\left\{v_i,v_j\right\}\)</span>不在G的任何环中出现</li><li>在图G中，结点v为割点的充要条件是存在两个结点u和w，使得连接u和w的所有路中都出现结点v</li><li>对于一个给定的图<span class="math inline">\(G = (V, E)\)</span>，如果能把结点集V分成两个互补的子集<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(V&#39;\)</span>，使得同一结点集中的任意两个结点之间，至少存在一条不包含另一个结点子集中的任何结点的路，那么G中的端点分别在<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_1&#39;\)</span>​中的边组成G的一个边割集</li><li>对于任意的图<span class="math inline">\(G = (V, E)\)</span>，有<spanclass="math inline">\(K(G) \leq \lambda(G)\leq  \delta(G)\)</span>（其中<spanclass="math inline">\(\delta(G)\)</span>是图G的最小度</li></ul><h2 id="欧拉图">欧拉图</h2><h3 id="概念-4">概念</h3><ul><li>欧拉回路：在图G中找到一个回路，它通过G的每条边一次且仅一次</li><li>欧拉路：具有欧拉回路的图</li><li>欧拉图：通过图G每条边一次且仅一次的开路</li></ul><h3 id="性质定理-3">性质定理</h3><ul><li>一个连通图G为欧拉图的充要条件是G的每一结点的度均为偶数</li><li>连通图G具有一条连接结点<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>的欧拉路的充要条件是，<spanclass="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>​是G中仅有的具有奇数度的结点</li><li>欧拉回路的边不可以重复但是结点可以重复，所以欧拉回路不一定是环路</li></ul><h2 id="哈密顿图">哈密顿图</h2><h3 id="概念-5">概念</h3><ul><li><p>哈密顿环：找到一个环它通过图G的每个结点一次且仅一次</p><p>哈密顿路：通过图G每个结点一次且仅一次的开路</p><p>哈密顿图：具有哈密顿环的图</p></li><li><p>闭图：设G是具有n个结点的图，若对于<spanclass="math inline">\(deg(u)+deg(v) \geqn\)</span>​的每一对结点u和v，均有u和v相邻接，则称图G是闭图</p></li><li><p>闭包：图G的闭包是一个与G有相同结点集的闭图，记作<spanclass="math inline">\(G_c\)</span>，使<span class="math inline">\(G\subset G_c\)</span>，且异于<spanclass="math inline">\(G_c\)</span>的任何图H，若<spanclass="math inline">\(G \subset H \subset G_c\)</span>，则G不是闭图</p><p><strong>图G的闭包是包含图G的最小闭图</strong></p></li></ul><h3 id="性质定理-4">性质定理</h3><ul><li>图G的闭包是唯一的</li><li>每个哈密顿图都一定是连通的</li><li>若图<span class="math inline">\(G =(V,E)\)</span>是哈密顿图，则对于V的任何一个非空子集S，有<spanclass="math inline">\(W(G-S)\leq\#S\)</span>，这里<spanclass="math inline">\(W(G-S)\)</span>表示G - S中分图的个数</li><li>设G是具有n个结点的图，若有结点u和v不相邻接，且<spanclass="math inline">\(deg(u) + deg(v) \geq n\)</span>，则当且仅当图<spanclass="math inline">\(G+\left\{u,v\right\}\)</span>是哈密顿图时，图G时哈密顿图</li><li>设有图G当且仅当<spanclass="math inline">\(G_c\)</span>​是哈密顿图时，图G是哈密顿图</li><li>若图G的闭包<span class="math inline">\(G_c = K_n\)</span>，且<spanclass="math inline">\(n \geq 3\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#G \geq3\)</span>，若V中任意两个不相邻的结点u和v，均有<spanclass="math inline">\(deg(u) + deg(v) \geqn\)</span>，则G是哈密顿图</li><li>设图<span class="math inline">\(G = (V, E)\)</span>，<spanclass="math inline">\(\#V \geq 3\)</span>，若对于任意的<spanclass="math inline">\(v \in V\)</span>，均有<spanclass="math inline">\(deg(v) \geq\frac{n}{2}\)</span>，则G是哈密顿图</li></ul><h2 id="树">树</h2><h3 id="概念-6">概念</h3><ul><li><p>树：不包含环的连通图</p><p>树林：不包含环的图</p><p>树叶：度为1的结点</p></li><li><p>生成树：若连通图G的生成子图T是一棵树，T是G的生成树</p><p>最小生成树：在所有生成树中有最小权值</p></li><li><p>若G是一<spanclass="math inline">\((n,m)\)</span>连通图，G的生成树<spanclass="math inline">\(T_G\)</span>是一<spanclass="math inline">\((n,n-1)\)</span>图</p><p>环秩：在得到<spanclass="math inline">\(T_G\)</span>之前需要删除的边的总数为<spanclass="math inline">\(m-(n-1)\)</span>，该数为环秩，环秩是为了“弄破”G的所有环而必须由G中删去的边的最小数目</p><p>弦：被删去的每一条边</p><p>枝：在生成树<span class="math inline">\(T_G\)</span>中的边</p></li></ul><h1 id="性质定理-5">性质定理</h1><ul><li><p>在<span class="math inline">\((n,m)\)</span>树中，<spanclass="math inline">\(m = n - 1\)</span></p></li><li><p>具有两个或更多个结点的树至少有两片树叶</p></li><li><p>两个节点之间由唯一的真路连接的图就是树</p><p><span class="math inline">\(m=n-1\)</span>的连通图是树</p><p><span class="math inline">\(m=n-1\)</span>​且无环的图是树</p></li></ul><h2 id="有向树">有向树</h2><h3 id="概念-7">概念</h3><ul><li><p>有向树：一个不包含环的有向图G，若它只有一个结点<spanclass="math inline">\(v_0\)</span>入度为0，而所有其它结点入度为1</p></li><li><p>根：节点<span class="math inline">\(v_0\)</span></p><p>树叶或终点：出度为0的结点</p><p>级：从<span class="math inline">\(v_0\)</span>到结点<spanclass="math inline">\(v_i\)</span>的距离</p></li><li><p>m元树：在一有向树中，若每一个结点的出度都小于或等于m</p><p>完全m元树：若每个结点的出度等于m或0</p></li><li><p>外部结点：树叶结点</p><p>内部结点：分支结点</p></li><li><p>外部路径长度：根到所有外部结点的距离和</p><p>内部路径长度：根到所有内部结点的距离和</p><p>树的路径长度：根到所有结点的距离和</p></li><li><p>有序树：规定了每一级上结点的次序，一般规定同一级结点的次序为从左到右</p></li><li><p>前缀码：在一个序列的集合中，如果没有一个序列是另一个序列的前缀，则称该序列的集合为前缀码</p></li><li><p>最优树：一颗带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树，如果在所有带权<spanclass="math inline">\(W_1,W_2,...,W_t\)</span>的二元树中具有最小的权，则称为最优树</p></li></ul><h3 id="性质定理-6">性质定理</h3><ul><li>一颗二元树第i级的最大结点数是<spanclass="math inline">\(2^i\)</span>，高度为h的二元树的最大结点数为<spanclass="math inline">\(2^{h+1}-1\)</span>​</li><li>设T为一颗完全二元树（T不为孤立结点）有r个内部结点，内部路径长度为I，外部路径长度为E，则<spanclass="math inline">\(E=I+2r\)</span></li><li>设T为一颗二元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，<spanclass="math inline">\(n_2\)</span>个出度为2的结点，则<spanclass="math inline">\(n_2=n_0-1\)</span></li><li>设T是一颗完全二元树，有n个结点，<spanclass="math inline">\(n_0\)</span>个叶节点，则<spanclass="math inline">\(n=2n_0-1\)</span></li><li>设T是一颗完全m元树，有<spanclass="math inline">\(n_0\)</span>个叶节点，t个分支结点，则<spanclass="math inline">\((m-1)t=n_0-1\)</span></li></ul><h2 id="二部图">二部图</h2><h3 id="概念-8">概念</h3><ul><li><p>二部图：若一个图G的结点集V能分成两个子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>使得<span class="math inline">\(V_1\cup V_2=V\)</span>,<span class="math inline">\(V_1 \cap V_2 =\varnothing\)</span>，使得G的每一条边<spanclass="math inline">\(\left\{V_i,V_j\right\}\)</span>的端点<spanclass="math inline">\(v_i \in V1, v_j \inV_2\)</span>，则称图G是一个二部图</p><p>完全二部图：如果<spanclass="math inline">\(V_1\)</span>的每一个结点和<spanclass="math inline">\(V_2\)</span>的每一个结点想邻接，则G为完全二部图</p></li><li><p>匹配：设G是具有互补结点子集<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>的二部图，其中<spanclass="math inline">\(V_1=\left\{v_1,v_2,...,v_q\right\}\)</span>，<spanclass="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配是G的一个子图，它由q条边<spanclass="math inline">\(\left\{v_1,v_1&#39;\right\},\left\{v_2,v_2&#39;\right\},...,\left\{v_q,v_q&#39;\right\}\)</span>组成，其中<spanclass="math inline">\(v_1&#39;,v_2&#39;,...v_q&#39;\)</span>是<spanclass="math inline">\(V_2\)</span>中q个不同的元素</p></li></ul><h3 id="性质定理-7">性质定理</h3><ul><li>图G为二部图的充要条件是至少有两个节点，它的所有回路均为偶数长</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>必要条件</strong>是<spanclass="math inline">\(\# V_2 \geq \#V_1\)</span></li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充要条件</strong>是<spanclass="math inline">\(V_1\)</span>中每k个结点至少和<spanclass="math inline">\(V_2\)</span>​中k个结点相邻接</li><li>二部图存在<span class="math inline">\(V_1\)</span>对<spanclass="math inline">\(V_2\)</span>的匹配的<strong>充分条件</strong>是，存在某一整数<spanclass="math inline">\(t&gt;0\)</span>使<ol type="1"><li>对<spanclass="math inline">\(V_1\)</span>中每个结点，至少有t条边与其相关联</li><li>对<spanclass="math inline">\(V_2\)</span>中每个结点，至多有t条边与其相关联</li></ol></li></ul><h2 id="平面图">平面图</h2><h3 id="概念-9">概念</h3><ul><li>平面图：能画于平面上而无任何交叉</li></ul><h3 id="性质定理-8">性质定理</h3><ul><li>平面图的欧拉公式：设G是一连通的平面图，则有<spanclass="math inline">\(n-m+k=2\)</span>这里的n、m、k分别是图G的结点数、边数、面数（包括无限面）</li><li>有两条或者更多条边的任何连通的平面图G中,有<spanclass="math inline">\(m \leq 3n-6\)</span></li><li><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051141374.png"alt="image-20240505114109639" /><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405051243937.png"alt="image-20240505124328184" /></li></ul><h2 id="有向图">有向图</h2><h3 id="概念-10">概念</h3><ul><li><p>弱连通：看作无向图时是连通的</p><p>单向连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>中至少有一个由另一个出发是可达的</p><p>强连通：任何两个结点<span class="math inline">\(v_i\)</span>和<spanclass="math inline">\(v_j\)</span>都是相互可达的</p><p><strong>强连通的有向图是单向连通的，单向连通的有向图是弱连通的</strong></p></li><li><p>强分图、单向分图、弱分图分别是G的极大连通子图、极大单向连通子图、极大弱连通子图</p></li></ul><h3 id="性质定理-9">性质定理</h3><ul><li><p>一个连通的有向图具有欧拉回路的充要条件是，G的每一个结点的入度和出度相等</p><p>一个连通的有向图具有欧拉路的充要条件是，除了两个结点外，G的每一个结点的入度和出度相等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>级数</title>
      <link href="/2024/05/27/%E7%BA%A7%E6%95%B0/"/>
      <url>/2024/05/27/%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数项级数">数项级数</h1><h2 id="概念">概念</h2><p><strong>数项级数：</strong> 给定一列实数<spanclass="math inline">\(a_1,a_2,...,a_n\)</span>，称<spanclass="math inline">\(a_1+a_2+...+a_n+...\)</span>为一个数项级数，简称级数</p><p><strong>部分和：</strong>称<spanclass="math inline">\(S_n=\sum\limits_{k=1}^{k=n}a_k\)</span>为级数的部分和</p><p><strong>级数的和：</strong> <spanclass="math inline">\(S=\lim\limits_{n \to\infty}S_n\)</span>，s是级数的和，<spanclass="math inline">\(S=\sum\limits_{n=1}^{\infty}a_n\)</span></p><p><strong>余项：</strong> <spanclass="math inline">\(R_n=S-S_n=\sum\limits_{k=n+1}^{\infty}a_k\)</span></p><h3 id="敛散性的定义">敛散性的定义</h3><p><spanclass="math inline">\(\color{red}{改变级数的有限项，不影响其敛散性}\)</span></p><ol type="1"><li>当S有限的时候，级数收敛</li><li>若级数收敛，则<span class="math inline">\(\lim\limits_{n \to\infty}a_n=0\)</span><ul><li>只要级数收敛，则通项趋于零；通项不趋于零时，级数必发散 <spanclass="math inline">\((eg:\sum a_n收敛\Rightarrow\sum\limits_{n=1}^{\infty}\frac{1}{1+|a_n|}发散)\)</span></li><li>通项趋于零的级数不一定都收敛 <span class="math inline">\((eg:\,\sum\limits_{n=1}^\infty  \frac{1}{n_p})\)</span></li><li>发散的级数通项不一定不趋于零<spanclass="math inline">\((eg:\sum\limits_{n=1}^{\infty}\frac{1}{n})\)</span>​</li></ul></li><li><span class="math inline">\(\sum a_n,\sum b_n\)</span>收敛<spanclass="math inline">\(\Rightarrow\)</span><spanclass="math inline">\(\sum (a_n +b_n)\)</span>收敛</li><li><span class="math inline">\(\sum a_n\)</span>收敛，<spanclass="math inline">\(\sum b_n\)</span>发散<spanclass="math inline">\(\Rightarrow\)</span><spanclass="math inline">\(\sum(a_n+b_n)\)</span>发散</li></ol><h3 id="常见级数">常见级数</h3><ul><li>几何级数：<span class="math inline">\(\sum\limits_{n=0}^{\infty}r^n= 1+r+r^2+...\)</span><ol type="1"><li><span class="math inline">\(\left|r \right| &lt;1\)</span>，收敛，且和为<spanclass="math inline">\(\frac{1}{1-r}\)</span></li><li><span class="math inline">\(|r|\geq1\)</span>，发散</li></ol></li><li>p-级数：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}\frac{1}{n^p}=1+\frac{1}{2^p}+\frac{1}{3^p}+...\)</span>​<ol type="1"><li><span class="math inline">\(p&gt;1\)</span>，收敛</li><li><span class="math inline">\(p\leq1\)</span>，发散</li></ol></li><li>调和级数：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}\frac{1}{n}=1+\frac{1}{2}+\frac{1}{3}+...\)</span>​<ol type="1"><li>发散</li></ol></li></ul><h2 id="正项级数">正项级数</h2><p>形式：<span class="math inline">\(a_n \geq 0\)</span>​</p><h3 id="判别法">判别法</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405272227749.jpg" /></p><ol type="1"><li><p><spanclass="math inline">\(A_n=\sum\limits_{k=1}^{n}a_k\)</span>随n单调增加，因此<spanclass="math inline">\(\sum a_n收敛\Leftrightarrow\left\{A_n\right\}极限存在\Leftrightarrow\left\{A_n\right\}有界\)</span>​</p></li><li><p>一般形式的<strong>比较判别法</strong></p><p>若从某项起有<span class="math inline">\(a_n\leq b_n\)</span></p><ul><li><p>当<span class="math inline">\(\sum b_n\)</span>收敛时，<spanclass="math inline">\(\sum a_n\)</span>收敛</p></li><li><p>当<span class="math inline">\(\sum a_n\)</span>发散时，<spanclass="math inline">\(\sum b_n\)</span>发散</p></li></ul></li><li><p>极限形式的<strong>比较判别法</strong></p><p>若<span class="math inline">\(b_n\neq 0,\lim\limits_{n\to\infty}a_n/b_n=l\)</span></p><ul><li><p><span class="math inline">\(0&lt;l&lt;+\infty\)</span>时，<spanclass="math inline">\(\sum a_n与\sum b_n\)</span>敛散性相同</p></li><li><p><span class="math inline">\(l=0\)</span>时，<spanclass="math inline">\(\sum b_n收敛，\sum a_n收敛\)</span></p></li><li><p><span class="math inline">\(l=+\infty\)</span>时，<spanclass="math inline">\(\sum b_n发散，\sum a_n发散\)</span>​</p></li></ul></li><li><p><strong>比值判别法</strong> --适用于连乘</p><p>若<spanclass="math inline">\(\lim\limits_{n\to\infty}\frac{a_{n+1}}{a_n}=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(l&lt;1\)</span>时，收敛</li><li><span class="math inline">\(l&gt;1\)</span>时，发散</li></ul></li><li><p><strong>根值判别法</strong> --适用于n次幂</p><p>若<spanclass="math inline">\(\lim\limits_{n\to\infty}\sqrt[n]{a_n}=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(l&lt;1\)</span>时，收敛</li><li><span class="math inline">\(l&gt;1\)</span>​时，发散</li></ul></li><li><p><strong>积分判别法</strong></p><p>设<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\([1,+\infty)\)</span>上非负且单调减，<spanclass="math inline">\(a_n=f(n)\)</span> <spanclass="math inline">\((n=1,2,3,...)\)</span>，则<spanclass="math inline">\(\sum a_n\)</span>与<spanclass="math inline">\(\int_1^{+\infty}f(x)dx\)</span>敛散性相同</p></li><li><p><strong>比阶判别法</strong></p><p>设<span class="math inline">\(\sum a_n\)</span>是一正项级数，<spanclass="math inline">\(\lim n^pa_n=l\)</span>，则级数<spanclass="math inline">\(\sum a_n\)</span></p><ul><li><span class="math inline">\(p&gt;1且0\leql&lt;+\infty\)</span>时，收敛</li><li><span class="math inline">\(p\leq 1且0&lt;l\leq+\infty\)</span>时，发散</li></ul></li></ol><h2 id="变号级数">变号级数</h2><p>形式：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}(-1)^{n-1}a_n，其中a_n&gt;0\)</span></p><h3 id="判别法-1">判别法</h3><p>Leibniz判别法：若<spanclass="math inline">\(\left\{a_n\right\}\)</span><strong>单调减</strong>且收敛于零，则级数收敛，在完全单调减的条件下，其和<spanclass="math inline">\(S\leq a_1\)</span>，余项<spanclass="math inline">\(R_n\)</span>满足<spanclass="math inline">\(|R_n|\leq a_{n+1}\)</span></p><h3 id="绝对收敛与相对收敛">绝对收敛与相对收敛</h3><p>绝对收敛：<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}|a_n|收敛\)</span></p><p>条件收敛：<spanclass="math inline">\(\sum_\limits{n=1}^{\infty}a_n\)</span>收敛，但<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}|a_n|\)</span>发散</p><h1 id="函数项级数">函数项级数</h1><h2 id="概念-1">概念</h2><p><strong>函数项级数</strong>：定义域<em>I</em>上的一列函数<spanclass="math inline">\(u_n(x)\)</span>，称<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}u_n(x)=u_1(x)+u_2(x)+...+u_n(x)+...\)</span>为<em>I</em>上的一个函数项级数</p><p><strong>收敛点</strong>：<span class="math inline">\(x_0\inI\)</span>，数项级数<spanclass="math inline">\(\sum\limits_{n=1}^{\infty}u_n(x_0)\)</span>收敛，则称<spanclass="math inline">\(x_0\)</span>为级数的收敛点</p><p><strong>收敛域</strong>：全体收敛点构成的集合B为级数的收敛域</p><p><strong>和函数</strong>：对每一个<span class="math inline">\(x\inB\)</span>，以<spanclass="math inline">\(S(x)\)</span>记级数的和，是定义于收敛域B上的函数</p><p><strong>部分和</strong>：<spanclass="math inline">\(S_n(x)=\sum\limits_{k=1}^{n}u_k(x)\)</span>是级数的部分和，定义于<em>I</em>上的函数</p><p><strong>余项</strong>：<spanclass="math inline">\(R_n(x)=S(x)-S_n(x)=\sum\limits_{k=n+1}^{\infty}u_k(x)\)</span>，仅在集合B上有定义</p><h2 id="一致收敛">一致收敛</h2><p>设级数在点集A上收敛，若<span class="math inline">\(\forall\varepsilon&gt;0,\exist N&gt;0,\forall n\geq N,\forall x\inA:|R_n(x)|&lt;\varepsilon\)</span>，则说级数在A上一致连续</p><h2 id="weierstrass判别法">Weierstrass判别法</h2><p>若存在一个收敛的正项级数<span class="math inline">\(\sumb_n\)</span>，使得<span class="math inline">\(|u_n(x)|\leqb_n\)</span>，则级数在A上绝对收敛且一致收敛</p><h2 id="和函数的分析性质">和函数的分析性质</h2><p>在一致收敛条件下，有：</p><ol type="1"><li>“逐项求导”：<spanclass="math inline">\((\sum\limits_{n=1}^{\infty}u_n(x))&#39;=\sum\limits_{n=1}^{\infty}u_n&#39;(x)\)</span></li><li>“逐项积分”：<spanclass="math inline">\(\int_{\alpha}^{\beta}\sum\limits_{n=1}^{\infty}u_n(x)dx=\sum\limits_{n=1}^{\infty}\int_{\alpha}^{\beta}u_n(x)dx\)</span></li></ol><h1 id="幂函数">幂函数</h1><h2 id="概念-2">概念</h2><p><strong>幂级数</strong>：</p><ol type="1"><li><p><spanclass="math inline">\(\sum\limits_{n=0}^{\infty}a_nx^n=a_0+a_1x+...+a_nx^n+...\)</span></p></li><li><p><spanclass="math inline">\(\sum\limits_{n=0}^{\infty}a_n(x-x_0)^n=a_0+a_1(x-x_0)+...+a_n(x-x_0)^n+...\)</span></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无穷级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静电场</title>
      <link href="/2024/05/24/%E9%9D%99%E7%94%B5%E5%9C%BA/"/>
      <url>/2024/05/24/%E9%9D%99%E7%94%B5%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电荷和库仑定律">电荷和库仑定律</h1><p>电子e：<span class="math inline">\(1.602 \times10^{-19}C\)</span></p><p>库仑定律：<span class="math inline">\(F=k\frac{q_1q_2}{r^2}\vec{e_r}\)</span>，其中<spanclass="math inline">\(k=\frac{1}{4\pi \varepsilon_0}=9\times10^9\)</span></p><h1 id="静电场与电场强度">静电场与电场强度</h1><h2 id="概念">概念</h2><p>电场强度：<spanclass="math inline">\(E=\frac{F}{q_0}\)</span>，单位：<spanclass="math inline">\(N/C或V/m\)</span>​</p><p>点电荷：<span class="math inline">\(E=\frac{q}{4\pi\varepsilon_0r^2}\vec{e_r}\)</span></p><p>线电荷密度：<span class="math inline">\(\lambda\)</span>面电荷密度：<span class="math inline">\(\sigma\)</span>体电荷密度：<span class="math inline">\(\rho\)</span></p><p><span class="math inline">\(\color{red}{(\lambda = \sigmady)}\)</span></p><h2 id="各特殊模型产生的场强">各特殊模型产生的场强</h2><ol type="1"><li><p>电偶极子</p><p>电偶极子：两相隔一定距离的等量异号点电荷</p><p><spanclass="math inline">\(\vec{l}\)</span>：负电荷到正电荷的矢量线段</p><p>电偶极矩：<span class="math inline">\(\vec{p}=q\vec{l}\)</span></p><p><span class="math inline">\(E=-\frac{ql}{4\pi \varepsilon_0 (r^2 +l^2/4)^{\frac{3}{2}}}\)</span>，若<span class="math inline">\(r\ggl\)</span>，<strong><span class="math inline">\(E=-\frac{ql}{4\pi\varepsilon_0r^3}\)</span>​</strong></p></li><li><p>均匀带电直线</p><p>无限长：<spanclass="math inline">\(E=\frac{\lambda}{2\pi\varepsilon_0x}\)</span>​</p></li><li><p>均匀带电平面</p><p>无限大：<spanclass="math inline">\(E=\frac{\sigma}{2\varepsilon_0}\)</span></p></li><li><p>均匀带电圆环</p><p>沿轴线：<spanclass="math inline">\(E=\frac{xQ}{4\pi\varepsilon_0(x^2+R^2)^{\frac{3}{2}}}\)</span>，若<span class="math inline">\(x\gg R\)</span>：<spanclass="math inline">\(E=\frac{Q}{4\pi\varepsilon_0x^2}\)</span></p></li><li><p>均匀带电圆盘</p><p>沿轴线：<spanclass="math inline">\(E=\frac{\sigma}{2\varepsilon_0}(1-\frac{x}{\sqrt{R^2+x^2}})\)</span></p><ul><li>当<span class="math inline">\(x\llR\)</span>，圆盘可视为无限大的平面，<spanclass="math inline">\(E=\frac{\sigma}{2\varepsilon_0}\)</span></li><li>当<span class="math inline">\(x\ggR\)</span>，圆盘可视为点电荷，<spanclass="math inline">\(E=\frac{q}{4\pi \varepsilon_0x^2}\)</span>（q为圆盘的总带电量<span class="math inline">\(q=\sigma \piR^2\)</span></li></ul></li><li><p>均匀带电球面</p><p>当<span class="math inline">\(x&gt;R\)</span>时，<spanclass="math inline">\(E=\frac{Q}{4\pi\varepsilon_0 x^2}\)</span></p><p>当<span class="math inline">\(x&lt;R\)</span>时，<spanclass="math inline">\(E=0\)</span></p></li></ol><h1 id="高斯定理">高斯定理</h1><p><span class="math inline">\(\Phi_e=\oint_S\vec{E}\cdotd\vec{S}=\frac{1}{\varepsilon_0}\sum\limits_{S_{\text{内}}}q_i\)</span>​</p><p>----揭示了静电场是有源场</p><p>注意：</p><ol type="1"><li><spanclass="math inline">\(\Phi_E只取决于S面包围的电荷，S面外的电荷对\Phi_E无贡献\)</span></li><li><spanclass="math inline">\(\vec{E}\)</span>是所取封闭面S（高斯面）上的场强，它是由全部电荷<spanclass="math inline">\(\color{red}{S内外}\)</span>​共同产生的合场强</li></ol><h2 id="高斯面的选取">高斯面的选取</h2><p>高斯面（封闭面）应该选在场强相等的封闭曲面上，如果场强相等的曲面不封闭，则应该添加与场强方向垂直的面共同形成封闭曲面</p><ol type="1"><li>球对称：选与带电体同心的球面</li><li>轴对称：选与带电体同轴的圆柱面</li><li>面对称：选轴与带电面垂直，两底与带电面等距平行的圆柱面</li></ol><h1 id="环路定理">环路定理</h1><p>----- 揭示了静电场的无旋性</p><p><span class="math inline">\(\oint_L\vec{E}\cdotd\vec{l}=0\)</span></p><p>静电场做功：<spanclass="math inline">\(\frac{A}{q_0}=\frac{q}{4\pi\varepsilon(\frac{1}{r_a}-\frac{1}{r_b})}(r_a,r_b表示场源电荷到被移动电荷的起点和终点距离)\)</span></p><h1 id="电势差和电势">电势差和电势</h1><h2 id="概念-1">概念</h2><p>点电荷<spanclass="math inline">\(q_0\)</span>从P到Q，电场力做功为：<spanclass="math inline">\(A_{PQ}=q_0\int_{P}^Q\vec{E}\cdotd\vec{l}\)</span></p><p><span class="math inline">\(W_P,W_Q\)</span>分别是<spanclass="math inline">\(q_0\)</span>在P点和Q点的静电势能，<spanclass="math inline">\(W_P-W_Q=q_0\int_P^Q\vec{E}\cdotd\vec{l}\)</span></p><p>P、Q两点的电势差为<span class="math inline">\(V_P-V_Q=\int_{P}^Q\vec{E}\cdot d \vec{l}\)</span></p><h2 id="电势零点的选取">电势零点的选取</h2><ol type="1"><li>场源电荷分布在有限空间，选取无穷远处为电势零点</li><li>电荷分布在无限空间，选有限远点为电势零点</li></ol><h2 id="电势的计算">电势的计算</h2><ol type="1"><li><p>定义法求电势</p><p><span class="math inline">\(V_P=\int_{P}^{V=0处}\vec{E}\cdotd\vec{l}\)</span></p></li><li><p>电势叠加法求电势</p><p>点电荷系场中的电势：<spanclass="math inline">\(V_P=\sum\limits_{i}\frac{q_i}{4\pi\varepsilon_0r_i}\)</span></p><p>任意带电体场中的电势：<spanclass="math inline">\(V_P=\int_q\frac{dq}{4\pi\varepsilon_0r}\)</span></p></li></ol><h2 id="电势梯度">电势梯度</h2><p>电视梯度是电势的最大空间变化率</p><p><spanclass="math inline">\(\vec{E}=-grad\,V=-(\frac{\partial}{\partialx}\vec{i}+\frac{\partial}{\partial y}\vec{j} +\frac{\partial}{\partialz}\vec{k})V\)</span></p><h1 id="静电场中的导体">静电场中的导体</h1><blockquote><p>静电感应<span class="math inline">\(\rightarrow\)</span>静电平衡<spanclass="math inline">\(\rightarrow\)</span>等势体</p></blockquote><h2 id="静电平衡的条件">静电平衡的条件</h2><p>静电平衡：导体表面和内部都没有电荷的定向移动</p><ol type="1"><li>导体内部 <span class="math inline">\(\vec{E}=0\)</span></li><li>外表面 <span class="math inline">\(\vec{E}\bot表面\)</span></li></ol><p>推论：导体是等势体，导体表面是等势面</p><p>静电平衡时导体上的电荷分布：</p><ol type="1"><li><p>导体内部没有静电荷，电荷分布在外表面上</p></li><li><p>导体内有空腔，腔内无其他带电体，电荷全分布在导体外表面</p></li><li><p>导体表面附近<spanclass="math inline">\(\vec{E}\)</span>的大小与该处的面电荷密度<spanclass="math inline">\(\sigma\)</span>成正比：<spanclass="math inline">\(\vec{E} =\frac{\sigma}{\varepsilon_0}\)</span></p></li></ol><p><spanclass="math inline">\(\color{red}{\vec{E}}是导体表面电荷和外部电荷的合场强\)</span>​</p><ol start="4" type="1"><li>孤立导体表面各处的面电荷密度<spanclass="math inline">\(\sigma\)</span>与各处曲率半径R成反比，即<spanclass="math inline">\(\sigma \propto \frac{1}{R}\)</span></li></ol><p>求解静电平衡时的电荷分布：</p><ol type="1"><li>取两板之间的高斯柱面，得两板电荷之和为0</li><li>导体内任一点电场为0</li></ol><h2 id="静电屏蔽">静电屏蔽</h2><ol type="1"><li><p>腔内无带电体</p><ul><li>内表面无电荷</li><li>腔内<span class="math inline">\(\vec{E} = 0\)</span></li></ul></li><li><p>腔内有带电体</p><ul><li>内表面电荷和腔内电荷等值异号</li><li>外表面电荷与腔内电荷等值同号</li></ul><p><spanclass="math inline">\(\color{red}{外表面电荷分布和曲率有关和腔内电荷位置无关}\)</span></p></li></ol><h1 id="静电场中的电介质">静电场中的电介质</h1><blockquote><p>电介质是绝缘体，不导电，在外电场<spanclass="math inline">\(\vec{E}\neq 0\)</span></p></blockquote><h2 id="电介质分子的分类">电介质分子的分类</h2><ol type="1"><li>无极分子：在无外场作用下，整个分子无电矩</li><li>有极分子：在无外场作用下，整个分子存在固有电矩</li></ol><h2 id="电极化现象">电极化现象</h2><p>宏观：电介质表面出现电荷</p><p>端面上束缚电荷越多，电极化程度越强</p><ol type="1"><li><p>有极分子</p><p>取向极化：<spanclass="math inline">\(\vec{E}=0,\sum\vec{p}=0;\vec{E}\neq0,\vec{M}=\vec{p}\times\vec{E}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011444076.png" /></p><p><span class="math inline">\(\vec{E}\uparrow\)</span>，<spanclass="math inline">\(\vec{p}\)</span>排列越整齐</p></li><li><p>无极分子</p><p>位移极化：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011444423.png" /></p></li></ol><h2 id="电极化强度矢量vecp">电极化强度矢量<spanclass="math inline">\(\vec{P}\)</span></h2><ol type="1"><li><p><span class="math inline">\(\vec{P} = \frac{\sum p_i}{\DeltaV}\)</span>，单位体积内所有分子的电偶极矩之矢量和，单位<spanclass="math inline">\(c/m^2\)</span></p></li><li><p><span class="math inline">\(\vec{P}\)</span>与<spanclass="math inline">\(\vec{E}\)</span>成正比，对于各向同性的电介质：<spanclass="math inline">\(\vec{P} =\varepsilon_0(\varepsilon_r-1)\vec{E}\)</span></p><p><span class="math inline">\(\chi_e=\varepsilon_r-1\)</span>，<spanclass="math inline">\(\chi_e\)</span>--电极化率，<spanclass="math inline">\(\varepsilon_r\)</span>--相对介电常数</p><p>即：<span class="math inline">\(\vec{P}=\chi_e\varepsilon_r\vec{E}\)</span>，<spanclass="math inline">\(\overrightarrow{E} =\overrightarrow{E_{\text{外}}}+\overrightarrow{E&#39;}\)</span></p></li><li><p>电击穿--电介质的击穿</p><p>当<spanclass="math inline">\(\vec{E}\)</span>足够强的时候，分子中正负电荷被拉开<spanclass="math inline">\(\rightarrow\)</span>自由电荷</p><p>绝缘体<span class="math inline">\(\rightarrow\)</span>导体 <spanclass="math inline">\(\Longrightarrow\)</span> 电介质的击穿</p><p>电介质所能承受的不被击穿的最大的电场强度<spanclass="math inline">\(\rightarrow\)</span>击穿场强</p></li></ol><h2 id="有电介质存在时的静电场的计算">有电介质存在时的静电场的计算​</h2><p>在有介质存在空间的电场由自由电荷和介质上的束缚电荷共同产生</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011507578.png" /></p><p>放入介质两极板间的电位差为<spanclass="math inline">\(\rightarrow\)</span>V</p><p>未放入介质两极板间的电位差为<span class="math inline">\(\rightarrowV_0\)</span></p><p><span class="math inline">\(\Longrightarrow\)</span> <spanclass="math inline">\(\color{red}{V=\frac{V_0}{\varepsilon_r}}\)</span>​</p><h3 id="介质中的高斯定理">介质中的高斯定理</h3><p>通过高斯面的电位移通量等于高斯面所包围的<spanclass="math inline">\(\color{red}{自由电荷}\)</span>的代数和，与极化电荷和高斯面外的电荷无关</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406011528093.png" /></p><p>电介质内的合场强为<spanclass="math inline">\(\vec{E}=\vec{E&#39;}+\vec{E_0}\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849786.png" /></p><p>电位移矢量：<span class="math inline">\(\vec{D}\)</span></p><p><spanclass="math inline">\(\vec{D}\)</span>线：电场线始于正电荷，止于负电荷；<spanclass="math inline">\(\vec{D}\)</span>线始于正自由电荷，止于正自由电荷</p><p><span class="math inline">\(\vec{D}\)</span>的通量：（均匀）<spanclass="math inline">\(\Phi_D=\vec{D}\cdot \Delta\vec{S}\)</span>，（非均匀）<span class="math inline">\(\Phi_D =\iint_S\vec{D}\cdot d\vec{S}\)</span></p><p><span class="math inline">\(\color{red}{注：}\)</span> 1. <spanclass="math inline">\(\vec{D}\)</span>由空间所有电荷（自由、束缚、S面内、S面外）共同决定</p><p>​ 2. <span class="math inline">\(\iint_S\vec{D}\cdotd\vec{S}\)</span>由面内自由电荷决定</p><p>​ 3.<span class="math inline">\(\vec{D} =\varepsilon\vec{E}\)</span>，<spanclass="math inline">\(\vec{D}\)</span>与<spanclass="math inline">\(\vec{E}\)</span>处处对应方向一致</p><p>​ 4.<span class="math inline">\(\oint\vec{D}d\vec{S}=\sumq_{self}\)</span>与 <span class="math inline">\(\oint\vec{E}d\vec{S}=\frac{\sum q_{\text{自}}+\sumq_{\text{束}}}{\varepsilon_0}\)</span></p><h3 id="环路定理-1">环路定理</h3><p><span class="math inline">\(\oint\vec{E}d\vec{l} =0\)</span>，束缚电荷产生的场强与自由电荷产生的场强相同</p><h3 id="归纳">归纳</h3><ol type="1"><li><p><spanclass="math inline">\(\vec{P}=\chi_E\varepsilon_0\vec{E}\)</span></p></li><li><p><span class="math inline">\(\vec{D}=\varepsilon_0\varepsilon_r\vec{E}\)</span></p></li><li><p><span class="math inline">\(\vec{D} = \varepsilon_0\vec{E}+\vec{P}\)</span></p></li><li><p>空间某点处的<spanclass="math inline">\(\vec{E}\)</span>仅与该点的电介质有关，而该处的<spanclass="math inline">\(\vec{V}\)</span>与积分路径上所有电介质有关</p></li></ol><h1 id="电容">电容</h1><h2 id="孤立导体的电容">孤立导体的电容</h2><p>若一孤立导体带电<span class="math inline">\(+q\)</span>，该导体具有一定的电势<span class="math inline">\(V\)</span>，电容<spanclass="math inline">\(C=\frac{q}{V}\)</span></p><p>电容的物理意义：孤立导体每升高一个单位的电势所需要的电量</p><h2 id="电容器及其电容">电容器及其电容</h2><p><span class="math inline">\(C_{AB} = \frac{q}{V_a-V_B}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849544.png" /></p><p>增大电容：多个电容并联<span class="math inline">\(C = C_1+C_2+...+C_k\)</span></p><p>增强耐压：多个电容串联<spanclass="math inline">\(\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}+...+\frac{1}{C_k}\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406020849265.png" /></p><p>电容器中有介质时的C：<span class="math inline">\(C =\frac{\varepsilon_0S}{b-\frac{\varepsilon_r-1}{\varepsilon_r}t}\)</span></p><h3 id="方法">方法</h3><ol type="1"><li>假设极板的上下面电荷密度，利用电势差的关系<spanclass="math inline">\(\rightarrow\)</span>场强<spanclass="math inline">\(\rightarrow\)</span>面电荷密度</li><li>假设极板的上下面电荷密度，利用<spanclass="math inline">\(D=\sigma\)</span> <spanclass="math inline">\(\rightarrow\)</span> E <spanclass="math inline">\(\rightarrow\)</span> <spanclass="math inline">\(\Delta V\)</span> <spanclass="math inline">\(\rightarrow\)</span>​ C</li><li>根据串并联的规则</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 静电场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静电场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲线积分与曲面积分</title>
      <link href="/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/"/>
      <url>/2024/05/23/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一型曲线积分">第一型曲线积分</h1><h2 id="形式">形式</h2><p><span class="math inline">\(\int_{L}f ds\)</span>​ --表示曲线L的质量，f是密度函数</p><h2 id="方法">方法</h2><ol type="1"><li><strong>化为定积分</strong></li></ol><p><span class="math inline">\(\int_{L}f ds =\int_{\alpha}^{\beta}f(x(t),y(t),z(t))\sqrt{x(t)&#39;^{2} +y(t)&#39;^{2} +z(t)&#39;^{2}}dt\)</span>​</p><ul><li>极坐标：<span class="math inline">\(ds=\sqrt{r(\theta)^2 +r(\theta)&#39;^2}d\theta\)</span></li><li>xy平面曲线：<span class="math inline">\(ds =\sqrt{1+y(t)&#39;^2}dx\)</span>​</li></ul><ol start="2" type="1"><li><strong>对称性</strong></li></ol><ul><li>平面曲线L关于<spanclass="math inline">\(y=x\)</span>对称，且被积函数在L上连续：可以交换x，y</li><li>空间曲线L关于<spanclass="math inline">\(y=x=z\)</span>对称，且被积函数在L上连续：x,y,z具有轮换对称性</li></ul><ol start="3" type="1"><li><p><strong>质心</strong></p><p>当被积函数是只有一次参变量时，可以利用已知质心进行计算</p></li></ol><h1 id="第二型曲线积分">第二型曲线积分</h1><h2 id="形式-1">形式</h2><p><span class="math inline">\(\int_{L}\vec{F} \cdot d\vec{r} = \int_L\vec{F} \cdot \vec{\tau}ds = \int_LPdx+Qdy+Rdz = \int_L Pcos\alpha +Qcos\beta + Rcos\gamma ds\)</span></p><p><spanclass="math inline">\(\vec{\tau}\)</span>为L的切矢量，其方向余弦为<spanclass="math inline">\({cos\alpha,cos\beta,cos\gamma}\)</span>，<spanclass="math inline">\(\vec{F} = \left\{P,Q,R\right\}\)</span>，<spanclass="math inline">\(d\vec{r} = \left\{dx,dy,dz\right\}\)</span> --变力沿​曲线做功</p><h2 id="方法-1">方法</h2><ol type="1"><li><p><strong>化为定积分</strong></p></li><li><p>Green公式</p><p><span class="math inline">\(\oint_L Pdx + Qdy = \iint_\limits{D}(Q_x- P_y)dxdy\)</span></p><ul><li>简单闭曲线</li><li>函数P，Q在D上包括边界有连续一阶偏导数</li></ul></li><li><p>积分与路径无关</p></li></ol><ul><li>可化成全微分</li><li><span class="math inline">\(Q_x = P_y\)</span></li><li>D内任何分段光滑闭曲线C，<span class="math inline">\(\oint_C Pdx+Qdy= 0\)</span></li></ul><ol start="4" type="1"><li>除<spanclass="math inline">\(M_0\)</span>点外，P，Q处处有一节连续偏导数，<spanclass="math inline">\(Q_x = P_y\)</span>，<spanclass="math inline">\(\color{red}{任何}\)</span>包围<spanclass="math inline">\(M_0\)</span>的<spanclass="math inline">\(\color{red}{正向}\)</span>简单闭曲线L，积分<spanclass="math inline">\(\oint_L Pdx+Qdy\)</span>取同一值</li></ol><h1 id="第一型曲面积分">第一型曲面积分</h1><h2 id="形式-2">形式</h2><p><span class="math inline">\(\iint_\limits{S}f(x,y,z)dS\)</span> --曲面质量</p><h2 id="方法-2">方法</h2><ol type="1"><li><p>化为二重积分</p><p>将曲面投影到某个坐标面，将<spanclass="math inline">\(\iint_\limits{S}\)</span>改成<spanclass="math inline">\(\iint_\limits{D}\)</span></p><p><span class="math inline">\(dS = \sqrt{1+z_x^2 +z_y^2}d\sigma\)</span></p></li></ol><h1 id="第二型曲面积分">第二型曲面积分</h1><h2 id="形式-3">形式</h2><p><span class="math inline">\(\iint_\limits{S} \vec{F}\cdot \vec{n}ds =\iint_\limits{S}Pcos\alpha + Qcos\beta + Rcos\gamma dS =\iint_\limits{S}Pdydz + Qdzdx + Rdxdy\)</span></p><p>-- 流量问题</p><h2 id="方法-3">方法</h2><ol type="1"><li>化为二重积分</li><li>分散投影</li><li>统一投影法</li></ol><p>​ <span class="math inline">\(\vec{n} = \left\{cos\alpha,cos\beta,cos\gamma\right\}=\pm \frac{1}{\sqrt{1+z_x^2 + z_y^2}}\left\{-z_x, -z_y, 1\right\}\)</span></p><p>​ <span class="math inline">\(dydz=\cos\alphadS=-z_x(x,y)dxdy\)</span></p><p>​ <span class="math inline">\(dzdx = \cos\beta dS =-z_y(x,y)dxdy\)</span></p><p>​ <span class="math inline">\(dxdy = \cos\gamma dS\)</span></p><ol start="4" type="1"><li>散度与旋度</li></ol><p>​ <span class="math inline">\(\nabla = \left\{\frac{\partial}{\partialx} ,\,\frac{\partial}{\partial y} ,\,\frac{\partial}{\partial z}\right\}\)</span></p><p>​ <span class="math inline">\(\nabla f(r) = \left\{\frac{\partialf(r)}{\partial x} ,\,\frac{\partial f(r)}{\partial y} ,\,\frac{\partialf(r)}{\partial z} \right\}\)</span> = <spanclass="math inline">\(f&#39;(r)\cdot \frac{1}{\sqrt{x^2 + y^2 + z^2}}\left\{x,y,z\right\}\)</span>=<spanclass="math inline">\(\frac{f&#39;(r)}{r} \vec{r}\)</span> （其中<spanclass="math inline">\(\vec{r} = \left\{x,y,z\right\}\)</span>）</p><p>​ 散度：<span class="math inline">\(div\, \vec{F} = P_x+Q_y+R_z=\nabla\cdot \vec {F}\)</span></p><p>​ 旋度：<span class="math inline">\(\overrightarrow{rot\,F}=\)</span><span class="math inline">\(\  \left|\begin{array}{cccc}     i&amp;    j    &amp; k \\     \frac{\partial}{\partial x}&amp;    \frac{\partial}{\partial y}   &amp; \frac{\partial}{\partialz}\\     P &amp; Q &amp; R  \end{array}\right|\)</span><spanclass="math inline">\(=\nabla \times \vec{F}\)</span></p><ol start="5" type="1"><li><p>Gauss公式</p><p>S应该是正向闭曲面</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405232047414.png" /></p></li><li><p>Stokes公式</p></li></ol><p>​ <span class="math inline">\(\oint_L \,\vec{F}\cdot d\vec{r} =\iint\limits_{s}(\nabla\times \vec{F})\cdot \vec{n}dS\)</span></p><p>​ <span class="math inline">\(\oint_L Pdx+Qdy+Rdz =\iint_\limits{S}\)</span> <spanclass="math inline">\(\  \left|\begin{array}{cccc}     dydz&amp;    dzdx    &amp; dxdy \\     \frac{\partial}{\partial x}&amp;    \frac{\partial}{\partial y}   &amp; \frac{\partial}{\partialz}\\     P &amp; Q &amp; R  \end{array}\right|\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分与曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绪论">绪论</h1><h2 id="概念">概念</h2><p><strong>数据</strong>：所有能输入到计算机中并被计算机程序加工、处理的符号的总称。如：整数、实数、字符、声音、图象、图形等。</p><p><strong>数据项</strong>：数据的不可分割的最小单位</p><p><strong>数据元素</strong>：数据的基本单位，一个数据元素可以由若干个数据项组成</p><p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集</p><p><strong>数据结构</strong>：相互之间存在一种或多种特定关系的数据元素的集合。</p><p><strong>结构</strong>：数据元素之间的关系称为结构。</p><p><strong>数据类型</strong>：是一个值的集合和定义在这个值上的一组操作的总称。</p><ol type="1"><li>原子类型(如：int,char,float等)</li><li>结构类型(如：数组,结构,联合体等）</li></ol><h2 id="抽象数据类型">抽象数据类型</h2><p><strong>抽象数据类型（ADT）</strong>：与计算机的实现无关的数据类型</p><p>形式定义：</p><p>ADT 抽象数据类型名 {</p><ol type="1"><li><p>数据对象</p></li><li><p>数据关系:一个或多个关系</p></li><li><p>基本操作：一组基本操作/运算</p></li></ol><p>} ADT 抽象数据类型名</p><p>其中数据对象和数据关系的定义用<strong>伪码</strong>描述，基本操作的定义格式为：</p><p>基本操作名（参数表）</p><p>​ 初始条件：<初始条件描述></p><p>​ 操作结果：<操作结果描述></p><p>参数表中有两种操作：</p><ol type="1"><li>赋值参数：只为操作提供输入值</li><li>引用参数：以&amp;打头，除可提供输入值外，还将返回操作结果</li></ol><h2 id="算法与算法分析">算法与算法分析</h2><p>算法的特征：</p><ol type="1"><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入：有0或多个输入量</li><li>输出：至少有一个输出量</li></ol><p>算法设计要求：</p><ol type="1"><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效与低存储量</li></ol><p>时间复杂度比较</p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281632685.png" style="zoom: 50%;" /></p><h1 id="线性表">线性表</h1><h2 id="adt">ADT</h2><p>ADT List</p><p>{</p><p>数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n&gt;=0\right\}\)</span></p><p>数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span></p><p>基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitList</span>(&amp;L) <span class="comment">//构造空表L。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyList</span>(&amp;L) <span class="comment">//销毁线性表L</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearList</span>(&amp;L) <span class="comment">//置L为空表</span></span><br><span class="line"><span class="number">4.L</span>istEmpty(L) <span class="comment">//判断L是否为空表</span></span><br><span class="line"><span class="number">5.L</span>istLength(L) <span class="comment">//求表L的长度</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetElem</span>(L,i,&amp;e) <span class="comment">//取元素ai,由e返回ai</span></span><br><span class="line"><span class="number">7.L</span>ocateElem(L,e,<span class="built_in">compare</span>()) <span class="comment">//查找符合条件的元素</span></span><br><span class="line"><span class="number">8.L</span>istInsert(&amp;L,i,e) <span class="comment">//元素ai之前插入新元素e</span></span><br><span class="line"><span class="number">9.L</span>istDelete(&amp;L,i,&amp;e) <span class="comment">//删除第i个元素</span></span><br></pre></td></tr></table></figure><p>}ADT List</p><h2 id="顺序存储结构">顺序存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">    <span class="type">int</span> listsize;<span class="comment">//当前分配的存储容量</span></span><br><span class="line">&#125;Sqlist</span><br></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中的第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;<span class="comment">//i不合法</span></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt; L.listsize)<span class="comment">//当前存储空间已满，增加存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(L.elem,(L.listsize + ADD)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += ADD;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(l.elem[i - <span class="number">1</span>]);<span class="comment">//q是待插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; p--)</span><br><span class="line">    *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​ 设共有n个元素，在各个位置插入元素的概率相同，为<spanclass="math inline">\(p=\frac{1}{n +1}\)</span>，则插入一个元素时移动的平均值为<spanclass="math inline">\(\sum\limits_{i=1}^{n+1}p(n-i+1)=\frac{n}{2}\)</span></p><h3 id="删除操作">删除操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中删除第i个元素，并用e返回其值</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelte_Sq</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;<span class="comment">//如果i不合法</span></span><br><span class="line">    p = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = *p;</span><br><span class="line">    q = L.elem + L.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(++p; p &lt;= q; ++p)</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​ 设共有n个元素，在各个地方删除元素的概率为<spanclass="math inline">\(p=\frac{1}{n}\)</span>，则删除一个元素时移动元素的平均值为<spanclass="math inline">\(\sum\limits_{i=1}^{n}p(n-i) =\frac{n-1}{2}\)</span>​</p><h3 id="合并操作">合并操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线性表Lb中的且不再La中的元素合并到La中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(Sqlist&amp; La, Sqlist&amp; Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, i, e);<span class="comment">//从Lb中取第i个元素赋值给e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La, e, equal))</span><br><span class="line">        <span class="built_in">ListInsert</span>(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并并排序操作">合并并排序操作</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并非递减排序线性表La和Lb，得到Lc并且Lc按非递减排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(Sqlist La, Sqlist Lb, Sqlist&amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i = j = k = <span class="number">0</span>;</span><br><span class="line">    La_len = La.length; Lb_len = Lb.Length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len &amp;&amp; j &lt;= Lb_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Getelem</span>(La, i, ai); <span class="built_in">Getelem</span>(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= La_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(La, i++, ai);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= Lb_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetElem</span>(Lb, j++, bj);</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序结构存储的评价">顺序结构存储的评价</h3><ol type="1"><li>优点<ol type="1"><li>是一种随机存取结构，存取任何元素的时间是一个常数，速度快</li><li>结构简单，逻辑上相邻的元素，物理上也是相邻的</li><li>不使用指针，节省存储空间</li></ol></li><li>缺点<ol type="1"><li>插入和删除需要移动大量数据，消耗大量时间</li><li>需要一块连续的空间</li><li>插入元素时可能会“溢出”</li><li>自由区中的存储空间不能被其他数据占用（共享）</li></ol></li></ol><h2 id="链式存储结构">链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125;node, *Linklist;</span><br></pre></td></tr></table></figure><h3 id="建立单链表">建立单链表</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“先进先出”（尾插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, tail, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    tail = head;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“后进先出&quot;（头插）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* create2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* head, p;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    head = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LENG));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立递增有序链表">建立递增有序链表</h3><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">create3</span>(<span class="keyword">struct</span> node* head, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    q = <span class="literal">NULL</span>, p = head;<span class="comment">//扫描，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//空表</span></span><br><span class="line">            head = s;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//尾插</span></span><br><span class="line">            q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="literal">NULL</span>)<span class="comment">//头插</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        head = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//其他正常情况的插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        q-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create4</span><span class="params">(<span class="keyword">struct</span> node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; e &gt; p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">//可以直接插入，不讨论</span></span><br><span class="line">    q-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作-1">插入操作</h3><p>​ 伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在i之前插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在i之后插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(Linklist&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)<span class="comment">//找到第i个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = (Linklist)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-1">删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在带表头节点的链表中删除值为e的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete1</span><span class="params">(stuct node* head, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* p, *q;</span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在单链表中删除指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete2</span><span class="params">(<span class="keyword">struct</span> node* head, <span class="type">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = head;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;<span class="comment">//q是待删除结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并操作-1">合并操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个带头节点的链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* <span class="built_in">Merge</span>(<span class="keyword">struct</span> node* La, <span class="keyword">struct</span> node* Lb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* pa, pb, pc;</span><br><span class="line">    pa = La-&gt;next, pb = Lb-&gt;next;</span><br><span class="line">    pc = La;</span><br><span class="line">    <span class="built_in">free</span>(Lb);<span class="comment">//释放Lb的头指针</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa) pc-&gt;next = pa;</span><br><span class="line">    <span class="keyword">else</span>  pc-&gt;next = pb; </span><br><span class="line">    <span class="keyword">return</span> La;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储结构评价">链式存储结构评价</h3><ol type="1"><li>优点：灵活地增加/插入，删除操作</li><li>缺点：使用显式顺序指针代替隐式的相邻存储的位置关系，增加了存储空间</li></ol><h2 id="循环链表">循环链表</h2><ol type="1"><li><p>一般形式</p><ol type="1"><li><p>带头结点的非空循环单链表，有：</p><p><code>head-&gt;next != head, head != NULL</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405291607660.png" /></p><ol type="1"><li><p>带表头结点的空循环单链表，有：</p><p><code>head-&gt;next == head, head != NULL</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048524.png" /></p></li><li><p>只有尾节点（带头）</p><ol type="1"><li><p>非空表，有：</p><p><code>tail-&gt;data ==an</code></p><p><code>tail-&gt;next指向表头结点</code></p><p><code>tail-&gt;next-&gt;next指向首节点</code></p><p><code>tail-&gt;next-&gt;next-&gt;data == a1</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048085.png" /></p><ol type="1"><li><p>空表，有：</p><p><code>tail-&gt;next == tail</code></p></li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048479.png" /></p></li></ol><p>两循环链表首尾相连(时间复杂度<code>O(1)</code>)</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292048842.png" /></p><p>​ <code>p2 = tail2-&gt;next</code></p><p>​ <code>tail2-&gt;next = tail1-&gt;next</code></p><p>​ <code>tail1-&gt;next = p2-&gt;next</code></p><p>​ <code>free(p2)</code></p><h2 id="双向链表">双向链表</h2><ol type="1"><li><p>非空表</p><figure><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047040.png"alt="image-20240529163639637" /><figcaption aria-hidden="true">image-20240529163639637</figcaption></figure><p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p><p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p><p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == NULL</code></p></li><li><p>空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047672.png" /></p><p>​ <code>L-&gt;next == L-&gt;prior == NULL</code></p></li></ol><h2 id="双向循环链表">双向循环链表</h2><ol type="1"><li><p>非空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047950.png" /></p><p>L为头指针，L指向表头结点，<code>L-&gt;next</code>指向首节点<code>L-&gt;next-&gt;data == a1</code></p><p><code>L-&gt;prior</code>指向尾节点，<code>L-&gt;prior-&gt;data == an</code></p><p><code>L-&gt;next-&gt;prior == L-&gt;prior-&gt;next == L</code></p></li><li><p>空表</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292047389.png" /></p><p>​ <code>L-&gt;next == L-&gt;prior == L</code></p></li></ol><h2 id="各链表比较">各链表比较</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292049549.png" /></p><h1 id="栈">栈</h1><p>栈：限定在表尾做插入、删除的线性表 ---“后进先出”</p><h2 id="adt-1">ADT</h2><p>ADT Stack</p><p>{</p><p>​ 数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq0\right\}\)</span></p><p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<spanclass="math inline">\(a_n\)</span>端为栈顶端，<spanclass="math inline">\(a_1\)</span>端为栈底</p><p>​ 基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitStack</span>(&amp;S) <span class="comment">//构造一个空栈。 </span></span><br><span class="line"><span class="number">2.</span><span class="built_in">ClearStack</span>(&amp;S) <span class="comment">//置s为空栈。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">DestroyStack</span>(&amp;S) <span class="comment">//栈s被销毁</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">Push</span>(&amp;S,e) <span class="comment">//元素e进栈S。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">Pop</span>(&amp;S,&amp;e) <span class="comment">//删除栈S的顶元素，并送入e 。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">GetTop</span>(S,&amp;e) <span class="comment">//将非空栈S的栈顶元素拷贝到e（与（4）的Pop操作是不同的）。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">StackEmpty</span>(&amp;S) <span class="comment">//判断s是否为空栈。若s为空栈,则返回值为true；否则为false。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">StackLength</span>(S) <span class="comment">//栈S的长度</span></span><br></pre></td></tr></table></figure><p>}ADT Stack</p><h2 id="栈的输出特点">栈的输出特点</h2><p>一般地，输入序列<spanclass="math inline">\((...,a_i,...,a_j,...,a_k)\)</span>到栈中，不能得到<spanclass="math inline">\((...,a_k,...,a_i,...,a_j)\)</span>​</p><h2 id="栈的存储结构">栈的存储结构</h2><p>栈的范围为<code>s[0...maxlen- 1]</code></p><ol type="1"><li><p>顶指针指向栈顶元素所在的位置</p><p>栈顶元素：s[top]</p><p>进栈：先对top + 1，再将新数据指向top</p><p>出栈：先取栈顶元素，再对top - 1</p><p>空栈：<code>top == -1</code></p><p>非空栈：<code>top &gt;= 0</code></p><p>满栈：<code>top == maxlen - 1</code></p></li><li><p>顶指针指向顶元素上的一空位置</p><p>栈顶元素：s[top - 1]</p><p>进栈：先将新数据指向top，再对top + 1</p><p>出栈：先对top - 1，再取栈顶元素</p><p>空栈：<code>top == 0</code></p><p>非空栈：<code>top &gt;= 0</code></p><p>满栈：<code>top == maxlen</code></p></li></ol><p><strong><spanclass="math inline">\(\color{red}{顺序栈规定top指向栈元素上一空位置}\)</span>​</strong></p><h2 id="顺序栈">顺序栈</h2><p>存储表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>初始化栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base =(SElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SElemType)*STACK_INIT_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//内存分配失败</span></span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果内存不够</span></span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize) </span><br><span class="line">    &#123;</span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(S.base,(S.stacksize + STACK_INIT_SIZE)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//如果分配失败</span></span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINITSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    *(S.top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;<span class="comment">//如果栈为空</span></span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式栈">链式栈</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292207525.png" /></p><p>让top指向an，进栈将新节点作为首节点，出栈删除首节点，保证进出栈时间为常数</p><h2 id="栈的应用">栈的应用</h2><h3 id="数制转换">数制转换</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292226270.png" /></p><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,N);</span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, N % <span class="number">8</span>);</span><br><span class="line">        N /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号匹配">括号匹配</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292231643.png" /></p><h3 id="表达式求值">表达式求值</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292253188.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292254637.png" /></p><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OperandType <span class="title">EvaluateExpression</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR); <span class="built_in">Push</span>(OPTR, <span class="string">&#x27;#&#x27;</span>);<span class="comment">//初始化操作符的栈</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPND); c = <span class="built_in">getchar</span>();<span class="comment">//初始化操作数的栈</span></span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(c, OP))<span class="comment">//如果不是运算符就进栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(OPND, c);</span><br><span class="line">            c = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), c))<span class="comment">/*判断优先级*/</span></span><br><span class="line">             <span class="comment">/*栈顶优先级低*/</span></span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>&lt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Push(OPRT, c);</span></span><br><span class="line"><span class="string">            c = getchar();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">            /*脱括号并接收下一个字符*/</span></span><br><span class="line"><span class="string">            case&#x27;</span>=<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Pop(OPRT, x);</span></span><br><span class="line"><span class="string">            c = getchar();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">               /*退栈并将运算符结果入栈*/</span></span><br><span class="line"><span class="string">            case&#x27;</span>&gt;<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            Pop(OPRT, theta);</span></span><br><span class="line"><span class="string">            Pop(OPND, b);</span></span><br><span class="line"><span class="string">            Pop(OPND, a);</span></span><br><span class="line"><span class="string">            Push(OPND, Operate(a, theta, b));</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return GetTop(OPND);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="队列">队列</h1><p>队列：只允许在表的一端插入一端删除的数据结构 ---“先进先出”</p><h2 id="adt-2">ADT</h2><p>ADT Queue</p><p>{</p><p>​ 数据对象：<spanclass="math inline">\(D=\left\{a_i|a_i∈ElemSet,i=1,2,...n,n\geq0\right\}\)</span></p><p>​ 数据关系：<span class="math inline">\(R1=\left\{&lt;a_{i-1},a_i&gt;|a_{i-1},a_i∈D,i=2,...n\right\}\)</span>，约定<spanclass="math inline">\(a_n\)</span>端为队列尾，<spanclass="math inline">\(a_1\)</span>端为队列头</p><p>​ 基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitQueue</span>(&amp;Q) <span class="comment">//初始化,构造空队列。</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">DestroyQueue</span>(&amp;Q) <span class="comment">//销毁Q队列。</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">ClearQueue</span>(&amp;Q) <span class="comment">//置Q为空队列。</span></span><br><span class="line"><span class="number">4.</span><span class="built_in">QueueEmpty</span>(Q) <span class="comment">//判断Q是否为空队列。</span></span><br><span class="line"><span class="number">5.</span><span class="built_in">EnQueue</span>(&amp;Q,e) <span class="comment">//将e插入队列Q的尾端。</span></span><br><span class="line"><span class="number">6.</span><span class="built_in">DeQueue</span>(&amp;Q,&amp;e) <span class="comment">//取走队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">7.</span><span class="built_in">GetHead</span>(Q,&amp;e) <span class="comment">//读取队列Q的首元素,送e。</span></span><br><span class="line"><span class="number">8.</span><span class="built_in">QueueLengrh</span>(Q) <span class="comment">//返回队列长度</span></span><br></pre></td></tr></table></figure><p>}ADT Queue</p><h2 id="链式队列">链式队列</h2><p>用带头节点的单链表表示队列</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292334133.png" /></p><p>存储表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span>* next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>初始化队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349895.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405292349851.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;<span class="comment">//头插</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="comment">//如果是只有一个节点的情况</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><p><ahref="https://blog.csdn.net/qq_61959780/article/details/127332940?app_version=6.2.9&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127332940%22%2C%22source%22%3A%22luckyYY520%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">参考此篇blog</a></p><p>分辨队满&amp;队空</p><ol type="1"><li>rear指向的为空，留一个空位置<ol type="1"><li>队空：<code>q.rear == q.front</code></li><li>队满：<code>q.rear + 1 == q.front</code></li></ol></li><li>设置flag标志<ol type="1"><li>入队时如果<code>q.rear == q.front</code>，则队满，设置flag为true</li><li>出队时如果<code>q.rear == q.front</code>，则队空，设置flag为false</li></ol></li><li>记录length</li></ol><p>找到front, rear, length的关系</p><p><code>front = (rear + MAXSIZE - length) % MAXSIZE</code></p><h1 id="数组">数组</h1><h2 id="数组的递归定义">数组的递归定义</h2><ul><li><p>一维数组：<spanclass="math inline">\((a_1,a_2,...,a_n)\)</span>，其中<spanclass="math inline">\(a_i\)</span>为数据元素<spanclass="math inline">\(1\leq i\leq n\)</span></p></li><li><p>二维数组：<spanclass="math inline">\((\alpha_1,\alpha_2,...,\alpha_m)\)</span>，其中<spanclass="math inline">\(\alpha_i = (a_{i1},a_{i2},...,a_{in})\)</span>为行向量，<span class="math inline">\(1\leqi\leq m\)</span></p></li><li><p>三维数组：<spanclass="math inline">\((\beta_1,\beta_2,...,\beta_p)\)</span>，其中<spanclass="math inline">\(\beta_k=(\alpha_1,\alpha_2,...,\alpha_m)\)</span>，<spanclass="math inline">\(1\leq k\leq p\)</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301404268.png" /></p></li></ul><h2 id="数组的顺序表示">数组的顺序表示</h2><ol type="1"><li><p>以行序为主序的顺序存储方式</p><p><spanclass="math inline">\(\color{red}{左边的下标后变化，右边的下标先变化}\)</span></p></li><li><p>以列序为主序的顺序存储方式</p><p><spanclass="math inline">\(\color{red}{左边的下标先变化，右边的下标后变化}\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301413278.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301415139.png" /></p></li></ol><h2 id="数组的映像函数">数组的映像函数</h2><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301418472.png" style="zoom: 67%;" /></p><ol type="1"><li><p>以行序为主序，<spanclass="math inline">\(a[i][j]\)</span>的地址为：</p><p><span class="math inline">\(Loc(i, j) = Loc(1, 1)+((i - 1)*n +(j -1))*s\)</span></p></li><li><p>以列序为主序，<spanclass="math inline">\(a[i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(i,j)=Loc(1,1)+((j-1)*m+(i-1))*s\)</span></p></li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301422772.png" style="zoom:67%;" /></p><ol type="1"><li><p>以行序为主序，<spanclass="math inline">\(a[k][i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((k-1)*m*n+(i-1)*m+(j-1))*s\)</span></p></li><li><p>以列序为主序，<spanclass="math inline">\(a[k][i][j]\)</span>的地址为：</p><p><spanclass="math inline">\(Loc(k,i,j)=Loc(1,1,1)+((j-1)*p*m+(i-1)*p+k-1)*s\)</span></p></li></ol><h2 id="矩阵的压缩存储">矩阵的压缩存储</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301905856.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301909749.png" /></p><p><span class="math inline">\(a_{ij}\)</span>在SA中的序号：</p><p><span class="math inline">\(k(i,j) =\)</span> <spanclass="math display">\[\left\{\begin{aligned}i(i-1)/2 + j&amp; &amp;i\geq j\\ j(j-1)/2+i&amp; &amp;i&lt;j\end{aligned}\right.\]</span>​</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301916257.png" /></p><p>任意<span class="math inline">\(a_{ij}\neq0\)</span>，在SA中的序号：<spanclass="math inline">\(k=((i-1)*3-1)+(j-i+2)=2i+j-2\)</span></p><p><span class="math inline">\(A[i,j]=\)</span> <spanclass="math display">\[\left\{\begin{aligned}k&amp; &amp;|i-j|\leq 1\\0&amp; &amp;其他\end{aligned}\right.\]</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405301941684.jpg" /></p><h2 id="稀疏矩阵的存储">稀疏矩阵的存储</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405302304289.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;<span class="comment">//非零元的下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];<span class="comment">//非零元三元组表</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数和非零元的个数</span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"><span class="comment">//求稀疏矩阵的转置</span></span><br><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.mu = M.nu, T.nu = M.mu, T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span>(T.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt;= M.nu; col++) num[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t &lt;= M.tu; t++) ++num[M.data[t].j];</span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">2</span>;col &lt;= M.nu; ++col) cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= M.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j;</span><br><span class="line">            T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[p].e;</span><br><span class="line">            ++cpot[col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十字链接表">十字链接表</h2><p><ahref="%5B稀疏矩阵的十字链表存储表示和实现（第五章%20P104%20算法5.4）_用十字链表实现稀疏矩阵的存储,写出其创建和输出算法-CSDN博客%5D(https://blog.csdn.net/qq_42185999/article/details/105083274)">见此篇blog</a></p><h1 id="广义表">广义表</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062335576.jpg" /></p><h1 id="二叉树">二叉树</h1><h2 id="二叉树的性质">二叉树的性质</h2><ol type="1"><li>二叉树第i层，最多有<spanclass="math inline">\(2^{i-1}\)</span>个结点</li><li>深度为k的二叉树，最多有<span class="math inline">\(2^k -1\)</span>个结点</li><li><span class="math inline">\(n_0=n_2+1\)</span></li><li>n个结点的满二叉树深度为<spanclass="math inline">\(log_2(n+1)\)</span></li><li>顺序编号的满二叉树<span class="math inline">\(1,2,...,n\)</span><ul><li>结点i的左孩子为2i，右孩子为2i+1</li><li>结点i的双亲为<span class="math inline">\(\lfloori/2\rfloor\)</span></li><li>结点i的层号<span class="math inline">\(\lfloorlog_2i\rfloor+1=\lceil log_2(n+1)\rceil\)</span></li></ul></li></ol><h2 id="二叉树的存储">二叉树的存储</h2><h3 id="顺序存储">顺序存储</h3><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323914.png" /></p><h3 id="链式存储">链式存储</h3><ol type="1"><li>二叉链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>三叉链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* parent;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* lcild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span>* rchild;</span><br><span class="line">    ElemType data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>静态链表</li></ol><h2 id="二叉树的遍历">二叉树的遍历</h2><p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<spanclass="math inline">\(O(n)\)</span>​</p><blockquote><p>前序+中序 / 中序+后序可以唯一确定一个二叉树</p></blockquote><h3 id="先序遍历">先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历">中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="built_in">MidOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历">后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历">非递归遍历</h3><p>中序遍历：</p><ol type="1"><li>第一次访问到根节点不访问，直接入栈</li><li>中序遍历左子树，左子树遍历结束之后，第二次遇到根节点，退栈进行访问，然后中序遍历右子树</li><li>退栈时栈为空结束</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>* BitTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree st[max_length];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t)<span class="comment">//遍历完左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == max_length) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            st[top++] = t;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            t = st[--top];</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(top || t);<span class="comment">//如果还有右子树 或者 栈非空（父节点未访问）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><ol type="1"><li>沿着根的左孩子依次入栈，直到左孩子为空</li><li>如果没有右孩子，或者右孩子已经访问过，就访问该根节点</li><li>栈顶元素出栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BitTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitTree last;<span class="comment">//上一个访问的节点</span></span><br><span class="line">    BitTree st[maxlength];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        st[top++] = t;</span><br><span class="line">        t = t-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">BitTree tmp = st[--top];</span><br><span class="line">        <span class="keyword">if</span>((tmp-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; tmp-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">/*如果左右孩子均为空*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == last)<span class="comment">/*右孩子已经访问完*/</span></span><br><span class="line">           ||(tmp-&gt;rchild == <span class="literal">NULL</span> &amp;&amp; tmp-&gt;lchild == last))<span class="comment">/*右孩子为空，左孩子访问了*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, tmp-&gt;data);<span class="comment">//访问</span></span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BitTree r = tmp-&gt;rchild;</span><br><span class="line">            <span class="keyword">while</span>(r)</span><br><span class="line">            &#123;</span><br><span class="line">                st[top++] = r;</span><br><span class="line">                r = r-&gt;l·child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><p>原理：使用队列进行存储，将根节点放入队列中，并且访问之后将该节点的左右孩子加入队列中</p><h2 id="创建二叉树">创建二叉树</h2><h3 id="递归法">递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == #) root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (BiTree)<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        root-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归法">非递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        q = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        q-&gt;data = e;</span><br><span class="line">        q-&gt;lchild = <span class="literal">NULL</span>, q-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        s[i] = q;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) root = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">2</span>) s[j]-&gt;rchild = q;</span><br><span class="line">            <span class="keyword">else</span> s[j]-&gt;lchild = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树">线索二叉树</h2><h3 id="概念-1">概念</h3><p>规则：</p><ol type="1"><li>若结点的左子树为空，则该结点的左孩子指向其前驱结点</li><li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li></ol><p>为了区别lchild/rchild是指向左右孩子还是前/后驱结点，添加标志位ltag,rtag：</p><ol type="1"><li><code>ltag == 0</code>，指向左孩子；<code>ltag == 1</code>，指向前驱结点</li><li><code>rtag == 0</code>，指向右孩子；<code>rtag == 1</code>，指向后继结点</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311434403.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311443551.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405311444734.png" /></p><h3 id="线索化二叉树">线索化二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Thread</span>* lchild, rchild;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThreadTree</span><span class="params">(<span class="keyword">struct</span> Thread* node, <span class="keyword">struct</span> Thread* pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;lchild, pre);</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) node-&gt;ltag = <span class="number">0</span>;<span class="comment">//左孩子不是线索</span></span><br><span class="line">    <span class="keyword">else</span> node-&gt;ltag = <span class="number">1</span>, node-&gt;lchild = pre;</span><br><span class="line">    <span class="comment">//处理前驱结点</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) </span><br><span class="line">        pre-&gt;rchild = node, pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="built_in">InitThreadTree</span>(node-&gt;rchild, pre);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历线索二叉树">遍历线索二叉树</h3><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span> *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//有左孩子</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有左孩子，指向右孩子或者后继结点</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(<span class="keyword">struct</span> BitNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BitNode</span>* p = node;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;<span class="comment">//找到最左边的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rchild)<span class="comment">//存在后继结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>) p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//找到最左边的结点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = p-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树和森林">树和森林</h1><h2 id="树的表示形式">树的表示形式</h2><ol type="1"><li>广义表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231516.png" />2. 嵌套集合</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231188.png" /></p><ol start="3" type="1"><li>凹入表/目录表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406062231758.png" /></p><h2 id="树的存储结构">树的存储结构</h2><ol type="1"><li>双亲表示法/数组表示法/顺序表示法</li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407567.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">snode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;t[maxlength + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>孩子表示法/链接表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021407745.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408154.png" /></p><ol start="3" type="1"><li>孩子兄弟表示法/二叉树表示法/二叉链表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408655.png" /></p><ol start="4" type="1"><li>孩子链表表示法/单链表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408590.png" /></p><ol start="5" type="1"><li>带双亲的孩子链表表示法</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021408034.png" /></p><h2 id="森林树和二叉树的转换">森林、树和二叉树的转换</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406021424154.png" /></p><h2 id="树和森林的遍历">树和森林的遍历</h2><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041323277.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406041324802.png" /></p><h2 id="哈夫曼树">哈夫曼树</h2><p>树T的路径长度：PL(T)从树T的跟到其余每个结点的路径长度之和</p><p>树的带权路径长度：WPL(T)每个叶子的权与根到该叶子的路径长度的乘积之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HTNode, *HuffmanCode;<span class="comment">//动态分配数组存储哈夫曼树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;<span class="comment">//存储哈夫曼编码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode &amp;HC, <span class="type">int</span> *w, <span class="type">int</span> n)</span><span class="comment">/*w存放n个字符的权值*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HTNode) * (m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(p = HT + <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= n; i++, p++, w++)<span class="comment">//0号单元未用</span></span><br><span class="line">    *p = &#123;*w, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= m; i++, p++) *p = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);<span class="comment">//在HT[1,..,i-1]中选择parent为0且weight最小的两个结点，其序号分别是s1,s2</span></span><br><span class="line">        HT[s1].parent = i, HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1, HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight +HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*从叶子到根逆向求每个字符的哈夫曼编码*/</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[i].parent)</span><br><span class="line">        <span class="keyword">if</span>(HT[f].lchild == c) cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        HC[i] = (<span class="type">char</span>*)<span class="built_in">mallov</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (n - start));<span class="comment">//为编码开辟空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="概念-2">概念</h2><p>强连通图：图G中每对结点都存在路径</p><p>强连通分量：图G'是图G的极大连通子图，G'是G的一个强连通分量</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002704.png" /></p><h2 id="图的存储结构">图的存储结构</h2><ol type="1"><li>邻接矩阵<ul><li>无向图中<span class="math inline">\(v_i\)</span> 的度<spanclass="math inline">\(TD=\sum\limits_{j=1}^{n}M[i][j]=\sum\limits_{i=1}^{n}M[i][j]\)</span></li><li>有向图中<span class="math inline">\(v_i\)</span> 的入度<spanclass="math inline">\(ID =\sum\limits_{i=1}^{n}M[i][j]\)</span>(每一列的和)，出度<spanclass="math inline">\(OD =\sum\limits_{j=1}^{n}M[i][j]\)</span>(每一行的和)</li></ul></li><li>邻接表/逆邻接表</li><li>十字链表</li></ol><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032002846.png" /></p><ol start="4" type="1"><li><p>邻接多重表​</p><p><ahref="https://www.bilibili.com/video/BV1TL411b7V3/?spm_id_from=333.337.search-card.all.click">具体步骤见这个视频</a></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032019350.png" /></p></li></ol><p><strong>存储结构的优缺点</strong></p><p><strong>邻接矩阵</strong></p><p>优点：</p><ol type="1"><li>简单直观，好理解</li><li>便于计算一对顶点间是否有边，并且找到所有的邻接点</li><li>方便计算一个顶点的度</li></ol><p>缺点：</p><ol type="1"><li>不利于增加或者删除节点</li><li>存储稀疏图<spanclass="math inline">\((e&lt;nlogn)\)</span>较浪费空间</li><li>在统计边数等操作方面时间复杂度大</li></ol><p><strong>邻接表</strong></p><p>缺点：</p><ol type="1"><li>求节点度困难</li><li>每条边都要存两遍（无向图）</li></ol><h2 id="图的遍历">图的遍历</h2><p>DFS/BFS时间复杂度</p><ol type="1"><li>邻接矩阵存储<span class="math inline">\(O(n^2)\)</span></li><li>邻接表存储<span class="math inline">\(O(n+e)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038343.png" style="zoom: 67%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032038662.png" style="zoom: 60%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032040296.png" style="zoom: 70%;" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032041338.png" style="zoom: 67%;" /></p><h2 id="最小生成树">最小生成树</h2><h3 id="prim">Prim</h3><p>时间复杂度：<spanclass="math inline">\(O(n^2)\)</span>，适合稠密图</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312202.jpg" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph G, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vertexNum; i++)<span class="comment">//遍历所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        shortEdge[i].lowcost = G.arc[start][i];<span class="comment">//初始化最短路的数组</span></span><br><span class="line">        shortEdge[i].adjvex = start;<span class="comment">//存储这个路径距离中这个节点的上一个节点  </span></span><br><span class="line">    &#125;</span><br><span class="line">    shortEdge[start].lowcost = <span class="number">0</span>;<span class="comment">//将start放入集合U</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vertexNum - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">minEdge</span>(shortEdge, G.vertexNum);<span class="comment">//寻找最短边的邻接点k</span></span><br><span class="line">        <span class="built_in">outputMST</span>(k, shortEdge[k]);<span class="comment">//输出最小生成树的路径</span></span><br><span class="line">        shortEdge[k].lowcast = <span class="number">0</span>;<span class="comment">//将k加入集合U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vertexNum; j++)<span class="comment">//调整shortEdge数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.arc[k][j] &lt; shortEdge[j].lowcast)</span><br><span class="line">            &#123;</span><br><span class="line">                shortEdge[j].lowcast = G.arc[k][j];</span><br><span class="line">                shortEdge[j].adjvex = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kruskal算法">Kruskal算法</h3><p>时间复杂度：<span class="math inline">\(O(eloge)\)</span></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312333.jpg" /></p><h2 id="拓扑排序">拓扑排序</h2><blockquote><p>有回路的有向图不存在拓扑排序</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406032312495.png" /></p><h2 id="aoe网">AOE网</h2><blockquote><p>先求点，再求边</p></blockquote><p>工程完成的最短时间是从开始点到完成点的最长路径长度，路径长度最长的路径叫做关键路径，关键路径上的点为关键点--开始时间等于结束时间</p><p><ahref="%5B图-AOE网和关键路径_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV1dy421a7S1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef5e5127819460e26182982933cfa21e)">请参考这个视频</a></p><ol type="1"><li>ve(事件/节点的最早开始时间)，拓扑排序，每次选取<strong>入度</strong>为0的点，更新与之相邻的结点，ve是最长的那条路径长度</li><li>vl(事件/节点的最晚开始时间)，初始化所有结点的vl为终点的ve，<strong>逆</strong>拓扑排序，每次选取<strong>出度</strong>为0的点，更新与之相邻的结点，vl是选择使vl最小的那条路</li><li>e(活动/边的最早开始时间)，与发出这条边的结点的ve一致</li><li>l(活动/边的最晚开始时间)，用这条边指向的结点的vl减去这条边的边权</li></ol><h2 id="最短路径">最短路径</h2><h3 id="dijkstra算法">Dijkstra算法</h3><blockquote><p>解决单源最短路问题</p></blockquote><p><ahref="%5B图-最短路径-Dijkstra(迪杰斯特拉)算法_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.999.0.0&amp;vd_source=ef5e5127819460e26182982933cfa21e)">请参考这个视频</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//把起始点距离初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//用于找到当前距离起点最短的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新节点距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd算法">Floyd算法</h3><p><ahref="%5B图-最短路径-Floyd(弗洛伊德)算法_哔哩哔哩_bilibili%5D(https://www.bilibili.com/video/BV19k4y1Q7Gj/?spm_id_from=333.788&amp;vd_source=ef5e5127819460e26182982933cfa21e)">请参考这个视频</a></p><blockquote><p>求任意两个节点间的最短路径</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph G, PathMatrix&amp; p[], DistanceMatrix&amp; D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">        &#123;</span><br><span class="line">            D[v][w] = G.arcs[v][w];</span><br><span class="line">            <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                P[v][w][u] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(D[v][w] &lt; INFINITY)</span><br><span class="line">                &#123;</span><br><span class="line">                    P[v][w][v] = <span class="literal">true</span>;</span><br><span class="line">                    P[v][w][w] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(D[v][u] + D[u][w] &lt; D[v][w])</span><br><span class="line">                &#123;</span><br><span class="line">                    D[v][w] = D[v][u] + D[u][w];</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        P[v][w][i] = P[v][u][i] || P[u][w][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找">查找</h1><h2 id="静态查找表">静态查找表</h2><h3 id="顺序查找法">顺序查找法</h3><ol type="1"><li><p>不设置监视哨</p><p>判断条件：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">1</span> &amp;&amp; k != ST.elem[i].key)i--;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>设置监视哨</li></ol><p>​ <code>elem[0].key = k;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ST.length;</span><br><span class="line"><span class="keyword">while</span>(k != ST.elem[i].key)i--;</span><br></pre></td></tr></table></figure><p>ASL成功 = (n + 1) / 2</p><p>ASL失败：使用监视哨 = n + 1, 不使用监视哨 = n</p><h3 id="折半查找法">折半查找法</h3><p>相当于二分查找</p><h3 id="判定树">判定树</h3><p>描述折半查找过程的二叉树</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051340541.png" /></p><p>若判定树为满二叉树：<span class="math inline">\(ASL =\frac{n+1}{n}log2(n + 1) - 1\)</span></p><p>证明：<imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051338386.jpg" /></p><h2 id="动态查找表">动态查找表</h2><h3id="二叉排序树二叉查找树"><strong>二叉排序树（二叉查找树）</strong></h3><p>特点：如果二叉树的任一结点大于其非空左子树的所有结点，而小于其非空右子树的所有结点，则这棵二叉树称为二叉排序树。<strong><spanclass="math inline">\({\color{red}(左小右大)}\)</span>​</strong></p><h4id="删除二叉排序树中的结点"><strong><em>删除二叉排序树中的结点</em></strong></h4><p>设被删除的结点为*p，其双亲结点为*f，*s为*p的前驱结点，*p是*f的左孩子，有三种情况：</p><ol type="1"><li><p>*p为叶子结点：直接删除</p></li><li><p>*p只有左孩子PL或者右孩子PR：让PL/PR为*f的左孩子</p></li><li><p>*p的左孩子PL和右孩子PR均不为空：</p><ol type="1"><li><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071134367.png" /></p></li><li><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405071135262.png" /></p></li></ol></li></ol><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是待删除的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果左子树为空，或者为叶子结点</span></span><br><span class="line">    &#123; q = p; p = p-&gt;rchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//如果右子树为空</span></span><br><span class="line">    &#123; q = p; p = p-&gt;lchild; <span class="built_in">free</span>(q);&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果左右子树均不为空 以方法二为例</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;<span class="comment">//设置s的双亲结点是q</span></span><br><span class="line">            s = s-&gt;rchild;<span class="comment">//遍历直到找到p的前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;<span class="comment">//将p替换成s</span></span><br><span class="line">        <span class="comment">//要判断是因为如果删除结点的左子树有右子树那么中序遍历的前驱结点是右孩子，否则前驱结点是左孩子，就会导致移动的不同</span></span><br><span class="line">        <span class="keyword">if</span>(p != q)<span class="comment">//表明删除节点的左子树有右子树</span></span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;<span class="comment">//不需要free因为原来的s占的是q-&gt;left，现在已经被替换了</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树avl树"><strong>平衡二叉树</strong>(<spanclass="math inline">\(AVL\)</span>树)</h3><ol type="1"><li>结点的平衡因子：结点的左右子树深度之差（左子树高度-右子树高度）</li><li>平衡二叉树：任意结点平衡因子的绝对值小于等于1的二叉树</li></ol><h4id="高度一定的avl树所含最小节点个数">高度一定的AVL树所含最小节点个数</h4><p>S(h)表示深度为h的平衡二叉树所含有的最少节点个数</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051555220.png" /></p><p><img src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406051556641.png" style="zoom: 67%;" /></p><h4id="构造平衡二叉搜索树的方法"><strong><em>构造平衡二叉搜索树的方法</em></strong></h4><ul><li><p>左旋：向作左旋转，冲突的左孩变右孩</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081654715.png" /></p></li><li><p>右旋：向右旋转，冲突的右孩变左孩</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081656759.png" /></p></li><li><p><span class="math inline">\(LL\)</span>型，<spanclass="math inline">\(RR\)</span>型，<spanclass="math inline">\(LR\)</span>型，<spanclass="math inline">\(RL\)</span>​型</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081714341.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081716342.png" /></p><ul><li><span class="math inline">\(LL\)</span>型：右旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715912.png" /></p><ul><li><span class="math inline">\(RR\)</span>​型：左旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081849686.png" /></p><ul><li><span class="math inline">\(LR\)</span>​型：先左旋左孩子，再右旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715436.png" /></p><ul><li><span class="math inline">\(RL\)</span>​型：先右旋右孩子，再左旋</li></ul><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405081715357.png" /></p></li><li><p>插入结点时平衡失调，调整离删除结点最近的失衡结点即可</p><p>删除结点时平衡失调，依次对每个祖先进行检查和调整</p></li></ul><h3 id="哈希表">哈希表</h3><h4 id="构造哈希函数的方法"><em>构造哈希函数的方法</em></h4><ol type="1"><li><p>直接定址法：取关键字或者关键字的某个线性函数值作为哈希地址</p></li><li><p>除留余数法：设哈希表HT[0,1,..,m-1]的表长为m，哈希地址为key除以p所得余数（p为接近m的素数或为不包含20以内质因数的合数）</p></li><li><p>平方取中法：取关键字平方后的中间某几位为哈希地址</p></li><li><p>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址</p><ol type="1"><li><p>边界折叠法：<span class="math inline">\(eg: k1 =056439527\)</span>对应的地址为<spanclass="math inline">\(650+439+725\)</span></p></li><li><p>移位折叠法：<span class="math inline">\(eg: k1 =056439527\)</span>对应的地址为</p><p><span class="math inline">\(056+439+527\)</span></p></li></ol></li><li><p>数字分析法：如果哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干分布均匀的位组成哈希地址</p></li><li><p>随机数法：利用<spanclass="math inline">\(random(key)\)</span>​</p></li></ol><h4 id="解决哈希冲突的方法"><em>解决哈希冲突的方法</em></h4><ol type="1"><li>开放地址法<ol type="1"><li>线性嗅探再散列</li><li>二次嗅探再散列</li></ol></li><li>链地址法</li><li>建立公共溢出区</li><li>再哈希法</li></ol><h4 id="哈希化的效率"><strong><em>哈希化的效率</em></strong></h4><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405132118931.png" /></p><h4id="哈希表的平均查找长度"><strong><em>哈希表的平均查找长度</em></strong></h4><p><ahref="%5B哈希表：线性探测法和链地址法求查找成功与不成功的平均查找长度_链地址法查找失败的平均查找长度怎么算-CSDN博客%5D(https://blog.csdn.net/KD35KD/article/details/107054474)">见此篇BLOG</a></p><p>散列表</p><p>查找成功的概率：</p><ul><li>分母：所有待插入的元素的个数</li><li>分子：每个位置元素出现的个数</li></ul><p>查找失败的概率：</p><ul><li>分母：mod的大小</li><li>分子：从0-m-1的每一个位置到下一个空位置需要查找的个数</li></ul><h1 id="排序">排序</h1><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202406052033580.png" /></p><h2id="插入排序朴素版--稳定排序-折半版--不稳定">插入排序（朴素版--稳定排序折半版--不稳定）</h2><blockquote><p>第n趟排序，保证前n + 1个元素有序</p></blockquote><p>操作：将新的元素插入到已排序的数组中</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span>​</p><ul><li><p>最好的情况：原n个记录递增有序</p><p>比较关键字次数：<span class="math inline">\(n-1\)</span>次</p><p>移动记录次数：<spanclass="math inline">\(2(n-1)\)</span>次（将数据复制到a[0]又复制回来）</p></li><li><p>最坏的情况：原n个记录递减有序</p><p>比较关键字次数：<span class="math inline">\(\sum_\limits{i = 2}^n i =2+3+...+n = \frac{(n-1)(n+2)}{2}\)</span></p><p>移动记录次数：<span class="math inline">\(\sum_\limits{i=2}^{n}(i-1+2)=3+4+...+n=\frac{(n-1)(n+4)}{2}\)</span></p><p>（+2是因为监视哨，先复制一遍，再加到合适的位置）</p></li></ul><p>朴素版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序 </span></span><br><span class="line"><span class="comment">//对1-n进行排序(n表示的是数组的最后一个元素的下标，不是元素个数) </span></span><br><span class="line"><span class="comment">//在a[0]设置监视哨</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">cur = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[cur];</span><br><span class="line">cur--;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半插入排序（不稳定）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="comment">//优化了比较次数，但是只有当n很大时使用折半插入效率更高</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>, m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)<span class="comment">//利用二分法折半查找</span></span><br><span class="line">&#123;</span><br><span class="line">m = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[m])high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在high左边</span></span><br><span class="line"><span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//插入的位置可能在low的右边</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//high + 1即是待插入的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[high + <span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二路插入排序：</p><p>优点：可以减少移动的次数</p><p>操作：（排序长度为n的序列）相当于先开辟长度为n的数组，将该数组当做一个循环的空间，进行插入。</p><p>表插入排序：</p><h2 id="希尔排序colorred-不稳定排序">希尔排序<spanclass="math inline">\(\color{red} {（不稳定排序）}\)</span>​</h2><blockquote><p>第n趟排序后，能找到n个gap使元素每隔gap个元素就有序，且这n个gap满足等比关系</p></blockquote><p>操作：每次排序相隔gap的元素，不断缩小gap，直至gap ==1，排序后退出循环</p><p>时间复杂度：<span class="math inline">\(O(n ^{1.3})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--希尔排序  O(n^1.3)</span></span><br><span class="line"><span class="comment">//1. gap &gt; 1 预排序</span></span><br><span class="line"><span class="comment">//2. gap == 1 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> gap, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> cur = i - gap;</span><br><span class="line"><span class="keyword">while</span> (a[cur] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[cur + gap] = a[cur];</span><br><span class="line">cur -= gap;</span><br><span class="line">&#125;</span><br><span class="line">a[cur + gap] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后记录位置的增量为dk</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellInsert</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = dk + <span class="number">1</span>; i &lt;= L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">LT</span>(L.r[i].key, L.r[i - dk].key))<span class="comment">//将L.r[i]插入有序增量子表</span></span><br><span class="line">         &#123;</span><br><span class="line">             L.r[<span class="number">0</span>] = L.r[i];<span class="comment">//暂存在L.r[0]中，不是哨兵位</span></span><br><span class="line">             <span class="keyword">for</span>(j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">LT</span>(L.r[j].key, L.r[<span class="number">0</span>].key)); j -= dk)</span><br><span class="line">             &#123;</span><br><span class="line">                 L.r[j + dk] = L.r[j];</span><br><span class="line">             &#125;</span><br><span class="line">             L.r[j + dk] = L.r[<span class="number">0</span>];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> delta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, delta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序colorred不稳定排序">快速排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>判断是不是第2趟快排之后的结果：</p><p>判断左右两端的元素是否是最大的或者最小的</p><ol type="1"><li>如果是，就再在中间找一个pivot</li><li>如果不是，就要找三个pivot</li></ol></blockquote><p>操作：随机在数组中找一个数，利用递归，让左边的数都小于该数，右边的数都大于该数</p><ul><li>时间复杂度：<spanclass="math inline">\(O(nlogn)\)</span>，最坏的情况下（序列基本有序）时间复杂度为<spanclass="math inline">\(O(n^2)\)</span></li><li>空间复杂度：快排需要一个栈做辅助空间，平均情况下需要<spanclass="math inline">\(O(nlogn)\)</span>的空间，最坏的情况下，要递归n次，需要<spanclass="math inline">\(O(n)\)</span>的空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, left, right);<span class="comment">//找到在left，mid，right三个下标下大小是中间的那个的下标</span></span><br><span class="line"><span class="built_in">Swap</span>(a + keyi, a + left);</span><br><span class="line"><span class="comment">//左边当key 右边先走 ；右边当key 左边先走</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Swap</span>(a + left, a + right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(a + left, a + keyi);</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> part = <span class="built_in">PartSort</span>(a, begin, end);</span><br><span class="line"><span class="built_in">QuickSort</span> (part + <span class="number">1</span>, end);</span><br><span class="line"><span class="built_in">QuickSort</span>(begin, part - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.r[<span class="number">0</span>] = L.r[low];<span class="comment">//选最左边为pivotkey</span></span><br><span class="line">    pivotkey = L.r[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)</span><br><span class="line">           high--;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">pivotloc = <span class="built_in">partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">Qsort</span>(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三路划分的优化快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortThree</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a, begin, end);</span><br><span class="line"><span class="built_in">Swap</span>(a + keyi, a + begin);</span><br><span class="line"><span class="type">int</span> left = begin, right = end, cur = begin + <span class="number">1</span>, key = a[begin];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[cur] &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + cur, a + left);</span><br><span class="line">++cur, ++left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[cur] == key)</span><br><span class="line">&#123;</span><br><span class="line">++cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + cur, a + right);</span><br><span class="line">--right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">QuickSortThree</span>(a, begin,left - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSortThree</span>(a, right + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序colorred不稳定排序">选择排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>排序n趟之后，前n个元素应该是整个序列中最小的n个元素，并且顺序排列</p></blockquote><p>操作：每次选择未选择序列中最小的（最大的），放在已经排序的序列之后时间复杂度：</p><ul><li>比较次数：<spanclass="math inline">\(\frac{n(n-1)}{2}\)</span>即<spanclass="math inline">\(O(n^2)\)</span>​</li><li>移动次数：<ul><li>最好的情况，一开始就是升序，不需要移动</li><li>最坏的情况：每次都需要移动（不是降序的时候），交换记录数为n-1对，移动记录数为3(n-1)（因为swap里面有三条语句）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mini = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[mini]) mini = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[mini], &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序colorred不稳定排序">堆排序<spanclass="math inline">\(\color{red}{(不稳定排序)}\)</span>​</h2><blockquote><p>排序n趟之后，数组的最后n个元素应该是最大且有序的</p></blockquote><p>对n较大的文件有效</p><p>操作：升序建大堆，降序建小堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序--堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">++child;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> child)</span><span class="comment">//造大堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a + child, a + parent);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">AdjustUp</span>(a, i);</span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(a, a + end);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, end , <span class="number">0</span>);</span><br><span class="line"><span class="comment">//因为end是交换过去的最后一个 所以循环应该到这个就结束 不应该传end+1</span></span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Sqlist HeapType;</span><br><span class="line"><span class="comment">//H[s...m]中除了H.r[s].key其他都满足堆的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType&amp; H, <span class="type">int</span> s, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rc = H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; <span class="built_in">LT</span>(H.r[j].key, H.r[j + <span class="number">1</span>].key)) j++;</span><br><span class="line">        <span class="keyword">if</span>(!(rc.key, H.r[j].key)) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s] = H.r[j]; s = j;<span class="comment">//向下遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType&amp; H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = H.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    <span class="keyword">for</span>(i = H.length; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        H.r[i]&lt;--&gt;H.r[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序稳定排序">归并排序（稳定排序）</h2><blockquote><p>第1趟排序之后，从开始起相邻两个元素为升序排列；第二趟排序之后，相邻4个元素为升序排列……第n趟排序之后，相邻<spanclass="math inline">\(2^n\)</span>个元素为升序排列</p></blockquote><p>操作：将它们划分为长度均为1的子序列，然后逐步二路归并</p><p>时间复杂度：</p><ul><li>对n个记录的文件进行归并排序，共需要<spanclass="math inline">\(log_2n\)</span>趟，每趟所需要比较的关键字次数不超过n，所以总比较次数为<spanclass="math inline">\(O(nlogn)\)</span></li><li>每趟移动n个记录，移动次数为<spanclass="math inline">\(O(nlogn)\)</span></li><li>归并排序需要一个大小为n的辅助空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin == end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">MergeSort</span>(a, begin, mid, tmp);</span><br><span class="line"><span class="built_in">MergeSort</span>(a, mid + <span class="number">1</span>, end, tmp);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = begin, end1 = mid;</span><br><span class="line"><span class="type">int</span> begin2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"><span class="type">int</span> i = begin;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line"><span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType&amp; TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将有序的SR[i...m]和SR[m + 1...n]归并为有序的TR[i...n]</span></span><br><span class="line">    <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">LQ</span>(SR[i].key, SR[j].key)) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= m) TR[k...n] = SR[i...m];</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= n) TR[k...n] = SR[j...n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MSort</span><span class="params">(RcdType SR[], ScdType&amp; TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将SR[s...t]归并为TR1[s...t]</span></span><br><span class="line">    <span class="keyword">if</span>(s == t) TR1[s] = SR[s];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (s + t)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Msort</span>(SR, TR2, s, m);</span><br><span class="line">        <span class="built_in">Msort</span>(SR, TR2, m + <span class="number">1</span>, t);</span><br><span class="line">        <span class="built_in">Merge</span>(TR2, TR1, s, m, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(Sqlist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Msort</span>(L.r, L.r, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序稳定排序">基数排序（稳定排序）</h2><p>操作：</p><ul><li>MSD：高位有效优先</li><li>LSD：低位有效优先</li></ul><p>MSD对应数字排序：下面以个位为例</p><p>数组形式：</p><video src="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405281546971.mp4" width="100%" height="100%" controls="controls"></video><p>队列形式：</p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936416.png" /></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405230936776.png" /></p><p>时间复杂度：设数字的有效位数为d</p><ul><li>需要d趟回收分配，每趟分配运算时间为<spanclass="math inline">\(O(n)\)</span></li><li>收集：基数为rd,即rd个队列。从rd个队列中收集，运算时间O(rd)</li><li>一趟分配、回收运算时间O(n+rd), 时间复杂度O(d*(n+rd))</li><li>辅助空间：每个队列首尾2个指针，共2rd个指针；n个记录需要n个指针域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/05/07/%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/07/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法基础">算法基础</h1><h2 id="读入优化">读入优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="stl">STL</h2><h3 id="vector">vector</h3><p>操作：</p><ul><li>push_back()</li><li>pop_back()</li><li>size()</li><li>clear()</li><li>insert()</li><li>erase()<ul><li>erase(_position) --删除某个元素</li><li>erase(position_start, position_end)--删除区间<spanclass="math inline">\([position\_start,position\_end)\)</span>内的元素</li></ul></li></ul><h3 id="set">set</h3><p>特点：</p><ol type="1"><li>set的含义是集合，所有操作都在<spanclass="math inline">\(O(logn)\)</span>的时间复杂度内完成</li><li>set插入的元素不能相同</li><li>所有元素会根据值排序（默认是从小到大）</li><li>set中元素的值不能被直接修改</li><li>set不支持下标访问操作，只支持迭代器</li><li>模版：set<type> s;</li></ol><p>操作：</p><ul><li>begin()--返回指向第一个元素的迭代器</li><li>end()--返回指向最后一个元素的迭代器</li><li>clear()<br /></li><li>empty() --如果集合为空，返回true，否则返回false</li><li>erase()</li><li>count()<br /></li><li>find(k)</li><li>insert()</li><li>lower_bound(k) -- 返回一个迭代器，指向键值大于等于k的第一个元素</li><li>upper_bound(k) --返回一个迭代器，指向键值大于k的第一个元素</li><li>size()</li></ul><h3 id="queue">queue</h3><p>操作：</p><ul><li>模板：queue&lt;数据类型，容器类型&gt; q</li><li>push()</li><li>pop()</li><li>size()</li><li>front()--返回队首</li><li>back()--返回队尾</li><li>empty()</li></ul><h3 id="priority_queue">priority_queue</h3><p>特点：</p><ol type="1"><li>包含头文件<span class="math inline">\(\verb|#include&lt;queue&gt;|\)</span>​</li><li>默认从大到小排序（less 从大到小，greater 从小到大）</li></ol><p>操作：</p><ul><li>push()</li><li>pop()</li><li>empty()</li><li>top()</li><li>size()</li></ul><h3 id="map">map</h3><p>特点：</p><ol type="1"><li><p>使用头文件<span class="math inline">\(\verb|#include&lt;map&gt;|\)</span></p></li><li><p>具有唯一键值对</p></li><li><p>模版：map&lt;key_type, value_type&gt;变量名</p></li><li><p>可以保证元素的有序性，默认按照键（key）从小到大排序</p><p>如果想从大到小排序：<span class="math inline">\(\verb|map&lt;string,int, greater&lt;string&gt; &gt; m;|\)</span></p></li></ol><p>操作：</p><ul><li>size()</li><li>count()</li><li>empty()</li><li>erase()</li><li>clear()</li><li>find()</li><li>insert()</li><li>begin()</li><li>end()</li><li>lower_bound()</li><li>upper_bound()</li></ul><h3 id="unordered_map">unordered_map</h3><p>特点：</p><ol type="1"><li>快速查找特定元素</li><li>存储时元素是无序的</li><li>头文件<span class="math inline">\(\verb|#include&lt;unordered_map&gt;|\)</span></li></ol><p>操作：</p><ul><li>插入：insert({key, value})/map[key] = value</li><li>删除：clear()/erase()</li><li>迭代器：begin()/end()</li><li>元素个数：size()/count()``</li></ul><h1 id="数据结构">数据结构</h1><h1 id="图论">图论</h1><h2 id="最短路问题">最短路问题</h2><h3 id="dijkstra算法">Dijkstra算法</h3><p><strong><spanclass="math inline">\(\color{blue}（不能存在负权边）\)</span></strong></p><ul><li>朴素版本 ：时间复杂度 <spanclass="math inline">\(O(n^2)\)</span>，适合稠密图（利用邻接矩阵存储）<ol type="1"><li>将起点距离初始化为0，其他点的初始距离设置为无穷</li><li>每次找到距离起点距离最近的节点，将该点做标记，表示已经设置过</li><li>更新与该点有关的结点的距离</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//循环n-1次（除了开始的结点），每次都找到到某一个点的最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//寻找当前还未找的结点距离起点的最短路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t])) t = j;</span><br><span class="line">            <span class="comment">//找到一个距离起点更小的未被标记过的结点，就让t等于那个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//设置标记表示已经找到最小距离了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//更新与该结点有关结点的最小距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;<span class="comment">//n个结点m条边</span></span><br><span class="line">    <span class="built_in">memset</span>(g,  <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//初始化距离为无穷大</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);<span class="comment">//利用邻接矩阵进行存储，因为有重边所以取min</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用堆排序优化：时间复杂度<spanclass="math inline">\(O(mlogn)\)</span>，适合稀疏图（利用邻接表存储）<spanclass="math inline">\({\color{red}(除了找最小距离的时候利用堆优化，其他与朴素算法一致)}\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], w[N],idx;<span class="comment">//利用链式前向星存储</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//一个用来存距离，一个用来存结点</span></span><br><span class="line"><span class="comment">//只能将距离存在前面，因为要根据距离排序</span></span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><span class="comment">//存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = z;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII q = heap.<span class="built_in">top</span>();<span class="comment">//取堆顶元素</span></span><br><span class="line">        <span class="type">int</span> a = q.second, b = q.first;<span class="comment">//a是路径的尾节点，b是这条路径的长度</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();<span class="comment">//删除刚刚用过的堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(st[a]) <span class="keyword">continue</span>;</span><br><span class="line">        st[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[a]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[a] + w[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[a] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijsktra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellmanford算法">BellmanFord算法</h3><p>求出从 1号点到 n号点的最多经过 k 条边的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], cpy[N];<span class="comment">//一个同来记录最短距离，一个同来当做临时拷贝，防止出现连续更新的情况，因为该算法要保证循环k次只能走k条边，所以每次只能更新一条边的距离，如果只有一个dist就会出现，先用a更新b，再用b更新c的情况，导致循环k次只能走k条边条件不满足。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//设置初始距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cpy, dist, <span class="keyword">sizeof</span> dist);<span class="comment">//拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], cpy[e.a] + e.w);<span class="comment">//用上一次循环的距离cpy更新这一次的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        edges[i].a = x, edges[i].b = y, edges[i].w = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BellmanFord</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//因为可能存在负边所以是0x3f3f3f3f / 2</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa算法">Spfa算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//建立队列，保证每次更新的前一个结点是更新的</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//出队列 队列中无该结点 设置为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序">拓扑排序</h2><p>每次找到度为0的节点加入到最终的序列中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = head[x];</span><br><span class="line">    head[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[tt++] = i;<span class="comment">//先找到一开始度为0的结点</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];<span class="comment">//删除t结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//更改与t结点有关的边的度数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[tt++] = j;<span class="comment">//如果度为0就加入序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        d[y]++;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">    &#125;<span class="comment">//存图</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopSort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论">数论</h1><h2 id="质数">质数</h2><h3 id="试除法判断质数">试除法判断质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a/ i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s++;</span><br><span class="line">                    a /= i;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//如果有一个比较大的因子，就输出</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法求质数">筛法求质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;<span class="comment">//如果未被标记过说明是质数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回质数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数">约数</h2><h3 id="试除法求约数">试除法求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;  cin &gt;&gt; a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//用来存储a的所有约数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(a / i != i) res.<span class="built_in">push_back</span>(a / i);<span class="comment">//保证不重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : res)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数个数为<spanclass="math inline">\((x_1+1)(x_2+1)...(x_k+1)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> +<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[i]++;</span><br><span class="line">                a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;<span class="number">1</span>) mp[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y] : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ret * (y + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ret % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><p>把一个数N写成<span class="math inline">\(N=p_1 ^ {x_1}\cdotp_2^{x_2}\cdot ... \cdot p_k^{x_k}\)</span>, 则约数之和为<spanclass="math inline">\((    p_1^0+p_1^1+..._+p_1^{x_1})\times...\times(p_k^0+p_k^1+...+p_k^{x_k})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//存储质因数对应的个数</span></span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x, y]: mp)</span><br><span class="line">&#123;</span><br><span class="line">    ll t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y--)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (t * x + <span class="number">1</span>) % mod;<span class="comment">//得到每个质因子对应的加和值</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = res * t % mod;<span class="comment">//将所有质因子的加和值乘起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划">动态规划</h1><h2 id="背包问题">背包问题</h2><p><ahref="https://blog.csdn.net/raelum/article/details/128996521">参考大佬的代码</a></p><h3 id="背包问题-1">01背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/28/hello-world/"/>
      <url>/2024/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><imgsrc="https://raw.githubusercontent.com/LUCKYCYYYY/PictureBed/master/img/202405241310482.png" /></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
